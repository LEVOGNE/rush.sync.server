// ===== DATEIEN NACH ERWEITERUNGEN =====
// ## FILE: src/ui/widget.rs
// ## BEGIN ##
// ## FILE: src/ui/widget.rs - KOMPRIMIERTE VERSION
use crate::core::prelude::*;
use crate::input::state::InputStateBackup;
use ratatui::widgets::Paragraph;

/// Core Widget trait - essentielles Rendering
pub trait Widget {
    fn render(&self) -> Paragraph<'_>;
    fn handle_input(&mut self, key: KeyEvent) -> Option<String>;
}

/// Cursor-f√§hige Widgets
pub trait CursorWidget: Widget {
    fn render_with_cursor(&self) -> (Paragraph<'_>, Option<(u16, u16)>);
}

/// State-Management f√ºr Widgets
pub trait StatefulWidget<T = InputStateBackup> {
    fn export_state(&self) -> T;
    fn import_state(&mut self, state: T);
}

/// Animierte Widgets (Blinken, etc.)
pub trait AnimatedWidget {
    fn tick(&mut self);
}

/// Vollst√§ndiges Input-Widget (kombiniert alle Traits)
pub trait InputWidget: Widget + CursorWidget + StatefulWidget + AnimatedWidget {}

// Blanket Implementation
impl<T> InputWidget for T where T: Widget + CursorWidget + StatefulWidget + AnimatedWidget {}

/// Widget Utilities
pub mod utils {
    use super::*;
    use ratatui::{
        style::Style,
        widgets::{Block, Borders},
    };

    pub fn simple_text(content: &str, style: Style) -> Paragraph<'_> {
        Paragraph::new(content.to_string())
            .style(style)
            .block(Block::default().borders(Borders::NONE))
    }

    pub fn has_cursor<T: Widget>(_: &T) -> bool {
        std::any::type_name::<T>().contains("CursorWidget")
    }
}

/// Beispiel-Implementierungen f√ºr Tests
#[cfg(test)]
mod examples {
    use super::*;

    #[derive(Debug)]
    pub struct SimpleWidget(String);

    impl Widget for SimpleWidget {
        fn render(&self) -> Paragraph<'_> {
            utils::simple_text(&self.0, ratatui::style::Style::default())
        }

        fn handle_input(&mut self, _: KeyEvent) -> Option<String> {
            None
        }
    }

    #[derive(Debug)]
    pub struct FullInputWidget {
        content: String,
        cursor_pos: usize,
        visible: bool,
    }

    impl Widget for FullInputWidget {
        fn render(&self) -> Paragraph<'_> {
            self.render_with_cursor().0
        }

        fn handle_input(&mut self, _: KeyEvent) -> Option<String> {
            Some("handled".to_string())
        }
    }

    impl CursorWidget for FullInputWidget {
        fn render_with_cursor(&self) -> (Paragraph<'_>, Option<(u16, u16)>) {
            let para = utils::simple_text(&self.content, ratatui::style::Style::default());
            let cursor = if self.visible {
                Some((self.cursor_pos as u16, 0))
            } else {
                None
            };
            (para, cursor)
        }
    }

    impl StatefulWidget for FullInputWidget {
        fn export_state(&self) -> InputStateBackup {
            InputStateBackup {
                content: self.content.clone(),
                history: vec![],
                cursor_pos: self.cursor_pos,
            }
        }

        fn import_state(&mut self, state: InputStateBackup) {
            self.content = state.content;
            self.cursor_pos = state.cursor_pos;
        }
    }

    impl AnimatedWidget for FullInputWidget {
        fn tick(&mut self) {
            self.visible = !self.visible;
        }
    }

    #[test]
    fn test_widget_system() {
        let mut simple = SimpleWidget("test".to_string());
        let _para = simple.render();
        assert_eq!(simple.handle_input(KeyEvent::from(KeyCode::Enter)), None);

        let mut full = FullInputWidget {
            content: "input".to_string(),
            cursor_pos: 5,
            visible: true,
        };

        // Test alle Traits
        let _para = full.render();
        let (_para, cursor) = full.render_with_cursor();
        assert_eq!(cursor, Some((5, 0)));

        let state = full.export_state();
        full.content = "changed".to_string();
        full.import_state(state);
        assert_eq!(full.content, "input");

        let old_visible = full.visible;
        full.tick();
        assert_ne!(full.visible, old_visible);
    }
}

/// Migration Helper f√ºr bestehenden Code
pub mod compat {
    pub use super::{
        AnimatedWidget as Tickable, CursorWidget as RenderWithCursor,
        InputWidget as InputWidgetFull, StatefulWidget as Stateful, Widget,
    };
}

// ## END ##

// ## FILE: src/ui/color.rs
// ## BEGIN ##
// =====================================================
// ANTI-FLICKER COLOR SYSTEM: src/ui/color.rs
// =====================================================

use crate::core::prelude::*;
use log::Level;
use once_cell::sync::Lazy;
use std::collections::HashMap;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct AppColor(Color);

// ‚úÖ BESTEHENDE COLOR_MAP (unver√§ndert f√ºr Kategorien)
static COLOR_MAP: Lazy<HashMap<&'static str, Color>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // Standard-Farben
    map.insert("black", Color::Black);
    map.insert("red", Color::Red);
    map.insert("green", Color::Green);
    map.insert("yellow", Color::Yellow);
    map.insert("blue", Color::Blue);
    map.insert("magenta", Color::Magenta);
    map.insert("cyan", Color::Cyan);
    map.insert("gray", Color::Gray);
    map.insert("darkgray", Color::DarkGray);
    map.insert("lightred", Color::LightRed);
    map.insert("lightgreen", Color::LightGreen);
    map.insert("lightyellow", Color::LightYellow);
    map.insert("lightblue", Color::LightBlue);
    map.insert("lightmagenta", Color::LightMagenta);
    map.insert("lightcyan", Color::LightCyan);
    map.insert("white", Color::White);

    // Kategorien
    map.insert("error", Color::Red);
    map.insert("warning", Color::Yellow);
    map.insert("warn", Color::Yellow);
    map.insert("info", Color::Green);
    map.insert("debug", Color::Blue);
    map.insert("trace", Color::White);
    map.insert("lang", Color::Cyan);
    map.insert("version", Color::LightBlue);
    map.insert("startup", Color::Magenta);
    map.insert("theme", Color::LightMagenta);

    map
});

// ‚úÖ NEUER ANTI-FLICKER: PRE-COMPILED DISPLAY -> COLOR MAP
static DISPLAY_COLOR_MAP: Lazy<HashMap<&'static str, Color>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // ‚úÖ ALLE DISPLAY-TEXTE DIREKT ZU FARBEN (ZERO DELAY!)

    // Best√§tigungen ‚Üí GELB
    map.insert("CONFIRM", Color::Yellow);
    map.insert("BEST√ÑTIGEN", Color::Yellow);

    // Fehler ‚Üí ROT
    map.insert("ERROR", Color::Red);
    map.insert("FEHLER", Color::Red);
    map.insert("RENDER", Color::Red);

    // Warnungen ‚Üí GELB
    map.insert("WARN", Color::Yellow);
    map.insert("WARNING", Color::Yellow);
    map.insert("TERMINAL", Color::Yellow);

    // Info ‚Üí GR√úN
    map.insert("INFO", Color::Green);
    map.insert("CLIPBOARD", Color::Green);
    map.insert("HISTORY", Color::Green);
    map.insert("HISTORIE", Color::Green);
    map.insert("LOG_LEVEL", Color::Green);
    map.insert("SYSTEM", Color::Green);

    // Debug ‚Üí BLAU
    map.insert("DEBUG", Color::Blue);

    // Trace ‚Üí WEI√ü
    map.insert("TRACE", Color::White);

    // Spezielle ‚Üí SPEZIALFARBEN
    map.insert("THEME", Color::LightMagenta); // PINK!
    map.insert("LANG", Color::Cyan); // CYAN
    map.insert("SPRACHE", Color::Cyan); // CYAN
    map.insert("VERSION", Color::LightBlue); // LIGHT_BLUE
    map.insert("READY", Color::Magenta); // MAGENTA
    map.insert("BEREIT", Color::Magenta); // MAGENTA

    map
});

impl AppColor {
    pub fn new(color: Color) -> Self {
        Self(color)
    }

    // ‚úÖ ANTI-FLICKER: ZERO-DELAY DISPLAY TEXT LOOKUP
    pub fn from_display_text(display_text: &str) -> Self {
        let normalized = display_text.trim().to_uppercase();

        // üöÄ DIREKT HIT: O(1) lookup, KEIN calculation, KEIN fallback!
        let color = DISPLAY_COLOR_MAP
            .get(normalized.as_str())
            .copied()
            .unwrap_or(Color::Green); // info fallback

        Self(color)
    }

    // ‚úÖ PERFORMANCE-OPTIMIERT: Category lookup
    pub fn from_category(category: &str) -> Self {
        let normalized = category.trim().to_lowercase();
        let color = COLOR_MAP
            .get(normalized.as_str())
            .copied()
            .unwrap_or(Color::Green);
        Self(color)
    }

    // ‚úÖ LEGACY SUPPORT: Vereinfacht f√ºr andere Stellen
    pub fn from_any<T: Into<String>>(source: T) -> Self {
        let key = source.into().to_lowercase();
        let color = COLOR_MAP.get(key.as_str()).copied().unwrap_or(Color::Green);
        Self(color)
    }

    pub fn from_log_level(level: Level) -> Self {
        Self::from_category(&level.to_string())
    }

    pub fn from_string(color_str: &str) -> crate::core::error::Result<Self> {
        let normalized = color_str.trim().to_lowercase();
        let color = COLOR_MAP
            .get(normalized.as_str())
            .copied()
            .ok_or_else(|| AppError::Validation(format!("Invalid color: {}", color_str)))?;
        Ok(Self(color))
    }

    // ‚úÖ DEBUG: Performance monitoring
    pub fn from_display_text_with_timing(display_text: &str) -> (Self, std::time::Duration) {
        let start = std::time::Instant::now();
        let color = Self::from_display_text(display_text);
        let duration = start.elapsed();
        (color, duration)
    }

    // ‚úÖ UTILITIES
    pub fn available_display_texts() -> Vec<&'static str> {
        DISPLAY_COLOR_MAP.keys().copied().collect()
    }

    pub fn available_categories() -> Vec<&'static str> {
        COLOR_MAP.keys().copied().collect()
    }

    // Bestehende Methoden...
    pub fn format_message(&self, level: &str, message: &str) -> String {
        if level.is_empty() {
            format!("\x1B[{}m{}\x1B[0m", self.to_ansi_code(), message)
        } else {
            format!(
                "\x1B[{}m[{}] {}\x1B[0m",
                self.to_ansi_code(),
                level,
                message
            )
        }
    }

    pub fn to_ansi_code(&self) -> u8 {
        match self.0 {
            Color::Black => 30,
            Color::Red => 31,
            Color::Green => 32,
            Color::Yellow => 33,
            Color::Blue => 34,
            Color::Magenta => 35,
            Color::Cyan => 36,
            Color::Gray => 37,
            Color::DarkGray => 90,
            Color::LightRed => 91,
            Color::LightGreen => 92,
            Color::LightYellow => 93,
            Color::LightBlue => 94,
            Color::LightMagenta => 95,
            Color::LightCyan => 96,
            Color::White => 97,
            _ => 37,
        }
    }

    pub fn to_name(&self) -> &'static str {
        COLOR_MAP
            .iter()
            .find(|(_, &v)| v == self.0)
            .map(|(k, _)| *k)
            .unwrap_or("gray")
    }
}

// Traits unver√§ndert...
impl From<AppColor> for Color {
    fn from(app_color: AppColor) -> Self {
        app_color.0
    }
}

impl From<&AppColor> for Color {
    fn from(app_color: &AppColor) -> Self {
        app_color.0
    }
}

impl Default for AppColor {
    fn default() -> Self {
        Self(Color::Gray)
    }
}

// ## END ##

// ## FILE: src/ui/terminal.rs
// ## BEGIN ##
use crate::core::constants::APP_TITLE;
use crate::core::prelude::*;
use crate::i18n::get_translation;
use crossterm::{
    cursor, execute,
    style::ResetColor,
    terminal::{
        self, disable_raw_mode, enable_raw_mode, ClearType, EnterAlternateScreen,
        LeaveAlternateScreen,
    },
};
use std::io::Stdout;

pub struct TerminalManager {
    stdout: Stdout,
    raw_mode_enabled: bool,
}

impl TerminalManager {
    pub async fn new() -> Result<Self> {
        Ok(Self {
            stdout: io::stdout(),
            raw_mode_enabled: false,
        })
    }

    pub async fn setup(&mut self) -> Result<()> {
        self.enable_full_raw_mode().await?;
        execute!(
            self.stdout,
            terminal::Clear(ClearType::All),
            EnterAlternateScreen,
            terminal::DisableLineWrap,
            terminal::SetTitle(APP_TITLE),
            crossterm::style::Print("\x1B]112\x07"),
            crossterm::style::Print("\x1B[0 q"),
            cursor::Hide
        )?;
        Ok(())
    }

    async fn enable_full_raw_mode(&mut self) -> Result<()> {
        enable_raw_mode()?;
        self.raw_mode_enabled = true;
        execute!(
            self.stdout,
            crossterm::style::Print("\x1B[?1000h"),
            crossterm::style::Print("\x1B[?1002h"),
            crossterm::style::Print("\x1B[?1015h"),
            crossterm::style::Print("\x1B[?1006h"),
            crossterm::style::Print("\x1B[?1049h")
        )?;
        Ok(())
    }

    pub async fn cleanup(&mut self) -> Result<()> {
        log::info!("üîÑ Starting terminal cleanup...");

        if self.raw_mode_enabled {
            self.disable_full_raw_mode().await?;
        }

        // Multi-standard cursor reset for maximum compatibility
        execute!(
            self.stdout,
            crossterm::style::Print("\x1B]12;\x07"),
            crossterm::style::Print("\x1B]Pl\x1B\\"),
            crossterm::style::Print("\x1B]112\x07"),
            crossterm::style::Print("\x1B[0 q"),
            ResetColor,
            cursor::Show
        )?;

        execute!(
            self.stdout,
            terminal::Clear(ClearType::All),
            LeaveAlternateScreen,
            terminal::EnableLineWrap,
            cursor::MoveTo(0, 0)
        )?;

        // Final reset - guaranteed standard terminal
        execute!(
            self.stdout,
            crossterm::style::Print("\x1B[!p"),
            crossterm::style::Print("\x1B]12;white\x07"),
            crossterm::style::Print("\x1B[0 q"),
            crossterm::style::Print("\x1B[?25h"),
            ResetColor
        )?;

        self.stdout.flush()?;
        log::info!("{}", get_translation("terminal.cleanup.done", &[]));
        Ok(())
    }

    async fn disable_full_raw_mode(&mut self) -> Result<()> {
        if !self.raw_mode_enabled {
            return Ok(());
        }

        execute!(
            self.stdout,
            crossterm::style::Print("\x1B[?1000l"),
            crossterm::style::Print("\x1B[?1002l"),
            crossterm::style::Print("\x1B[?1015l"),
            crossterm::style::Print("\x1B[?1006l"),
            crossterm::style::Print("\x1B[?1049l")
        )?;

        disable_raw_mode()?;
        self.raw_mode_enabled = false;
        Ok(())
    }

    pub fn is_raw_mode_enabled(&self) -> bool {
        self.raw_mode_enabled
    }

    pub async fn force_raw_mode(&mut self) -> Result<()> {
        if !self.raw_mode_enabled {
            log::warn!("üö® Raw mode was lost, re-enabling...");
            self.enable_full_raw_mode().await?;
        }
        Ok(())
    }
}

impl Drop for TerminalManager {
    fn drop(&mut self) {
        if self.raw_mode_enabled {
            let _ = disable_raw_mode();
            let _ = execute!(
                std::io::stdout(),
                terminal::LeaveAlternateScreen,
                cursor::Show,
                ResetColor
            );
            log::warn!("üö® Emergency terminal cleanup in destructor");
        }
    }
}

// ## END ##

// ## FILE: src/ui/screen.rs
// ## BEGIN ##
// ## FILE: src/ui/screen.rs - KOMPRIMIERTE VERSION
use crate::commands::{history::HistoryKeyboardHandler, lang::LanguageService, theme::ThemeSystem};
use crate::core::prelude::*;
use crate::input::{
    keyboard::{KeyAction, KeyboardManager},
    state::InputState,
    AppEvent, EventHandler,
};
use crate::output::display::MessageDisplay;
use crate::ui::{
    color::AppColor,
    terminal::TerminalManager,
    viewport::ScrollDirection,
    widget::{AnimatedWidget, CursorWidget, StatefulWidget, Widget},
};
use crossterm::{event::KeyEvent, execute};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::{
    io::{self, Stdout},
    sync::OnceLock,
};

pub type TerminalBackend = Terminal<CrosstermBackend<Stdout>>;

pub struct ScreenManager {
    terminal: TerminalBackend,
    pub message_display: MessageDisplay,
    input_state: InputState,
    config: Config,
    terminal_mgr: TerminalManager,
    events: EventHandler,
    keyboard_manager: KeyboardManager,
    waiting_for_restart_confirmation: bool,
}

#[derive(Clone)]
struct TerminalInfo {
    term_program: String,
    tmux: bool,
}
static TERMINAL_INFO: OnceLock<TerminalInfo> = OnceLock::new();

impl ScreenManager {
    pub async fn new(config: &Config) -> Result<Self> {
        let mut terminal_mgr = TerminalManager::new().await?;
        terminal_mgr.setup().await?;

        let backend = CrosstermBackend::new(io::stdout());
        let terminal = Terminal::new(backend)?;
        let size = terminal.size()?;

        let mut screen_manager = Self {
            terminal,
            terminal_mgr,
            message_display: MessageDisplay::new(config, size.width, size.height),
            input_state: InputState::new(config),
            config: config.clone(),
            events: EventHandler::new(config.poll_rate),
            keyboard_manager: KeyboardManager::new(),
            waiting_for_restart_confirmation: false,
        };

        let version = crate::core::constants::VERSION;
        let startup_msg = get_command_translation("system.startup.version", &[version]);
        screen_manager
            .message_display
            .add_message_instant(startup_msg);

        // ‚úÖ FERTIG!
        Ok(screen_manager)
    }

    pub async fn run(&mut self) -> Result<()> {
        let result = loop {
            if let Some(event) = self.events.next().await {
                match event {
                    AppEvent::Input(key) => {
                        if self.handle_input(key).await? {
                            self.events.shutdown().await;
                            break Ok(());
                        }
                    }
                    AppEvent::Resize(w, h) => self.handle_resize(w, h).await?,
                    AppEvent::Tick => self.handle_tick().await?,
                }
            }
            self.render().await?;
        };
        self.terminal_mgr.cleanup().await?;
        result
    }

    // ‚úÖ KOMPRIMIERTES INPUT HANDLING
    async fn handle_input(&mut self, key: KeyEvent) -> Result<bool> {
        // History handling
        if HistoryKeyboardHandler::get_history_action(&key).is_some() {
            if let Some(input) = self.input_state.handle_input(key) {
                self.process_special_input(&input).await;
            }
            return Ok(false);
        }

        // Scroll/Action handling
        match self.keyboard_manager.get_action(&key) {
            KeyAction::ScrollUp => {
                self.message_display.handle_scroll(ScrollDirection::Up, 1);
                Ok(false)
            }
            KeyAction::ScrollDown => {
                self.message_display.handle_scroll(ScrollDirection::Down, 1);
                Ok(false)
            }
            KeyAction::PageUp => {
                self.message_display
                    .handle_scroll(ScrollDirection::PageUp, 0);
                Ok(false)
            }
            KeyAction::PageDown => {
                self.message_display
                    .handle_scroll(ScrollDirection::PageDown, 0);
                Ok(false)
            }
            KeyAction::Submit => self.handle_submit(key).await,
            KeyAction::Quit => Ok(true),
            _ => {
                if let Some(input) = self.input_state.handle_input(key) {
                    self.process_special_input(&input).await;
                }
                Ok(false)
            }
        }
    }

    async fn handle_submit(&mut self, key: KeyEvent) -> Result<bool> {
        let Some(input) = self.input_state.handle_input(key) else {
            return Ok(false);
        };

        // üéØ KRITISCHER FIX: SYSTEM-COMMANDS ZUERST PR√úFEN UND AUSF√úHREN!
        //    (BEVOR wir sie als Text ausgeben!)

        if input == "__CLEAR__" {
            self.message_display.clear_messages();
            return Ok(false);
        }

        if input == "__EXIT__" {
            return Ok(true); // ‚úÖ BEENDE PROGRAMM SOFORT!
        }

        if input.starts_with("__RESTART") {
            self.handle_restart(&input).await;
            return Ok(false);
        }

        // ‚úÖ Process special messages (Theme, Language updates)
        if self.process_special_input(&input).await {
            return Ok(false);
        }

        // ‚úÖ Add message to display (NUR wenn es KEIN System-Command war)
        let cmd = input.trim().to_lowercase();
        if input.starts_with("__")
            || ["theme", "help", "lang"]
                .iter()
                .any(|&c| cmd.starts_with(c))
        {
            self.message_display.add_message_instant(input.clone());
        } else {
            self.message_display.add_message(input.clone());
        }

        Ok(false)
    }

    // ‚úÖ VEREINFACHTE SPECIAL INPUT PROCESSING
    async fn process_special_input(&mut self, input: &str) -> bool {
        // Language updates
        if let Some(processed) = LanguageService::process_save_message(input).await {
            self.message_display.add_message_instant(processed);
            return true;
        }

        // Theme updates
        if let Some(processed) = self.process_theme_update(input).await {
            self.message_display.add_message_instant(processed);
            return true;
        }

        false
    }

    // ‚úÖ KOMPRIMIERTES THEME UPDATE
    async fn process_theme_update(&mut self, message: &str) -> Option<String> {
        if !message.starts_with("__LIVE_THEME_UPDATE__") {
            return None;
        }

        let parts: Vec<&str> = message.split("__MESSAGE__").collect();
        if parts.len() != 2 {
            return None;
        }

        let theme_name = parts[0].replace("__LIVE_THEME_UPDATE__", "");
        let display_msg = parts[1];

        // Load and apply theme
        let theme_system = ThemeSystem::load().ok()?;
        let theme_def = theme_system.get_theme(&theme_name)?;
        let new_theme = self.create_theme(theme_def).ok()?;

        // Backup state, update config, restore state
        let backup = self.input_state.export_state();
        self.config.theme = new_theme;
        self.config.current_theme_name = theme_name;

        self.message_display.clear_messages();
        self.message_display.update_config(&self.config);

        self.input_state = InputState::new(&self.config);
        self.input_state.import_state(backup);

        Some(display_msg.to_string())
    }

    fn create_theme(
        &self,
        def: &crate::commands::theme::ThemeDefinition,
    ) -> Result<crate::core::config::Theme> {
        Ok(crate::core::config::Theme {
            input_text: AppColor::from_string(&def.input_text)?,
            input_bg: AppColor::from_string(&def.input_bg)?,
            output_text: AppColor::from_string(&def.output_text)?,
            output_bg: AppColor::from_string(&def.output_bg)?,
            input_cursor_prefix: def.input_cursor_prefix.clone(),
            input_cursor_color: AppColor::from_string(&def.input_cursor_color)?,
            input_cursor: def.input_cursor.clone(),
            output_cursor: def.output_cursor.clone(),
            output_cursor_color: AppColor::from_string(&def.output_cursor_color)?,
        })
    }

    async fn handle_restart(&mut self, input: &str) {
        if input.starts_with("__RESTART_WITH_MSG__") {
            let msg = input.replace("__RESTART_WITH_MSG__", "").trim().to_string();
            if !msg.is_empty() {
                self.message_display.add_message_instant(msg);
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            }
        }

        if let Err(e) = self.perform_restart().await {
            self.message_display
                .add_message_instant(get_translation("screen.restart.failed", &[&e.to_string()]));
        }
    }

    async fn handle_resize(&mut self, width: u16, height: u16) -> Result<()> {
        self.message_display.handle_resize(width, height);
        Ok(())
    }

    async fn handle_tick(&mut self) -> Result<()> {
        self.message_display.update_typewriter();
        self.input_state.tick();
        Ok(())
    }

    // ‚úÖ KOMPRIMIERTES RENDERING
    async fn render(&mut self) -> Result<()> {
        let (input_widget, cursor_pos) = self.input_state.render_with_cursor();

        let viewport_ok = self.message_display.viewport().is_usable();
        let output_area = self.message_display.viewport().output_area();
        let input_area = self.message_display.viewport().input_area();

        let (messages, config, layout, cursor_state) =
            self.message_display.create_output_widget_for_rendering();

        self.terminal.draw(|frame| {
            let size = frame.size();

            // Emergency cases with i18n
            if size.width < 10 || size.height < 5 {
                let widget = ratatui::widgets::Paragraph::new(get_translation(
                    "screen.render.terminal_too_small",
                    &[],
                ))
                .block(ratatui::widgets::Block::default());
                frame.render_widget(widget, size);
                return;
            }

            if !viewport_ok || !output_area.is_valid() || !input_area.is_valid() {
                let widget = ratatui::widgets::Paragraph::new(get_translation(
                    "screen.render.viewport_error",
                    &[],
                ))
                .block(ratatui::widgets::Block::default());
                frame.render_widget(widget, size);
                return;
            }

            // Check bounds
            if Self::exceeds_bounds(&output_area, &input_area, size) {
                return;
            }

            // Render normally
            let output_widget = crate::output::display::create_output_widget(
                &messages,
                layout,
                &config,
                cursor_state,
            );

            frame.render_widget(output_widget, output_area.as_rect());
            frame.render_widget(input_widget, input_area.as_rect());

            if let Some((x, y)) = cursor_pos {
                frame.set_cursor(input_area.x + 3 + x, input_area.y + 1 + y);
            }
        })?;

        // Cursor styling (unchanged)
        if cursor_pos.is_some() {
            self.apply_cursor_styling()?;
        } else {
            execute!(std::io::stdout(), crossterm::style::Print("\x1B[?25l"))?;
        }
        Ok(())
    }

    // ‚úÖ UTILITY METHODS
    fn exceeds_bounds(
        output: &crate::ui::viewport::LayoutArea,
        input: &crate::ui::viewport::LayoutArea,
        size: ratatui::layout::Rect,
    ) -> bool {
        output.x + output.width > size.width
            || output.y + output.height > size.height
            || input.x + input.width > size.width
            || input.y + input.height > size.height
    }

    // ‚úÖ CURSOR STYLING (komprimiert)
    fn apply_cursor_styling(&self) -> Result<()> {
        let form = match self.config.theme.input_cursor.to_uppercase().as_str() {
            "PIPE" => "\x1B[6 q",
            "UNDERSCORE" => "\x1B[4 q",
            "BLOCK" => "\x1B[2 q",
            _ => "\x1B[6 q",
        };

        let color_cmds = self.get_cursor_colors(&self.config.theme.input_cursor_color);

        execute!(std::io::stdout(), crossterm::style::Print(form))?;
        for cmd in color_cmds {
            execute!(std::io::stdout(), crossterm::style::Print(cmd))?;
        }
        execute!(std::io::stdout(), crossterm::style::Print("\x1B[?25h"))?;
        Ok(())
    }

    fn get_cursor_colors(&self, color: &AppColor) -> Vec<String> {
        let (r, g, b) = self.get_rgb(color);
        let info = Self::terminal_info();

        if info.tmux {
            return vec![format!(
                "\x1BPtmux;\x1B\x1B]12;#{:02x}{:02x}{:02x}\x07\x1B\\",
                r, g, b
            )];
        }

        let base = format!("\x1B]12;#{:02x}{:02x}{:02x}\x07", r, g, b);
        match info.term_program.as_str() {
            "Apple_Terminal" => vec![base],
            p if p.starts_with("iTerm") => {
                vec![format!("\x1B]Pl{:02x}{:02x}{:02x}\x1B\\", r, g, b), base]
            }
            _ => vec![base],
        }
    }

    fn get_rgb(&self, color: &AppColor) -> (u8, u8, u8) {
        match color.to_name() {
            "black" => (0, 0, 0),
            "red" => (255, 0, 0),
            "green" => (0, 255, 0),
            "yellow" => (255, 255, 0),
            "blue" => (0, 0, 255),
            "magenta" => (255, 0, 255),
            "cyan" => (0, 255, 255),
            "white" => (255, 255, 255),
            "gray" => (128, 128, 128),
            "darkgray" => (64, 64, 64),
            _ => (255, 255, 255),
        }
    }

    fn terminal_info() -> &'static TerminalInfo {
        TERMINAL_INFO.get_or_init(|| TerminalInfo {
            term_program: std::env::var("TERM_PROGRAM").unwrap_or_default(),
            tmux: std::env::var("TMUX").is_ok(),
        })
    }

    async fn perform_restart(&mut self) -> Result<()> {
        execute!(
            std::io::stdout(),
            crossterm::style::Print("\x1B[0 q"),
            crossterm::style::Print("\x1B[?25h")
        )?;

        self.terminal_mgr.cleanup().await?;
        self.terminal_mgr = TerminalManager::new().await?;
        self.terminal_mgr.setup().await?;

        let backend = CrosstermBackend::new(io::stdout());
        self.terminal = Terminal::new(backend)?;
        let size = self.terminal.size()?;

        self.message_display = MessageDisplay::new(&self.config, size.width, size.height);
        self.input_state = InputState::new(&self.config);
        self.waiting_for_restart_confirmation = false;

        self.message_display
            .add_message(get_translation("screen.restart.success", &[]));
        Ok(())
    }

    // ‚úÖ PUBLIC API METHODS
    pub async fn switch_theme_safely(&mut self, theme_name: &str) -> Result<String> {
        let system = ThemeSystem::load().map_err(|e| {
            AppError::Validation(get_translation(
                "screen.theme.load_failed",
                &[&e.to_string()],
            ))
        })?;

        let def = system.get_theme(theme_name).ok_or_else(|| {
            AppError::Validation(get_translation("screen.theme.not_found", &[theme_name]))
        })?;

        let theme = self.create_theme(def)?;
        let backup = self.input_state.export_state();

        self.config.theme = theme;
        self.config.current_theme_name = theme_name.to_string();
        self.message_display.update_config(&self.config);

        self.input_state = InputState::new(&self.config);
        self.input_state.import_state(backup);

        Ok(get_translation(
            "screen.theme.switched_success",
            &[&theme_name.to_uppercase()],
        ))
    }

    // ‚úÖ I18N VALIDATION (komprimiert)
    pub fn validate_i18n_keys() -> Vec<String> {
        [
            "screen.theme.failed",
            "screen.render.too_small.text",
            "screen.render.viewport_error.text",
            "system.commands.restart.success",
        ]
        .iter()
        .filter(|&&key| !crate::i18n::has_translation(key))
        .map(|&key| key.to_string())
        .collect()
    }
}

// ## END ##

// ## FILE: src/ui/mod.rs
// ## BEGIN ##
// src/ui/mod.rs
pub mod color;
pub mod cursor;
pub mod screen;
pub mod terminal;
pub mod viewport; // ‚úÖ ADDED: Missing viewport module
pub mod widget;

// ## END ##

// ## FILE: src/ui/cursor.rs
// ## BEGIN ##
use crate::core::config::Config;
use crate::ui::color::AppColor;
use ratatui::prelude::{Span, Style};
use std::time::{Duration, Instant};
use unicode_segmentation::UnicodeSegmentation;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CursorKind {
    Input,
    Output,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CursorType {
    Block,
    Pipe,
    Underscore,
}

impl std::str::FromStr for CursorType {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s.to_uppercase().as_str() {
            "BLOCK" => CursorType::Block,
            "UNDERSCORE" => CursorType::Underscore,
            _ => CursorType::Pipe, // Default fallback
        })
    }
}

impl CursorType {
    pub fn parse_type(s: &str) -> CursorType {
        s.parse().unwrap_or(CursorType::Pipe)
    }
    pub fn symbol(self) -> &'static str {
        match self {
            CursorType::Block => "‚ñà",
            CursorType::Pipe => "|",
            CursorType::Underscore => "_",
        }
    }
}

#[derive(Debug, Clone)]
pub struct UiCursor {
    pub kind: CursorKind,
    pub ctype: CursorType,
    pub color: AppColor,
    pub fg: AppColor,
    pub position: usize,
    pub text_length: usize,
    pub blink_visible: bool,
    last_blink: Instant,
    blink_interval: Duration,
}

impl UiCursor {
    // Factory methods
    pub fn from_config(config: &Config, kind: CursorKind) -> Self {
        let (cursor_str, color, fg) = match kind {
            CursorKind::Input => (
                &config.theme.input_cursor,
                config.theme.input_cursor_color,
                config.theme.input_text,
            ),
            CursorKind::Output => (
                &config.theme.output_cursor,
                config.theme.output_cursor_color,
                config.theme.output_text,
            ),
        };

        Self {
            kind,
            ctype: CursorType::parse_type(cursor_str),
            color,
            fg,
            position: 0,
            text_length: 0,
            blink_visible: true,
            last_blink: Instant::now(),
            blink_interval: Duration::from_millis(530),
        }
    }

    pub fn for_typewriter() -> Self {
        Self {
            kind: CursorKind::Output,
            ctype: CursorType::Pipe,
            color: AppColor::default(),
            fg: AppColor::default(),
            position: 0,
            text_length: 0,
            blink_visible: true,
            last_blink: Instant::now(),
            blink_interval: Duration::from_millis(530),
        }
    }

    // Config updates
    pub fn update_from_config(&mut self, config: &Config) {
        let (cursor_str, color, fg) = match self.kind {
            CursorKind::Input => (
                &config.theme.input_cursor,
                config.theme.input_cursor_color,
                config.theme.input_text,
            ),
            CursorKind::Output => (
                &config.theme.output_cursor,
                config.theme.output_cursor_color,
                config.theme.output_text,
            ),
        };
        self.ctype = CursorType::parse_type(cursor_str);
        self.color = color;
        self.fg = fg;
    }

    pub fn update_from_config_explicit(&mut self, config: &Config, kind: CursorKind) {
        self.kind = kind;
        self.update_from_config(config);
    }

    // Blink management
    pub fn update_blink(&mut self) {
        if self.last_blink.elapsed() >= self.blink_interval {
            self.blink_visible = !self.blink_visible;
            self.last_blink = Instant::now();
        }
    }

    pub fn show_cursor(&mut self) {
        self.blink_visible = true;
        self.last_blink = Instant::now();
    }

    pub fn is_visible(&self) -> bool {
        self.blink_visible
    }

    // Position management - streamlined
    pub fn move_left(&mut self) {
        if self.position > 0 {
            self.position -= 1;
        }
    }
    pub fn move_right(&mut self) {
        if self.position < self.text_length {
            self.position += 1;
        }
    }
    pub fn move_to_start(&mut self) {
        self.position = 0;
    }
    pub fn move_to_end(&mut self) {
        self.position = self.text_length;
    }
    pub fn get_position(&self) -> usize {
        self.position
    }
    pub fn get_current_position(&self) -> usize {
        self.position
    }

    // Text length management
    pub fn update_text_length(&mut self, text: &str) {
        self.text_length = text.graphemes(true).count();
        if self.position > self.text_length {
            self.position = self.text_length;
        }
    }

    pub fn reset_for_empty_text(&mut self) {
        self.position = 0;
        self.text_length = 0;
    }

    // Byte position calculations for text editing
    pub fn get_byte_position(&self, text: &str) -> usize {
        text.grapheme_indices(true)
            .nth(self.position)
            .map(|(i, _)| i)
            .unwrap_or_else(|| text.len())
    }

    pub fn get_prev_byte_position(&self, text: &str) -> usize {
        if self.position == 0 {
            return 0;
        }
        text.grapheme_indices(true)
            .nth(self.position.saturating_sub(1))
            .map(|(i, _)| i)
            .unwrap_or(0)
    }

    pub fn get_next_byte_position(&self, text: &str) -> usize {
        text.grapheme_indices(true)
            .nth(self.position + 1)
            .map(|(i, _)| i)
            .unwrap_or_else(|| text.len())
    }

    // Rendering methods
    pub fn as_span(&self, text: &str, blink: bool) -> Span<'static> {
        if !blink || !self.blink_visible {
            let graphemes: Vec<&str> = text.graphemes(true).collect();
            let ch = graphemes.get(self.position).copied().unwrap_or(" ");
            return Span::styled(ch.to_string(), Style::default().fg(self.fg.into()));
        }

        // Block cursor: invert character under cursor
        let graphemes: Vec<&str> = text.graphemes(true).collect();
        let ch = graphemes.get(self.position).copied().unwrap_or(" ");
        Span::styled(
            ch.to_string(),
            Style::default().fg(self.fg.into()).bg(self.color.into()),
        )
    }

    pub fn create_cursor_span(&self, config: &Config) -> Span<'static> {
        let bg_color = match self.kind {
            CursorKind::Input => config.theme.input_bg.into(),
            CursorKind::Output => config.theme.output_bg.into(),
        };
        Span::styled(
            self.get_symbol().to_string(),
            Style::default().fg(self.color.into()).bg(bg_color),
        )
    }

    pub fn get_symbol(&self) -> &'static str {
        self.ctype.symbol()
    }

    // Debug methods - consolidated
    pub fn debug_info(&self) -> String {
        format!(
            "UiCursor({:?}): type={:?}, pos={}/{}, visible={}, symbol='{}', color='{}', fg='{}'",
            self.kind,
            self.ctype,
            self.position,
            self.text_length,
            self.blink_visible,
            self.get_symbol(),
            self.color.to_name(),
            self.fg.to_name()
        )
    }

    pub fn full_debug(&self) -> String {
        format!("üîç FULL CURSOR DEBUG:\nKind: {:?}\nType: {:?}\nSymbol: '{}'\nCursor Color: '{}'\nText Color: '{}'\nPosition: {}/{}\nVisible: {}",
            self.kind, self.ctype, self.get_symbol(), self.color.to_name(), self.fg.to_name(),
            self.position, self.text_length, self.blink_visible)
    }

    pub fn detailed_debug(&self) -> String {
        format!("üîç DETAILED CURSOR DEBUG:\nüè∑Ô∏è Kind: {:?}\nüéØ Type: {:?} (symbol: '{}')\nüé® Cursor Color: '{}'\nüé® Text Color (fg): '{}'\nüìç Position: {}/{}\nüëÅÔ∏è Visible: {}\n‚è±Ô∏è Last Blink: {:?}",
            self.kind, self.ctype, self.get_symbol(), self.color.to_name(), self.fg.to_name(),
            self.position, self.text_length, self.blink_visible, self.last_blink.elapsed())
    }
}

// Factory functions - streamlined
pub fn create_input_cursor(config: &Config) -> UiCursor {
    UiCursor::from_config(config, CursorKind::Input)
}
pub fn create_output_cursor(config: &Config) -> UiCursor {
    UiCursor::from_config(config, CursorKind::Output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cursor_types() {
        assert_eq!(CursorType::parse_type("BLOCK").symbol(), "‚ñà");
        assert_eq!(CursorType::parse_type("PIPE").symbol(), "|");
        assert_eq!(CursorType::parse_type("UNDERSCORE").symbol(), "_");
        assert_eq!(CursorType::parse_type("unknown").symbol(), "|"); // Fallback to PIPE
    }

    #[test]
    fn test_fromstr_trait() {
        assert_eq!("BLOCK".parse::<CursorType>().unwrap(), CursorType::Block);
        assert_eq!("PIPE".parse::<CursorType>().unwrap(), CursorType::Pipe);
        assert_eq!(
            "UNDERSCORE".parse::<CursorType>().unwrap(),
            CursorType::Underscore
        );
        assert_eq!("unknown".parse::<CursorType>().unwrap(), CursorType::Pipe); // Fallback
    }

    #[test]
    fn test_cursor_position() {
        let config = crate::core::config::Config::default();
        let mut cursor = UiCursor::from_config(&config, CursorKind::Input);

        cursor.update_text_length("hello");
        assert_eq!(cursor.text_length, 5);

        cursor.move_right();
        cursor.move_right();
        assert_eq!(cursor.position, 2);

        cursor.move_to_end();
        assert_eq!(cursor.position, 5);

        cursor.move_to_start();
        assert_eq!(cursor.position, 0);
    }

    #[test]
    fn test_input_cursor_color() {
        let config = crate::core::config::Config::default();
        let cursor = UiCursor::from_config(&config, CursorKind::Input);

        assert_eq!(
            cursor.color.to_name(),
            config.theme.input_cursor_color.to_name()
        );
    }
}

// ## END ##

// ## FILE: src/ui/viewport.rs
// ## BEGIN ##
#[derive(Debug, Clone)]
pub struct Viewport {
    terminal_width: u16,
    terminal_height: u16,
    output_area: LayoutArea,
    input_area: LayoutArea,
    content_height: usize,
    window_height: usize,
    scroll_offset: usize,
    auto_scroll_enabled: bool,
    min_terminal_height: u16,
    min_terminal_width: u16,
}

#[derive(Debug, Clone, Copy)]
pub struct LayoutArea {
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
}

#[derive(Debug, Clone)]
pub enum ViewportEvent {
    TerminalResized {
        width: u16,
        height: u16,
    },
    ContentChanged {
        new_height: usize,
    },
    ScrollRequest {
        direction: ScrollDirection,
        amount: usize,
    },
    ForceAutoScroll,
}

#[derive(Debug, Clone)]
pub enum ScrollDirection {
    Up,
    Down,
    ToTop,
    ToBottom,
    PageUp,
    PageDown,
}

impl LayoutArea {
    pub fn new(x: u16, y: u16, width: u16, height: u16) -> Self {
        Self {
            x,
            y,
            width,
            height,
        }
    }

    pub fn is_valid(&self) -> bool {
        self.width > 0 && self.height > 0
    }

    pub fn as_rect(&self) -> ratatui::layout::Rect {
        ratatui::layout::Rect {
            x: self.x,
            y: self.y,
            width: self.width,
            height: self.height,
        }
    }
}

impl Viewport {
    pub fn new(terminal_width: u16, terminal_height: u16) -> Self {
        let mut viewport = Self {
            terminal_width: terminal_width.max(40),
            terminal_height: terminal_height.max(10),
            output_area: LayoutArea::new(0, 0, 0, 0),
            input_area: LayoutArea::new(0, 0, 0, 0),
            content_height: 0,
            window_height: 0,
            scroll_offset: 0,
            auto_scroll_enabled: true,
            min_terminal_height: 10,
            min_terminal_width: 40,
        };
        viewport.calculate_layout();
        viewport
    }

    pub fn update_terminal_size(&mut self, width: u16, height: u16) -> bool {
        let new_width = width.max(self.min_terminal_width);
        let new_height = height.max(self.min_terminal_height);
        let changed = self.terminal_width != new_width || self.terminal_height != new_height;

        if changed {
            self.terminal_width = new_width;
            self.terminal_height = new_height;
            self.calculate_layout();
            self.adjust_scroll_after_resize();
        }
        changed
    }

    fn calculate_layout(&mut self) {
        // Validate and fix dimensions
        if self.terminal_width < 10 || self.terminal_height < 5 {
            self.terminal_width = self.terminal_width.max(10);
            self.terminal_height = self.terminal_height.max(5);
        }

        let margin = 1u16;
        let available_height = self.terminal_height.saturating_sub(margin * 2);

        // Calculate heights with safety checks
        let input_height = match available_height {
            h if h >= 5 => 3,
            h if h >= 3 => 2,
            _ => 2,
        }
        .min(available_height.saturating_sub(1));

        let output_height = available_height.saturating_sub(input_height).max(1);

        // Create layout areas with emergency fallback
        if input_height < 2 || output_height < 1 {
            self.create_emergency_layout(margin);
        } else {
            self.create_normal_layout(margin, output_height, input_height);
        }

        self.window_height = output_height.max(1) as usize;
        self.validate_layout();
    }

    fn create_emergency_layout(&mut self, margin: u16) {
        let width = self.terminal_width.saturating_sub(margin * 2).max(1);
        self.output_area = LayoutArea::new(
            margin,
            margin,
            width,
            self.terminal_height.saturating_sub(3).max(1),
        );
        self.input_area = LayoutArea::new(margin, self.output_area.height + margin, width, 2);
    }

    fn create_normal_layout(&mut self, margin: u16, output_height: u16, input_height: u16) {
        let width = self.terminal_width.saturating_sub(margin * 2).max(1);
        self.output_area = LayoutArea::new(margin, margin, width, output_height);
        self.input_area = LayoutArea::new(margin, margin + output_height, width, input_height);
    }

    fn validate_layout(&mut self) {
        if !self.output_area.is_valid() || !self.input_area.is_valid() {
            self.output_area = LayoutArea::new(
                0,
                0,
                self.terminal_width.max(1),
                self.terminal_height.saturating_sub(2).max(1),
            );
            self.input_area =
                LayoutArea::new(0, self.output_area.height, self.terminal_width.max(1), 2);
            self.window_height = self.output_area.height.max(1) as usize;
        }
    }

    // Scroll operations - simplified and consolidated
    pub fn scroll_up(&mut self, lines: usize) {
        if lines > 0 {
            self.disable_auto_scroll();
        }
        self.scroll_offset = self.scroll_offset.saturating_sub(lines.max(1));
    }

    pub fn scroll_down(&mut self, lines: usize) {
        self.scroll_offset = self.scroll_offset.saturating_add(lines.max(1));
        self.clamp_scroll_offset();
        if self.is_at_bottom() {
            self.enable_auto_scroll();
        }
    }

    pub fn scroll_to_top(&mut self) {
        self.disable_auto_scroll();
        self.scroll_offset = 0;
    }

    pub fn scroll_to_bottom(&mut self) {
        self.scroll_offset = self.max_scroll_offset();
        self.auto_scroll_enabled = true;
    }

    pub fn page_up(&mut self) {
        self.scroll_up(self.window_height.saturating_sub(1).max(1));
    }

    pub fn page_down(&mut self) {
        self.scroll_down(self.window_height.saturating_sub(1).max(1));
    }

    // Content and auto-scroll management
    pub fn update_content_height(&mut self, new_content_height: usize) {
        self.content_height = new_content_height;
        self.clamp_scroll_offset();
    }

    pub fn update_content_height_silent(&mut self, new_content_height: usize) {
        self.content_height = new_content_height;
        self.clamp_scroll_offset();
    }

    pub fn set_scroll_offset_direct_silent(&mut self, offset: usize) {
        self.scroll_offset = offset.min(self.max_scroll_offset());
    }

    pub fn enable_auto_scroll_silent(&mut self) {
        self.auto_scroll_enabled = true;
    }

    pub fn force_auto_scroll(&mut self) {
        self.enable_auto_scroll_silent();
        self.scroll_to_bottom();
    }

    pub fn set_scroll_offset_direct(&mut self, offset: usize) {
        self.scroll_offset = offset;
        self.clamp_scroll_offset();
    }

    pub fn enable_auto_scroll(&mut self) {
        self.auto_scroll_enabled = true;
    }

    pub fn disable_auto_scroll(&mut self) {
        self.auto_scroll_enabled = false;
    }

    // View calculations
    pub fn get_visible_range(&self) -> (usize, usize) {
        if self.content_height == 0 || self.window_height == 0 {
            return (0, 0);
        }
        let start = self.scroll_offset;
        let end = (start + self.window_height).min(self.content_height);
        (start, end)
    }

    // Getters - streamlined
    pub fn output_area(&self) -> LayoutArea {
        self.output_area
    }
    pub fn input_area(&self) -> LayoutArea {
        self.input_area
    }
    pub fn window_height(&self) -> usize {
        self.window_height
    }
    pub fn content_height(&self) -> usize {
        self.content_height
    }
    pub fn scroll_offset(&self) -> usize {
        self.scroll_offset
    }
    pub fn is_auto_scroll_enabled(&self) -> bool {
        self.auto_scroll_enabled
    }
    pub fn terminal_size(&self) -> (u16, u16) {
        (self.terminal_width, self.terminal_height)
    }

    pub fn is_usable(&self) -> bool {
        self.terminal_width >= self.min_terminal_width
            && self.terminal_height >= self.min_terminal_height
            && self.output_area.is_valid()
            && self.input_area.is_valid()
    }

    pub fn debug_info(&self) -> String {
        format!("Viewport: {}x{}, output: {}x{}+{}+{}, input: {}x{}+{}+{}, content: {}, window: {}, offset: {}, auto: {}, at_bottom: {}, max_offset: {}",
            self.terminal_width, self.terminal_height,
            self.output_area.width, self.output_area.height, self.output_area.x, self.output_area.y,
            self.input_area.width, self.input_area.height, self.input_area.x, self.input_area.y,
            self.content_height, self.window_height, self.scroll_offset, self.auto_scroll_enabled,
            self.is_at_bottom(), self.max_scroll_offset())
    }

    pub fn short_debug(&self) -> String {
        format!(
            "{}x{}, content: {}, offset: {}",
            self.terminal_width, self.terminal_height, self.content_height, self.scroll_offset
        )
    }

    // Event handling - consolidated
    pub fn handle_event(&mut self, event: ViewportEvent) -> bool {
        match event {
            ViewportEvent::TerminalResized { width, height } => {
                self.update_terminal_size(width, height)
            }
            ViewportEvent::ContentChanged { new_height } => {
                self.update_content_height(new_height);
                true
            }
            ViewportEvent::ScrollRequest { direction, amount } => {
                match direction {
                    ScrollDirection::Up => self.scroll_up(amount),
                    ScrollDirection::Down => self.scroll_down(amount),
                    ScrollDirection::ToTop => self.scroll_to_top(),
                    ScrollDirection::ToBottom => self.scroll_to_bottom(),
                    ScrollDirection::PageUp => self.page_up(),
                    ScrollDirection::PageDown => self.page_down(),
                }
                true
            }
            ViewportEvent::ForceAutoScroll => {
                self.force_auto_scroll();
                true
            }
        }
    }

    // Private helpers - streamlined
    fn max_scroll_offset(&self) -> usize {
        self.content_height.saturating_sub(self.window_height)
    }

    fn is_at_bottom(&self) -> bool {
        let max_offset = self.max_scroll_offset();
        self.scroll_offset >= max_offset || max_offset == 0
    }

    fn clamp_scroll_offset(&mut self) {
        self.scroll_offset = self.scroll_offset.min(self.max_scroll_offset());
    }

    fn adjust_scroll_after_resize(&mut self) {
        if self.auto_scroll_enabled {
            self.scroll_to_bottom();
        } else {
            self.clamp_scroll_offset();
        }
    }
}

// ## END ##

// ## FILE: src/core/constants.rs
// ## BEGIN ##
use crate::memory::{register_embedded, ResourceKind};

pub const APP_TITLE: &str = "RUSH SYNC SERVER";
pub const DEFAULT_BUFFER_SIZE: usize = 1000;
pub const DEFAULT_POLL_RATE: u64 = 16;
pub const MIN_POLL_RATE: u64 = 16;
pub const MAX_POLL_RATE: u64 = 1000;
pub const DOUBLE_ESC_THRESHOLD: u64 = 250;
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Registriert die Konstanten im Memory-Manager
pub fn register_constants_to_memory() {
    register_embedded(
        "core:constant:app_title@v1",
        ResourceKind::EmbeddedAsset,
        APP_TITLE.len() as u64,
    );

    register_embedded(
        "core:constant:default_buffer_size@v1",
        ResourceKind::EmbeddedAsset,
        std::mem::size_of_val(&DEFAULT_BUFFER_SIZE) as u64,
    );

    register_embedded(
        "core:constant:default_poll_rate@v1",
        ResourceKind::EmbeddedAsset,
        std::mem::size_of_val(&DEFAULT_POLL_RATE) as u64,
    );

    register_embedded(
        "core:constant:min_poll_rate@v1",
        ResourceKind::EmbeddedAsset,
        std::mem::size_of_val(&MIN_POLL_RATE) as u64,
    );

    register_embedded(
        "core:constant:max_poll_rate@v1",
        ResourceKind::EmbeddedAsset,
        std::mem::size_of_val(&MAX_POLL_RATE) as u64,
    );

    register_embedded(
        "core:constant:double_esc_threshold@v1",
        ResourceKind::EmbeddedAsset,
        std::mem::size_of_val(&DOUBLE_ESC_THRESHOLD) as u64,
    );

    register_embedded(
        "core:constant:version@v1",
        ResourceKind::EmbeddedAsset,
        VERSION.len() as u64,
    );
}

// ## END ##

// ## FILE: src/core/error.rs
// ## BEGIN ##
use crate::core::prelude::*;
use std::io;

#[derive(Debug)]
pub enum AppError {
    Io(io::Error),
    Validation(String),
    Terminal(String),
    Translation(TranslationError),
}

impl From<io::Error> for AppError {
    fn from(err: io::Error) -> Self {
        AppError::Terminal(err.to_string())
    }
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AppError::Io(err) => write!(
                f,
                "{}",
                get_translation("system.error.io_error", &[&err.to_string()])
            ),
            AppError::Validation(msg) => write!(
                f,
                "{}",
                get_translation("system.error.validation_error", &[msg])
            ),
            AppError::Terminal(msg) => write!(
                f,
                "{}",
                get_translation("system.error.terminal_error", &[msg])
            ),
            AppError::Translation(err) => write!(
                f,
                "{}",
                get_translation("system.error.translation_error", &[&err.to_string()])
            ),
        }
    }
}

impl std::error::Error for AppError {}
pub type Result<T> = std::result::Result<T, AppError>;

// ## END ##

// ## FILE: src/core/config.rs
// ## BEGIN ##
// src/core/config.rs - Cleaned and simplified
use crate::core::constants::{DEFAULT_BUFFER_SIZE, DEFAULT_POLL_RATE};
use crate::core::prelude::*;
use crate::proxy::types::{ProxyConfig, ProxyConfigToml};
use crate::ui::color::AppColor;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

// TOML Configuration Structure
#[derive(Debug, Serialize, Deserialize)]
struct ConfigFile {
    general: GeneralConfig,
    #[serde(default)]
    server: Option<ServerConfigToml>,
    #[serde(default)]
    logging: Option<LoggingConfigToml>,
    #[serde(default)]
    theme: Option<HashMap<String, ThemeDefinitionConfig>>,
    language: LanguageConfig,
    proxy: Option<ProxyConfigToml>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GeneralConfig {
    max_messages: usize,
    typewriter_delay: u64,
    input_max_length: usize,
    max_history: usize,
    poll_rate: u64,
    log_level: String,
    #[serde(default = "default_theme")]
    current_theme: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct LanguageConfig {
    current: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct ServerConfigToml {
    #[serde(default = "default_port_start")]
    port_range_start: u16,
    #[serde(default = "default_port_end")]
    port_range_end: u16,
    #[serde(default = "default_max_concurrent")]
    max_concurrent: usize,
    #[serde(default = "default_shutdown_timeout")]
    shutdown_timeout: u64,
    #[serde(default = "default_startup_delay")]
    startup_delay_ms: u64,
    #[serde(default = "default_workers")]
    workers: usize,
    #[serde(default = "default_auto_open_browser")]
    auto_open_browser: bool,

    // TLS Configuration
    #[serde(default = "default_enable_https")]
    enable_https: bool,
    #[serde(default = "default_https_port_offset")]
    https_port_offset: u16,
    #[serde(default = "default_cert_dir")]
    cert_dir: String,
    #[serde(default = "default_auto_cert")]
    auto_cert: bool,
    #[serde(default = "default_cert_validity_days")]
    cert_validity_days: u32,

    // Production Settings
    #[serde(default = "default_use_lets_encrypt")]
    use_lets_encrypt: bool,
    #[serde(default = "default_production_domain")]
    production_domain: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct LoggingConfigToml {
    #[serde(default = "default_max_file_size")]
    max_file_size_mb: u64,
    #[serde(default = "default_max_archive_files")]
    max_archive_files: u8,
    #[serde(default = "default_compress_archives")]
    compress_archives: bool,
    #[serde(default = "default_log_requests")]
    log_requests: bool,
    #[serde(default = "default_log_security")]
    log_security_alerts: bool,
    #[serde(default = "default_log_performance")]
    log_performance: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct ThemeDefinitionConfig {
    input_text: String,
    input_bg: String,
    output_text: String,
    output_bg: String,
    #[serde(default = "default_prefix")]
    input_cursor_prefix: String,
    #[serde(default = "default_input_color")]
    input_cursor_color: String,
    #[serde(default = "default_cursor")]
    input_cursor: String,
    #[serde(default = "default_cursor")]
    output_cursor: String,
    #[serde(default = "default_output_color")]
    output_cursor_color: String,
}

// Default Functions
fn default_theme() -> String {
    "dark".into()
}
fn default_prefix() -> String {
    "/// ".into()
}
fn default_input_color() -> String {
    "LightBlue".into()
}
fn default_output_color() -> String {
    "White".into()
}
fn default_cursor() -> String {
    "PIPE".into()
}

// Server Defaults
fn default_port_start() -> u16 {
    8080
}
fn default_port_end() -> u16 {
    8180
}
fn default_max_concurrent() -> usize {
    10
}
fn default_shutdown_timeout() -> u64 {
    5
}
fn default_startup_delay() -> u64 {
    500
}
fn default_workers() -> usize {
    1
}
fn default_auto_open_browser() -> bool {
    true
}

// TLS Defaults
fn default_enable_https() -> bool {
    true
}
fn default_https_port_offset() -> u16 {
    1000
}
fn default_cert_dir() -> String {
    ".rss/certs".to_string()
}
fn default_auto_cert() -> bool {
    true
}
fn default_cert_validity_days() -> u32 {
    365
}
fn default_use_lets_encrypt() -> bool {
    false
}
fn default_production_domain() -> String {
    "localhost".to_string()
}

// Logging Defaults
fn default_max_file_size() -> u64 {
    100
}
fn default_max_archive_files() -> u8 {
    9
}
fn default_compress_archives() -> bool {
    true
}
fn default_log_requests() -> bool {
    true
}
fn default_log_security() -> bool {
    true
}
fn default_log_performance() -> bool {
    true
}

// Main Configuration Structures
#[derive(Clone)]
pub struct Config {
    config_path: Option<String>,
    pub max_messages: usize,
    pub typewriter_delay: Duration,
    pub input_max_length: usize,
    pub max_history: usize,
    pub poll_rate: Duration,
    pub log_level: String,
    pub theme: Theme,
    pub current_theme_name: String,
    pub language: String,
    pub debug_info: Option<String>,
    pub server: ServerConfig,
    pub logging: LoggingConfig,
    pub proxy: ProxyConfig,
}

#[derive(Clone)]
pub struct ServerConfig {
    pub port_range_start: u16,
    pub port_range_end: u16,
    pub max_concurrent: usize,
    pub shutdown_timeout: u64,
    pub startup_delay_ms: u64,
    pub workers: usize,
    pub auto_open_browser: bool,

    // TLS Configuration
    pub enable_https: bool,
    pub https_port_offset: u16,
    pub cert_dir: String,
    pub auto_cert: bool,
    pub cert_validity_days: u32,
    pub use_lets_encrypt: bool,
    pub production_domain: String,
}

#[derive(Clone)]
pub struct LoggingConfig {
    pub max_file_size_mb: u64,
    pub max_archive_files: u8,
    pub compress_archives: bool,
    pub log_requests: bool,
    pub log_security_alerts: bool,
    pub log_performance: bool,
}

#[derive(Clone)]
pub struct Theme {
    pub input_text: AppColor,
    pub input_bg: AppColor,
    pub output_text: AppColor,
    pub output_bg: AppColor,
    pub input_cursor_prefix: String,
    pub input_cursor_color: AppColor,
    pub input_cursor: String,
    pub output_cursor: String,
    pub output_cursor_color: AppColor,
}

impl Default for Theme {
    fn default() -> Self {
        Self {
            input_text: AppColor::new(Color::White),
            input_bg: AppColor::new(Color::Black),
            output_text: AppColor::new(Color::White),
            output_bg: AppColor::new(Color::Black),
            input_cursor_prefix: "/// ".into(),
            input_cursor_color: AppColor::new(Color::LightBlue),
            input_cursor: "PIPE".into(),
            output_cursor: "PIPE".into(),
            output_cursor_color: AppColor::new(Color::White),
        }
    }
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            port_range_start: 8080,
            port_range_end: 8180,
            max_concurrent: 10,
            shutdown_timeout: 5,
            startup_delay_ms: 500,
            workers: 1,
            auto_open_browser: true,
            enable_https: true,
            https_port_offset: 1000,
            cert_dir: ".rss/certs".to_string(),
            auto_cert: true,
            cert_validity_days: 365,
            use_lets_encrypt: false,
            production_domain: "localhost".to_string(),
        }
    }
}

impl Default for LoggingConfig {
    fn default() -> Self {
        Self {
            max_file_size_mb: 100,
            max_archive_files: 9,
            compress_archives: true,
            log_requests: true,
            log_security_alerts: true,
            log_performance: true,
        }
    }
}

impl Config {
    pub async fn load() -> Result<Self> {
        Self::load_with_messages(true).await
    }

    pub async fn load_with_messages(show_messages: bool) -> Result<Self> {
        // Try existing configs
        for path in crate::setup::setup_toml::get_config_paths() {
            if path.exists() {
                if let Ok(config) = Self::from_file(&path).await {
                    if show_messages {
                        Self::log_startup(&config);
                    }
                    Self::apply_language(&config).await;
                    return Ok(config);
                }
            }
        }

        // Create new config
        let path = crate::setup::setup_toml::ensure_config_exists().await?;
        let mut config = Self::from_file(&path).await?;

        if show_messages {
            config.debug_info = Some(format!("New config: {}", path.display()));
            Self::log_startup(&config);
        }

        Self::apply_language(&config).await;
        Ok(config)
    }

    pub async fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = tokio::fs::read_to_string(&path)
            .await
            .map_err(AppError::Io)?;
        let file: ConfigFile =
            toml::from_str(&content).map_err(|e| AppError::Validation(format!("TOML: {}", e)))?;

        let poll_rate = Self::clamp(file.general.poll_rate, 16, 1000, 16);
        let typewriter = Self::clamp(file.general.typewriter_delay, 0, 2000, 50);
        let theme = Self::load_theme(&file).unwrap_or_default();

        // Load server config
        let server = file
            .server
            .map_or_else(ServerConfig::default, |s| ServerConfig {
                port_range_start: s.port_range_start,
                port_range_end: s.port_range_end,
                max_concurrent: s.max_concurrent,
                shutdown_timeout: s.shutdown_timeout,
                startup_delay_ms: s.startup_delay_ms,
                workers: s.workers,
                auto_open_browser: s.auto_open_browser,
                enable_https: s.enable_https,
                https_port_offset: s.https_port_offset,
                cert_dir: s.cert_dir,
                auto_cert: s.auto_cert,
                cert_validity_days: s.cert_validity_days,
                use_lets_encrypt: s.use_lets_encrypt,
                production_domain: s.production_domain,
            });

        // Load logging config
        let logging = file
            .logging
            .map_or_else(LoggingConfig::default, |l| LoggingConfig {
                max_file_size_mb: l.max_file_size_mb,
                max_archive_files: l.max_archive_files,
                compress_archives: l.compress_archives,
                log_requests: l.log_requests,
                log_security_alerts: l.log_security_alerts,
                log_performance: l.log_performance,
            });

        let config = Self {
            config_path: Some(path.as_ref().to_string_lossy().into_owned()),
            max_messages: file.general.max_messages,
            typewriter_delay: Duration::from_millis(typewriter),
            input_max_length: file.general.input_max_length,
            max_history: file.general.max_history,
            poll_rate: Duration::from_millis(poll_rate),
            log_level: file.general.log_level,
            theme,
            current_theme_name: file.general.current_theme,
            language: file.language.current,
            debug_info: None,
            server,
            logging,
            proxy: file.proxy.map(ProxyConfig::from).unwrap_or_default(),
        };

        // Auto-save corrected values
        if poll_rate != file.general.poll_rate || typewriter != file.general.typewriter_delay {
            let _ = config.save().await;
        }

        Ok(config)
    }

    pub async fn save(&self) -> Result<()> {
        let Some(path) = &self.config_path else {
            return Ok(());
        };

        let themes = Self::load_existing_themes().await.unwrap_or_default();
        let file = ConfigFile {
            general: GeneralConfig {
                max_messages: self.max_messages,
                typewriter_delay: self.typewriter_delay.as_millis() as u64,
                input_max_length: self.input_max_length,
                max_history: self.max_history,
                poll_rate: self.poll_rate.as_millis() as u64,
                log_level: self.log_level.clone(),
                current_theme: self.current_theme_name.clone(),
            },
            server: Some(ServerConfigToml {
                port_range_start: self.server.port_range_start,
                port_range_end: self.server.port_range_end,
                max_concurrent: self.server.max_concurrent,
                shutdown_timeout: self.server.shutdown_timeout,
                startup_delay_ms: self.server.startup_delay_ms,
                workers: self.server.workers,
                auto_open_browser: self.server.auto_open_browser,
                enable_https: self.server.enable_https,
                https_port_offset: self.server.https_port_offset,
                cert_dir: self.server.cert_dir.clone(),
                auto_cert: self.server.auto_cert,
                cert_validity_days: self.server.cert_validity_days,
                use_lets_encrypt: self.server.use_lets_encrypt,
                production_domain: self.server.production_domain.clone(),
            }),
            logging: Some(LoggingConfigToml {
                max_file_size_mb: self.logging.max_file_size_mb,
                max_archive_files: self.logging.max_archive_files,
                compress_archives: self.logging.compress_archives,
                log_requests: self.logging.log_requests,
                log_security_alerts: self.logging.log_security_alerts,
                log_performance: self.logging.log_performance,
            }),
            theme: if themes.is_empty() {
                None
            } else {
                Some(themes)
            },
            language: LanguageConfig {
                current: self.language.clone(),
            },
            proxy: Some(self.proxy.clone().into()),
        };

        let content = toml::to_string_pretty(&file)
            .map_err(|e| AppError::Validation(format!("TOML: {}", e)))?;

        // Ensure dir exists
        if let Some(parent) = std::path::PathBuf::from(path).parent() {
            tokio::fs::create_dir_all(parent)
                .await
                .map_err(AppError::Io)?;
        }

        tokio::fs::write(path, content).await.map_err(AppError::Io)
    }

    pub async fn change_theme(&mut self, name: &str) -> Result<()> {
        let themes = Self::load_existing_themes().await?;
        let def = themes
            .get(name)
            .ok_or_else(|| AppError::Validation(format!("Theme '{}' not found", name)))?;

        self.theme = Theme::from_config(def)?;
        self.current_theme_name = name.into();
        self.save().await
    }

    pub fn get_performance_info(&self) -> String {
        let fps = 1000.0 / self.poll_rate.as_millis() as f64;
        let typewriter = if self.typewriter_delay.as_millis() > 0 {
            1000.0 / self.typewriter_delay.as_millis() as f64
        } else {
            f64::INFINITY
        };
        format!(
            "Performance: {:.1} FPS, Typewriter: {:.1} chars/sec, Max Servers: {}",
            fps, typewriter, self.server.max_concurrent
        )
    }

    // Helper methods
    fn clamp(value: u64, min: u64, max: u64, default: u64) -> u64 {
        if value < min || value > max {
            default
        } else {
            value
        }
    }

    fn load_theme(file: &ConfigFile) -> Option<Theme> {
        let themes = file.theme.as_ref()?;
        let def = themes.get(&file.general.current_theme)?;
        Theme::from_config(def).ok()
    }

    async fn load_existing_themes() -> Result<HashMap<String, ThemeDefinitionConfig>> {
        for path in crate::setup::setup_toml::get_config_paths() {
            if path.exists() {
                let content = tokio::fs::read_to_string(&path)
                    .await
                    .map_err(AppError::Io)?;
                let file: ConfigFile = toml::from_str(&content)
                    .map_err(|e| AppError::Validation(format!("TOML: {}", e)))?;

                if let Some(themes) = file.theme {
                    return Ok(themes);
                }
            }
        }
        Ok(HashMap::new())
    }

    async fn apply_language(config: &Config) {
        let _ = crate::commands::lang::LanguageService::new()
            .load_and_apply_from_config(config)
            .await;
    }

    fn log_startup(config: &Config) {
        if config.poll_rate.as_millis() < 16 {
            log::warn!("Performance: poll_rate sehr niedrig!");
        }
        log::info!("Rush Sync Server v{}", crate::core::constants::VERSION);
        log::info!(
            "Server Config: Ports {}-{}, Max: {}",
            config.server.port_range_start,
            config.server.port_range_end,
            config.server.max_concurrent
        );
    }
}

impl Theme {
    fn from_config(def: &ThemeDefinitionConfig) -> Result<Self> {
        Ok(Self {
            input_text: AppColor::from_string(&def.input_text)?,
            input_bg: AppColor::from_string(&def.input_bg)?,
            output_text: AppColor::from_string(&def.output_text)?,
            output_bg: AppColor::from_string(&def.output_bg)?,
            input_cursor_prefix: def.input_cursor_prefix.clone(),
            input_cursor_color: AppColor::from_string(&def.input_cursor_color)?,
            input_cursor: def.input_cursor.clone(),
            output_cursor: def.output_cursor.clone(),
            output_cursor_color: AppColor::from_string(&def.output_cursor_color)?,
        })
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            config_path: None,
            max_messages: DEFAULT_BUFFER_SIZE,
            typewriter_delay: Duration::from_millis(50),
            input_max_length: DEFAULT_BUFFER_SIZE,
            max_history: 30,
            poll_rate: Duration::from_millis(DEFAULT_POLL_RATE),
            log_level: "info".into(),
            theme: Theme::default(),
            current_theme_name: "dark".into(),
            language: crate::i18n::DEFAULT_LANGUAGE.into(),
            debug_info: None,
            server: ServerConfig::default(),
            logging: LoggingConfig::default(),
            proxy: ProxyConfig::default(),
        }
    }
}

// ## END ##

// ## FILE: src/core/helpers.rs
// ## BEGIN ##
use crate::core::prelude::*;

/// Runtime-sicherer Config-Loader
pub fn get_config() -> Result<Config> {
    // Einfachste L√∂sung: Channel-basiert
    let (tx, rx) = std::sync::mpsc::channel();

    std::thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let result = rt.block_on(Config::load());
        let _ = tx.send(result);
    });

    rx.recv()
        .map_err(|_| AppError::Validation("Config loading timeout".to_string()))?
}

// ## END ##

// ## FILE: src/core/mod.rs
// ## BEGIN ##
// src/core/mod.rs
pub mod config;
pub mod constants;
pub mod error;
pub mod helpers;
pub mod prelude;

// ## END ##

// ## FILE: src/core/prelude.rs
// ## BEGIN ##
// ‚úÖ CORE ESSENTIALS - √ºberall gebraucht
pub use crate::core::config::Config;
pub use crate::core::error::{AppError, Result};
pub use crate::core::helpers::get_config;

// ‚úÖ STANDARD LIBRARY ESSENTIALS
pub use std::collections::HashMap;
pub use std::io::{self, Write};
pub use std::time::{Duration, Instant};

// ‚úÖ CROSSTERM BASICS (nur die wichtigsten)
pub use crossterm::event::{KeyCode, KeyEvent};

// ‚úÖ RATATUI BASICS
pub use ratatui::style::Color;

// ‚úÖ i18n INTEGRATION - VOLLST√ÑNDIG
pub use crate::i18n::{
    clear_translation_cache, get_available_languages, get_color_category_for_display,
    get_command_translation, get_current_language, get_translation, has_translation, set_language,
    TranslationError,
};

// ‚úÖ i18n MAKROS - f√ºr einfache Nutzung
pub use crate::{t, tc};

// ‚úÖ ZUS√ÑTZLICHE UTILITIES f√ºr h√§ufige Operationen
pub use crate::ui::color::AppColor;

// ‚úÖ LOGGING INTEGRATION - damit log! Makros i18n nutzen k√∂nnen
pub use log::{debug, error, info, trace, warn};

// ‚úÖ RE-EXPORTS f√ºr bessere API
pub use crate::commands::{Command, CommandHandler, CommandRegistry};
pub use crate::input::keyboard::KeyAction;
pub use crate::output::display::MessageDisplay;

// ## END ##

// ## FILE: src/memory/mod.rs
// ## BEGIN ##
use std::collections::HashMap;
use std::sync::{Mutex, OnceLock, RwLock};
use std::time::SystemTime;

use sysinfo; // 0.30+

// ---------------- Prozess-Systemhandle (einmalig, wiederverwendbar) ----------------

static SYS: OnceLock<Mutex<sysinfo::System>> = OnceLock::new();

fn sys_handle() -> &'static Mutex<sysinfo::System> {
    SYS.get_or_init(|| Mutex::new(sysinfo::System::new()))
}

// ---------------- Registry ----------------

#[derive(Clone, Copy, Debug)]
pub enum ResourceKind {
    EmbeddedAsset,
    Phase, // ŒîRSS je Start-/Laufzeitphase
    Other,
}

#[derive(Clone, Debug)]
pub struct Resource {
    pub id: String,
    pub kind: ResourceKind,
    pub bytes: u64,
    pub created_at: SystemTime,
}

static REGISTRY: OnceLock<RwLock<HashMap<String, Resource>>> = OnceLock::new();

fn reg() -> &'static RwLock<HashMap<String, Resource>> {
    REGISTRY.get_or_init(|| RwLock::new(HashMap::new()))
}

pub fn register_embedded(id: &str, kind: ResourceKind, bytes: u64) {
    let res = Resource {
        id: id.to_string(),
        kind,
        bytes,
        created_at: SystemTime::now(),
    };
    let mut map = reg().write().expect("memory registry poisoned");
    map.insert(res.id.clone(), res);
}

pub fn snapshot() -> Vec<Resource> {
    reg()
        .read()
        .expect("memory registry poisoned")
        .values()
        .cloned()
        .collect()
}

pub fn total_bytes() -> u64 {
    reg()
        .read()
        .expect("memory registry poisoned")
        .values()
        .map(|r| r.bytes)
        .sum()
}

// ---------------- Prozess-Metriken ----------------

// RSS in BYTES (sysinfo 0.30+ liefert Bytes)
pub fn process_rss_bytes() -> u64 {
    let mut sys = sys_handle().lock().expect("sysinfo mutex poisoned");
    sys.refresh_processes();
    if let Ok(pid) = sysinfo::get_current_pid() {
        if let Some(p) = sys.process(pid) {
            p.memory() as u64
        } else {
            0
        }
    } else {
        0
    }
}

pub fn process_vms_bytes() -> u64 {
    let mut sys = sys_handle().lock().expect("sysinfo mutex poisoned");
    sys.refresh_processes();
    if let Ok(pid) = sysinfo::get_current_pid() {
        if let Some(p) = sys.process(pid) {
            p.virtual_memory() as u64
        } else {
            0
        }
    } else {
        0
    }
}

pub fn total_ram_bytes() -> u64 {
    let mut sys = sys_handle().lock().expect("sysinfo mutex poisoned");
    sys.refresh_memory();
    sys.total_memory() as u64
}

/// Anzahl Threads (falls nicht verf√ºgbar: 0)
#[cfg(target_os = "linux")]
pub fn process_thread_count() -> usize {
    // Best-effort: aus /proc/self/status die "Threads:"-Zeile parsen
    // (keine extra Dependencies)
    use std::fs;
    if let Ok(s) = fs::read_to_string("/proc/self/status") {
        for line in s.lines() {
            if let Some(rest) = line.strip_prefix("Threads:") {
                return rest.trim().parse::<usize>().unwrap_or(0);
            }
        }
    }
    0
}

#[cfg(not(target_os = "linux"))]
pub fn process_thread_count() -> usize {
    // sysinfo 0.30 bietet hier plattform√ºbergreifend keine Threads-API.
    // Fallback: 0 (oder du gibst in der Anzeige "n/a" aus).
    0
}

// ---------------- Scopes / Phasen-Messung ----------------

pub struct ScopeGuard {
    id: String,
    start_rss: u64,
}

pub fn begin_scope(id: &str) -> ScopeGuard {
    ScopeGuard {
        id: id.to_string(),
        start_rss: process_rss_bytes(),
    }
}

impl Drop for ScopeGuard {
    fn drop(&mut self) {
        let end = process_rss_bytes();
        let delta = end.saturating_sub(self.start_rss);
        register_embedded(&self.id, ResourceKind::Phase, delta);
    }
}

// ---------------- Debug ----------------

pub fn debug_dump_to_log() {
    #[cfg(debug_assertions)]
    {
        let map = reg().read().expect("memory registry poisoned");
        let total: u64 = map.values().map(|r| r.bytes).sum();
        log::debug!("[memory] resources: {}", map.len());
        log::debug!("[memory] total bytes (registered): {}", total);
        for r in map.values() {
            log::debug!("  - {} ({:?}) {} bytes", r.id, r.kind, r.bytes);
        }
    }
}

// ## END ##

// ## FILE: src/proxy/types.rs
// ## BEGIN ##
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyConfig {
    pub enabled: bool,
    pub port: u16,              // HTTP Proxy Port (3000)
    pub https_port_offset: u16, // NEU: HTTPS Offset (443)
    pub bind_address: String,
    pub health_check_interval: u64,
    pub timeout_ms: u64,
}

impl Default for ProxyConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 3000,             // HTTP Proxy
            https_port_offset: 443, // HTTPS = 3000 + 443 = 3443
            bind_address: "127.0.0.1".to_string(),
            health_check_interval: 30,
            timeout_ms: 5000,
        }
    }
}

// NEU: TOML-spezifische Struktur f√ºr Serialisierung
#[derive(Debug, Serialize, Deserialize)]
pub struct ProxyConfigToml {
    pub enabled: bool,
    pub port: u16,
    pub bind_address: String,
    pub health_check_interval: u64,
    pub timeout_ms: u64,
    pub https_port_offset: u16,
}

// FEHLEND: Default f√ºr ProxyConfigToml
impl Default for ProxyConfigToml {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 3000,
            https_port_offset: 443,
            bind_address: "127.0.0.1".to_string(),
            health_check_interval: 30,
            timeout_ms: 5000,
        }
    }
}

impl From<ProxyConfig> for ProxyConfigToml {
    fn from(config: ProxyConfig) -> Self {
        Self {
            enabled: config.enabled,
            port: config.port,
            https_port_offset: config.https_port_offset,
            bind_address: config.bind_address,
            health_check_interval: config.health_check_interval,
            timeout_ms: config.timeout_ms,
        }
    }
}

impl From<ProxyConfigToml> for ProxyConfig {
    fn from(config: ProxyConfigToml) -> Self {
        Self {
            enabled: config.enabled,
            port: config.port,
            https_port_offset: config.https_port_offset,
            bind_address: config.bind_address,
            health_check_interval: config.health_check_interval,
            timeout_ms: config.timeout_ms,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ProxyTarget {
    pub name: String,
    pub port: u16,
    pub healthy: bool,
    pub last_check: std::time::SystemTime,
}

#[derive(Debug, Clone)]
pub struct ProxyRoute {
    pub subdomain: String,
    pub target_port: u16,
    pub server_id: String,
}

pub type RouteMap = HashMap<String, ProxyRoute>;

// ## END ##

// ## FILE: src/proxy/handler.rs
// ## BEGIN ##
use crate::proxy::ProxyManager;
use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Client, Request, Response, Server, Uri};
use std::convert::Infallible;
use std::sync::Arc;

pub struct ProxyServer {
    manager: Arc<ProxyManager>,
}

impl ProxyServer {
    pub fn new(manager: Arc<ProxyManager>) -> Self {
        Self { manager }
    }

    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let config = self.manager.get_config();
        let addr = ([127, 0, 0, 1], config.port).into();

        let manager = Arc::clone(&self.manager);

        let make_svc = make_service_fn(move |_conn| {
            let manager = Arc::clone(&manager);
            let client = Client::new();

            async move {
                Ok::<_, Infallible>(service_fn(move |req| {
                    let manager = Arc::clone(&manager);
                    let client = client.clone();
                    handle_proxy_request(req, manager, client)
                }))
            }
        });

        let server = Server::bind(&addr).serve(make_svc);

        log::info!(
            "Reverse Proxy listening on http://127.0.0.1:{}",
            config.port
        );
        log::info!("Route pattern: {{servername}}.localhost -> 127.0.0.1:{{port}}");

        if let Err(e) = server.await {
            log::error!("Proxy server error: {}", e);
        }

        Ok(())
    }

    // NEU: HTTPS-Server hinzuf√ºgen
    pub async fn start_with_https(&self) -> crate::core::prelude::Result<()> {
        let config = self.manager.get_config();
        let https_port = config.port + config.https_port_offset;

        // Manager EINMAL clonen f√ºr beide Tasks
        let manager_for_http = Arc::clone(&self.manager);
        let manager_for_https = Arc::clone(&self.manager);
        let config_clone = config.clone(); // Config f√ºr HTTPS Task

        log::info!("Starting HTTP + HTTPS proxy servers...");
        log::info!("  HTTP:  http://127.0.0.1:{}", config.port);
        log::info!("  HTTPS: https://127.0.0.1:{}", https_port);

        // HTTP Server Task
        let http_task = tokio::spawn(async move {
            let proxy_server = ProxyServer::new(manager_for_http);
            if let Err(e) = proxy_server.start().await {
                log::error!("HTTP proxy failed: {}", e);
            }
        });

        // HTTPS Server Task
        let https_task = tokio::spawn(async move {
            // TLS-Setup
            let tls_manager = match crate::server::tls::TlsManager::new(".rss/certs", 365) {
                Ok(manager) => manager,
                Err(e) => {
                    log::error!("TLS manager creation failed: {}", e);
                    return;
                }
            };

            let tls_config = match tls_manager.get_rustls_config("proxy", config_clone.port) {
                Ok(config) => config,
                Err(e) => {
                    log::error!("TLS config failed: {}", e);
                    return;
                }
            };

            // HTTPS Listener
            let listener = match tokio::net::TcpListener::bind(("127.0.0.1", https_port)).await {
                Ok(listener) => listener,
                Err(e) => {
                    log::error!("HTTPS bind failed: {}", e);
                    return;
                }
            };

            let acceptor = tokio_rustls::TlsAcceptor::from(tls_config);
            log::info!("HTTPS proxy listening on https://127.0.0.1:{}", https_port);

            loop {
                let (stream, _) = match listener.accept().await {
                    Ok(conn) => conn,
                    Err(e) => {
                        log::warn!("HTTPS accept failed: {}", e);
                        continue;
                    }
                };

                let acceptor = acceptor.clone();
                let manager = Arc::clone(&manager_for_https);

                tokio::spawn(async move {
                    let tls_stream = match acceptor.accept(stream).await {
                        Ok(stream) => stream,
                        Err(e) => {
                            log::debug!("TLS handshake failed: {}", e);
                            return;
                        }
                    };

                    let service = hyper::service::service_fn(move |req| {
                        let manager = Arc::clone(&manager);
                        let client = hyper::Client::new();
                        handle_proxy_request(req, manager, client)
                    });

                    if let Err(e) = hyper::server::conn::Http::new()
                        .serve_connection(tls_stream, service)
                        .await
                    {
                        log::debug!("HTTPS connection error: {}", e);
                    }
                });
            }
        });

        // Tasks parallel laufen lassen
        tokio::select! {
            _ = http_task => log::error!("HTTP task ended"),
            _ = https_task => log::error!("HTTPS task ended"),
        }

        Ok(())
    }
}

// Rest der handle_proxy_request Funktion bleibt gleich...
pub async fn handle_proxy_request(
    req: Request<Body>,
    manager: Arc<ProxyManager>,
    client: Client<hyper::client::HttpConnector>,
) -> Result<Response<Body>, hyper::Error> {
    let host = req
        .headers()
        .get("host")
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string())
        .unwrap_or_else(|| "localhost".to_string());

    let subdomain = if let Some(dot_pos) = host.find('.') {
        host[..dot_pos].to_string()
    } else {
        host.clone()
    };

    // DEBUG: Log every request
    log::info!(
        "Proxy Request: Host='{}' -> Subdomain='{}'",
        host,
        subdomain
    );

    let path_and_query = req
        .uri()
        .path_and_query()
        .map(|pq| pq.as_str())
        .unwrap_or("/")
        .to_string();

    // DEBUG: Check if route exists
    let routes = manager.get_routes().await;
    log::info!(
        "Available routes: {:?}",
        routes.iter().map(|r| &r.subdomain).collect::<Vec<_>>()
    );

    if let Some(target_port) = manager.get_target_port(&subdomain).await {
        let target_uri = format!("http://127.0.0.1:{}{}", target_port, path_and_query);

        match target_uri.parse::<Uri>() {
            Ok(uri) => {
                let (mut parts, body) = req.into_parts();
                parts.uri = uri;
                parts.headers.insert(
                    "host",
                    format!("127.0.0.1:{}", target_port).parse().unwrap(),
                );
                let backend_req = Request::from_parts(parts, body);

                match client.request(backend_req).await {
                    Ok(response) => Ok(response),
                    Err(e) => {
                        log::warn!("Backend request failed for {}.localhost: {}", subdomain, e);
                        Ok(Response::builder()
                            .status(502)
                            .header("content-type", "text/html")
                            .body(Body::from(format!(
                                r#"<!DOCTYPE html>
<html><head><title>Backend Unavailable</title></head>
<body>
<h1>502 Bad Gateway</h1>
<p>Backend server for <strong>{}.localhost</strong> is not responding.</p>
<p>Target: 127.0.0.1:{}</p>
</body></html>"#,
                                subdomain, target_port
                            )))
                            .unwrap())
                    }
                }
            }
            Err(_) => Ok(Response::builder()
                .status(400)
                .body(Body::from("Invalid target URI"))
                .unwrap()),
        }
    } else {
        let routes = manager.get_routes().await;
        let route_list = routes
            .iter()
            .map(|route| {
                format!(
                    r#"<li><a href="http://{}.localhost:{}/">{}.localhost</a> ‚Üí 127.0.0.1:{}</li>"#,
                    route.subdomain,
                    manager.get_config().port,
                    route.subdomain,
                    route.target_port
                )
            })
            .collect::<Vec<_>>()
            .join("\n");

        Ok(Response::builder()
            .status(404)
            .header("content-type", "text/html")
            .body(Body::from(format!(
                r#"<!DOCTYPE html>
<html>
<head>
    <title>Subdomain Not Found</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 40px; }}
        .container {{ max-width: 600px; margin: 0 auto; }}
        h1 {{ color: #ff4757; }}
        .routes {{ background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }}
        ul {{ list-style: none; padding: 0; }}
        li {{ margin: 8px 0; }}
        a {{ color: #0066cc; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        code {{ background: #e9ecef; padding: 2px 6px; border-radius: 4px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Subdomain '{}.localhost' Not Found</h1>
        <p>The requested subdomain <code>{}.localhost</code> is not configured in the reverse proxy.</p>

        <div class="routes">
            <h3>Available Routes:</h3>
            {}
        </div>

        <p><strong>How to add a new route:</strong></p>
        <pre><code>cargo run server create myapp --port 8080</code></pre>
        <p>This will automatically register <code>myapp.localhost</code> with the proxy.</p>
    </div>
</body>
</html>"#, subdomain, subdomain,
    if routes.is_empty() {
        "<p><em>No routes configured yet. Start a server to see routes here.</em></p>".to_string()
    } else {
        format!("<ul>{}</ul>", route_list)
    })))
            .unwrap())
    }
}

// ## END ##

// ## FILE: src/proxy/config.rs
// ## BEGIN ##
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyConfig {
    pub enabled: bool,
    pub port: u16,
    pub enable_tls: bool,
    pub cert_dir: String,
    pub max_concurrent: usize,
    pub timeout_seconds: u64,
}

impl Default for ProxyConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            port: 8000,
            enable_tls: true,
            cert_dir: ".rss/certs".to_string(),
            max_concurrent: 50,
            timeout_seconds: 30,
        }
    }
}

// ## END ##

// ## FILE: src/proxy/manager.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::proxy::handler::ProxyServer;
use crate::proxy::types::{ProxyConfig, ProxyRoute, ProxyTarget, RouteMap};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct ProxyManager {
    config: ProxyConfig,
    routes: Arc<RwLock<RouteMap>>,
    targets: Arc<RwLock<HashMap<String, ProxyTarget>>>,
}

impl ProxyManager {
    pub fn new(config: ProxyConfig) -> Self {
        Self {
            config,
            routes: Arc::new(RwLock::new(HashMap::new())),
            targets: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn add_route(&self, server_name: &str, server_id: &str, port: u16) -> Result<()> {
        let route = ProxyRoute {
            subdomain: server_name.to_string(),
            target_port: port,
            server_id: server_id.to_string(),
        };

        let target = ProxyTarget {
            name: server_name.to_string(),
            port,
            healthy: true,
            last_check: std::time::SystemTime::now(),
        };

        {
            let mut routes = self.routes.write().await;
            routes.insert(server_name.to_string(), route);
        }

        {
            let mut targets = self.targets.write().await;
            targets.insert(server_name.to_string(), target);
        }

        log::info!(
            "Added proxy route: {}.localhost -> 127.0.0.1:{}",
            server_name,
            port
        );
        Ok(())
    }

    pub async fn remove_route(&self, server_name: &str) -> Result<()> {
        {
            let mut routes = self.routes.write().await;
            routes.remove(server_name);
        }

        {
            let mut targets = self.targets.write().await;
            targets.remove(server_name);
        }

        log::info!("Removed proxy route: {}.localhost", server_name);
        Ok(())
    }

    pub async fn get_routes(&self) -> Vec<ProxyRoute> {
        let routes = self.routes.read().await;
        routes.values().cloned().collect()
    }

    pub async fn get_target_port(&self, subdomain: &str) -> Option<u16> {
        let routes = self.routes.read().await;
        routes.get(subdomain).map(|route| route.target_port)
    }

    pub fn get_config(&self) -> &ProxyConfig {
        &self.config
    }

    pub async fn start_proxy_server(self: Arc<Self>) -> Result<()> {
        if !self.config.enabled {
            log::info!("Reverse Proxy disabled");
            return Ok(());
        }

        let proxy_server = ProxyServer::new(Arc::clone(&self));

        let https_port = self.config.port + self.config.https_port_offset;

        log::info!("Starting Reverse Proxy:");
        log::info!("  HTTP:  http://127.0.0.1:{}", self.config.port);
        log::info!("  HTTPS: https://127.0.0.1:{}", https_port);

        tokio::spawn(async move {
            if let Err(e) = proxy_server.start_with_https().await {
                log::error!("Proxy with HTTPS failed: {}", e);
            }
        });

        log::info!(
            "TLS certificate: .rss/certs/proxy-{}.cert",
            self.config.port
        );

        Ok(())
    }

    pub async fn debug_routes(&self) {
        let routes = self.routes.read().await;
        log::info!("=== ACTIVE PROXY ROUTES ===");
        if routes.is_empty() {
            log::warn!("No routes registered!");
        } else {
            for (subdomain, route) in routes.iter() {
                log::info!(
                    "  {} -> 127.0.0.1:{} (server_id: {})",
                    subdomain,
                    route.target_port,
                    route.server_id
                );
            }
        }
        log::info!("=== END ROUTES ===");
    }
}

// ## END ##

// ## FILE: src/proxy/mod.rs
// ## BEGIN ##
pub mod handler;
pub mod manager;
pub mod types;

pub use manager::ProxyManager;
pub use types::{ProxyConfig, ProxyConfigToml, ProxyRoute, ProxyTarget};

// ## END ##

// ## FILE: src/input/mod.rs
// ## BEGIN ##
pub mod keyboard;
pub mod state;

use crossterm::event::{self as crossterm_event, Event as CrosstermEvent, KeyEvent};
use tokio::sync::mpsc::{self, Sender};
use tokio::time::{interval, Duration, Instant};

#[derive(Debug)]
pub enum AppEvent {
    Input(KeyEvent),
    Tick,
    Resize(u16, u16),
}

pub struct EventHandler {
    rx: mpsc::Receiver<AppEvent>,
    shutdown_tx: Vec<Sender<()>>,
}

impl EventHandler {
    pub fn new(tick_rate: Duration) -> Self {
        let (tx, rx) = mpsc::channel(100);
        let mut shutdown_tx = Vec::new();

        // Input event handler
        let (input_shutdown_tx, input_shutdown_rx) = mpsc::channel(1);
        shutdown_tx.push(input_shutdown_tx);
        Self::spawn_input_handler(tx.clone(), input_shutdown_rx);

        // Tick handler
        let (tick_shutdown_tx, tick_shutdown_rx) = mpsc::channel(1);
        shutdown_tx.push(tick_shutdown_tx);
        Self::spawn_tick_handler(tx, tick_rate, tick_shutdown_rx);

        EventHandler { rx, shutdown_tx }
    }

    fn spawn_input_handler(tx: mpsc::Sender<AppEvent>, mut shutdown_rx: mpsc::Receiver<()>) {
        tokio::spawn(async move {
            let (mut last_key_time, mut last_resize_time) = (Instant::now(), Instant::now());
            let (key_interval, resize_interval) =
                (Duration::from_millis(16), Duration::from_millis(50));

            loop {
                tokio::select! {
                    _ = shutdown_rx.recv() => break,
                    _ = async {
                        if crossterm_event::poll(Duration::from_millis(99)).unwrap() {
                            if let Ok(event) = crossterm_event::read() {
                                let now = Instant::now();
                                match event {
                                    CrosstermEvent::Key(key) if now.duration_since(last_key_time) >= key_interval => {
                                        let _ = tx.send(AppEvent::Input(key)).await;
                                        last_key_time = now;
                                    }
                                    CrosstermEvent::Resize(w, h) if now.duration_since(last_resize_time) >= resize_interval => {
                                        let _ = tx.send(AppEvent::Resize(w, h)).await;
                                        last_resize_time = now;
                                    }
                                    _ => {}
                                }
                            }
                        }
                    } => {}
                }
            }
        });
    }

    fn spawn_tick_handler(
        tx: mpsc::Sender<AppEvent>,
        tick_rate: Duration,
        mut shutdown_rx: mpsc::Receiver<()>,
    ) {
        tokio::spawn(async move {
            let mut interval = interval(tick_rate);
            loop {
                tokio::select! {
                    _ = shutdown_rx.recv() => break,
                    _ = interval.tick() => { let _ = tx.send(AppEvent::Tick).await; }
                }
            }
        });
    }

    pub async fn next(&mut self) -> Option<AppEvent> {
        self.rx.recv().await
    }

    pub async fn shutdown(&mut self) {
        for tx in &self.shutdown_tx {
            let _ = tx.send(()).await;
        }
    }
}

// ## END ##

// ## FILE: src/input/keyboard.rs
// ## BEGIN ##
use crate::core::constants::DOUBLE_ESC_THRESHOLD;
use crate::core::prelude::*;
use crossterm::event::KeyModifiers;
use lazy_static::lazy_static;
use std::sync::Mutex;

#[derive(Debug, Clone, PartialEq)]
pub enum KeyAction {
    MoveLeft,
    MoveRight,
    MoveToStart,
    MoveToEnd,
    InsertChar(char),
    Backspace,
    Delete,
    Submit,
    Cancel,
    Quit,
    ClearLine,
    CopySelection,
    PasteBuffer,
    NoAction,
    ScrollUp,
    ScrollDown,
    PageUp,
    PageDown,
}

lazy_static! {
    static ref LAST_ESC_PRESS: Mutex<Option<Instant>> = Mutex::new(None);
    static ref ESCAPE_SEQUENCE_BUFFER: Mutex<Vec<char>> = Mutex::new(Vec::new());
}

pub struct KeyboardManager {
    double_press_threshold: Duration,
    sequence_timeout: Duration,
    last_key_time: Instant,
}

impl KeyboardManager {
    pub fn new() -> Self {
        Self {
            double_press_threshold: Duration::from_millis(DOUBLE_ESC_THRESHOLD),
            sequence_timeout: Duration::from_millis(100),
            last_key_time: Instant::now(),
        }
    }

    // Consolidated security filtering
    fn is_safe_char(&mut self, c: char) -> bool {
        // Filter dangerous control chars and sequences
        if matches!(c, '\x00'..='\x08' | '\x0B'..='\x0C' | '\x0E'..='\x1F' | '\x7F') {
            return false;
        }

        // Filter suspicious non-ASCII chars (except common European chars)
        if !c.is_ascii() && !c.is_alphabetic() && !"√§√∂√º√ü√Ñ√ñ√ú‚Ç¨".contains(c) {
            return false;
        }

        // Check for terminal sequence patterns
        !self.detect_terminal_sequence(c)
    }

    fn detect_terminal_sequence(&mut self, c: char) -> bool {
        let now = Instant::now();

        // Reset old buffer
        if now.duration_since(self.last_key_time) > self.sequence_timeout {
            if let Ok(mut buffer) = ESCAPE_SEQUENCE_BUFFER.lock() {
                buffer.clear();
            }
        }
        self.last_key_time = now;

        // Check sequences
        if let Ok(mut buffer) = ESCAPE_SEQUENCE_BUFFER.lock() {
            buffer.push(c);
            let sequence: String = buffer.iter().collect();

            // Detect dangerous patterns
            let is_dangerous = sequence.to_lowercase().contains("tmux")
                || (sequence.len() > 3
                    && sequence.chars().all(|ch| ch.is_ascii_digit() || ch == ';'))
                || sequence.contains("///")
                || sequence.contains(";;;");

            if is_dangerous {
                buffer.clear();
            }
            if buffer.len() > 20 {
                buffer.drain(0..10);
            }

            is_dangerous
        } else {
            false
        }
    }

    pub fn get_action(&mut self, key: &KeyEvent) -> KeyAction {
        // Handle ESC double-press
        if key.code == KeyCode::Esc {
            return self.handle_escape();
        }

        // Filter dangerous characters
        if let KeyCode::Char(c) = key.code {
            if !self.is_safe_char(c) {
                return KeyAction::NoAction;
            }
        }

        // Quick scroll detection
        if key.modifiers.contains(KeyModifiers::SHIFT) {
            match key.code {
                KeyCode::Up => return KeyAction::ScrollUp,
                KeyCode::Down => return KeyAction::ScrollDown,
                _ => {}
            }
        }

        // Main key mapping - consolidated
        match (key.code, key.modifiers) {
            // Basic movement
            (KeyCode::Left, KeyModifiers::NONE) => KeyAction::MoveLeft,
            (KeyCode::Right, KeyModifiers::NONE) => KeyAction::MoveRight,
            (KeyCode::Home, KeyModifiers::NONE) => KeyAction::MoveToStart,
            (KeyCode::End, KeyModifiers::NONE) => KeyAction::MoveToEnd,
            (KeyCode::Enter, KeyModifiers::NONE) => KeyAction::Submit,

            // Scrolling
            (KeyCode::PageUp, KeyModifiers::NONE) => KeyAction::PageUp,
            (KeyCode::PageDown, KeyModifiers::NONE) => KeyAction::PageDown,

            // Text editing
            (KeyCode::Backspace, KeyModifiers::NONE) => KeyAction::Backspace,
            (KeyCode::Delete, KeyModifiers::NONE) => KeyAction::Delete,

            // Platform-specific shortcuts - consolidated
            (KeyCode::Char(c), mods) => self.handle_char_with_modifiers(c, mods),

            // Arrow keys with modifiers
            (KeyCode::Left, mods) if self.is_move_modifier(mods) => KeyAction::MoveToStart,
            (KeyCode::Right, mods) if self.is_move_modifier(mods) => KeyAction::MoveToEnd,

            // Backspace with modifiers
            (KeyCode::Backspace, mods) if self.is_clear_modifier(mods) => KeyAction::ClearLine,

            _ => KeyAction::NoAction,
        }
    }

    fn handle_escape(&self) -> KeyAction {
        let now = Instant::now();
        let mut last_press = LAST_ESC_PRESS.lock().unwrap_or_else(|p| p.into_inner());

        if let Some(prev_press) = *last_press {
            if now.duration_since(prev_press) <= self.double_press_threshold {
                *last_press = None;
                return KeyAction::Quit;
            }
        }

        *last_press = Some(now);
        KeyAction::NoAction
    }

    fn handle_char_with_modifiers(&self, c: char, mods: KeyModifiers) -> KeyAction {
        // Safe character input (no modifiers or just shift)
        if mods.is_empty() || mods == KeyModifiers::SHIFT {
            return if c.is_ascii_control() && c != '\t' {
                KeyAction::NoAction
            } else {
                KeyAction::InsertChar(c)
            };
        }

        // Shortcut handling - consolidated for all platforms
        match c {
            'c' if self.is_copy_modifier(mods) => KeyAction::CopySelection,
            'v' if self.is_paste_modifier(mods) => KeyAction::PasteBuffer,
            'x' if self.is_cut_modifier(mods) => KeyAction::ClearLine,
            'a' if self.is_select_modifier(mods) => KeyAction::MoveToStart,
            'e' if self.is_end_modifier(mods) => KeyAction::MoveToEnd,
            'u' if self.is_clear_modifier(mods) => KeyAction::ClearLine,
            _ => KeyAction::NoAction,
        }
    }

    // Platform-agnostic modifier checks
    fn is_copy_modifier(&self, mods: KeyModifiers) -> bool {
        mods.contains(KeyModifiers::SUPER)
            || mods.contains(KeyModifiers::CONTROL)
            || mods.contains(KeyModifiers::ALT)
    }

    fn is_paste_modifier(&self, mods: KeyModifiers) -> bool {
        self.is_copy_modifier(mods)
    }
    fn is_cut_modifier(&self, mods: KeyModifiers) -> bool {
        self.is_copy_modifier(mods)
    }
    fn is_select_modifier(&self, mods: KeyModifiers) -> bool {
        self.is_copy_modifier(mods)
    }
    fn is_end_modifier(&self, mods: KeyModifiers) -> bool {
        mods.contains(KeyModifiers::CONTROL) || mods.contains(KeyModifiers::ALT)
    }
    fn is_clear_modifier(&self, mods: KeyModifiers) -> bool {
        self.is_copy_modifier(mods)
    }
    fn is_move_modifier(&self, mods: KeyModifiers) -> bool {
        self.is_copy_modifier(mods)
    }
}

impl Default for KeyboardManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

    #[test]
    fn test_escape_sequence_filtering() {
        let mut manager = KeyboardManager::new();

        // Test dangerous control character
        let ctrl_char = KeyEvent::new(KeyCode::Char('\x1B'), KeyModifiers::NONE);
        assert_eq!(manager.get_action(&ctrl_char), KeyAction::NoAction);

        // Test safe character
        let normal_char = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);
        assert_eq!(manager.get_action(&normal_char), KeyAction::InsertChar('a'));
    }

    #[test]
    fn test_platform_shortcuts() {
        let mut manager = KeyboardManager::new();

        // Test CMD shortcuts (Mac)
        let cmd_c = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::SUPER);
        assert_eq!(manager.get_action(&cmd_c), KeyAction::CopySelection);

        // Test CTRL shortcuts (Windows/Linux)
        let ctrl_c = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL);
        assert_eq!(manager.get_action(&ctrl_c), KeyAction::CopySelection);

        // Test ALT shortcuts (fallback)
        let alt_c = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::ALT);
        assert_eq!(manager.get_action(&alt_c), KeyAction::CopySelection);
    }

    #[test]
    fn test_scroll_actions() {
        let mut manager = KeyboardManager::new();

        let shift_up = KeyEvent::new(KeyCode::Up, KeyModifiers::SHIFT);
        assert_eq!(manager.get_action(&shift_up), KeyAction::ScrollUp);

        let shift_down = KeyEvent::new(KeyCode::Down, KeyModifiers::SHIFT);
        assert_eq!(manager.get_action(&shift_down), KeyAction::ScrollDown);
    }

    #[test]
    fn test_double_escape() {
        let mut manager = KeyboardManager::new(); // ‚úÖ FIX: mut hinzugef√ºgt
        let esc_key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        // First ESC should return NoAction
        assert_eq!(manager.get_action(&esc_key), KeyAction::NoAction);

        // Quick second ESC should return Quit (if within threshold)
        // Note: This test is simplified - in real usage, timing matters
    }
}

// ## END ##

// ## FILE: src/input/state.rs
// ## BEGIN ##
// =====================================================
// SCHRITT 2: DIESER CODE KOMMT IN src/input/state.rs
// L√ñSCHE DEN KOMPLETTEN ALTEN INHALT UND F√úGE DAS HIER EIN:
// =====================================================

use crate::commands::handler::CommandHandler;
use crate::commands::history::{
    HistoryAction, HistoryConfig, HistoryEvent, HistoryEventHandler, HistoryKeyboardHandler,
    HistoryManager,
};
use crate::core::prelude::*;
use crate::input::keyboard::{KeyAction, KeyboardManager};
use crate::ui::cursor::{CursorKind, UiCursor};
use crate::ui::widget::{AnimatedWidget, CursorWidget, StatefulWidget, Widget};
use ratatui::prelude::*;
use ratatui::widgets::{Block, Borders, Padding, Paragraph};
use unicode_segmentation::UnicodeSegmentation;
use unicode_width::UnicodeWidthStr;

// ‚úÖ ZENTRALER SYSTEM COMMAND PROCESSOR
#[derive(Default)]
pub struct SystemCommandProcessor {
    pending_confirmation: Option<PendingConfirmation>,
}

#[derive(Debug, Clone)]
struct PendingConfirmation {
    action: SystemAction,
}

#[derive(Debug, Clone, PartialEq)]
enum SystemAction {
    Exit,
    Restart,
    ClearHistory,
    CleanupExecute(String),
}

impl SystemCommandProcessor {
    /// Verarbeite System-Commands und Cleanup-Confirms
    pub fn process_command(&mut self, input: &str) -> SystemCommandResult {
        // 1Ô∏è‚É£ Direkte System-Commands
        if let Some(result) = self.handle_system_commands(input) {
            return result;
        }

        // 2Ô∏è‚É£ System-Best√§tigungs-Requests (inkl. Cleanup)
        if let Some(result) = self.handle_confirmation_requests(input) {
            return result;
        }

        // 3Ô∏è‚É£ Benutzer-Best√§tigungen
        if self.pending_confirmation.is_some() {
            return self.handle_user_confirmation(input);
        }

        // 4Ô∏è‚É£ Kein System-Command
        SystemCommandResult::NotSystemCommand
    }

    /// System-Commands (sofort ausf√ºhren)
    fn handle_system_commands(&mut self, input: &str) -> Option<SystemCommandResult> {
        match input.trim() {
            "__CLEAR__" => Some(SystemCommandResult::ClearScreen),
            "__EXIT__" => Some(SystemCommandResult::Exit),
            "__RESTART__" | "__RESTART_FORCE__" => Some(SystemCommandResult::Restart),
            "__CLEAR_HISTORY__" => Some(SystemCommandResult::ClearHistory),
            _ => None,
        }
    }

    /// ‚úÖ Best√§tigungs-Requests (zeige Prompt)
    fn handle_confirmation_requests(&mut self, input: &str) -> Option<SystemCommandResult> {
        // Exit-Best√§tigung
        if let Some(prompt) = input.strip_prefix("__CONFIRM:__EXIT__") {
            self.pending_confirmation = Some(PendingConfirmation {
                action: SystemAction::Exit,
            });
            return Some(SystemCommandResult::ShowPrompt(prompt.to_string()));
        }

        // Restart-Best√§tigung
        if let Some(prompt) = input.strip_prefix("__CONFIRM:__RESTART__") {
            self.pending_confirmation = Some(PendingConfirmation {
                action: SystemAction::Restart,
            });
            return Some(SystemCommandResult::ShowPrompt(prompt.to_string()));
        }

        // History-Clear-Best√§tigung
        if let Some(prompt) = input.strip_prefix("__CONFIRM:__CLEAR_HISTORY__") {
            self.pending_confirmation = Some(PendingConfirmation {
                action: SystemAction::ClearHistory,
            });
            return Some(SystemCommandResult::ShowPrompt(prompt.to_string()));
        }

        // Cleanup-Best√§tigungen (neues sauberes Pattern)
        if let Some(rest) = input.strip_prefix("__CONFIRM:__CLEANUP__") {
            if let Some((force_command, prompt)) = rest.split_once("__") {
                self.pending_confirmation = Some(PendingConfirmation {
                    action: SystemAction::CleanupExecute(force_command.to_string()),
                });
                return Some(SystemCommandResult::ShowPrompt(prompt.to_string()));
            }
        }

        None
    }

    /// ‚úÖ Benutzer-Best√§tigung verarbeiten (j/n)
    fn handle_user_confirmation(&mut self, input: &str) -> SystemCommandResult {
        let confirm_key = t!("system.input.confirm.short").to_lowercase();
        let user_input = input.trim().to_lowercase();

        let result = if user_input == confirm_key {
            // Best√§tigt - f√ºhre Aktion aus
            match &self.pending_confirmation.as_ref().unwrap().action {
                SystemAction::Exit => SystemCommandResult::Exit,
                SystemAction::Restart => SystemCommandResult::Restart,
                SystemAction::ClearHistory => SystemCommandResult::ClearHistory,
                SystemAction::CleanupExecute(force_command) => {
                    SystemCommandResult::CleanupExecute(force_command.clone())
                }
            }
        } else {
            // Abgebrochen
            SystemCommandResult::Message(get_translation("system.input.cancelled", &[]))
        };

        self.pending_confirmation = None;
        result
    }

    // Helper-Methoden bleiben unver√§ndert
    pub fn is_valid_confirmation_char(&self, c: char) -> bool {
        if self.pending_confirmation.is_none() {
            return false;
        }

        let confirm_char = t!("system.input.confirm.short").to_lowercase();
        let cancel_char = t!("system.input.cancel.short").to_lowercase();
        let char_str = c.to_lowercase().to_string();

        [confirm_char, cancel_char].contains(&char_str)
    }

    pub fn is_waiting_for_confirmation(&self) -> bool {
        self.pending_confirmation.is_some()
    }

    pub fn reset_for_language_change(&mut self) {
        self.pending_confirmation = None;
    }
}

#[derive(Debug, PartialEq)]
pub enum SystemCommandResult {
    NotSystemCommand,
    ClearScreen,
    Exit,
    Restart,
    ClearHistory,
    CleanupExecute(String),
    ShowPrompt(String),
    Message(String),
}

// =====================================================
// ERWEITERTE InputState MIT ZENTRALER VERARBEITUNG
// =====================================================

pub struct InputState {
    content: String,
    cursor: UiCursor,
    prompt: String,
    history_manager: HistoryManager,
    config: Config,
    command_handler: CommandHandler,
    keyboard_manager: KeyboardManager,
    system_processor: SystemCommandProcessor, // ‚úÖ NEU: Zentrale Verarbeitung
}

#[derive(Debug, Clone, Default)]
pub struct InputStateBackup {
    pub content: String,
    pub history: Vec<String>,
    pub cursor_pos: usize,
}

impl InputState {
    pub fn new(config: &Config) -> Self {
        let history_config = HistoryConfig::from_main_config(config);
        Self {
            content: String::with_capacity(100),
            cursor: UiCursor::from_config(config, CursorKind::Input),
            prompt: config.theme.input_cursor_prefix.clone(),
            history_manager: HistoryManager::new(history_config.max_entries),
            config: config.clone(),
            command_handler: CommandHandler::new(),
            keyboard_manager: KeyboardManager::new(),
            system_processor: SystemCommandProcessor::default(),
        }
    }

    pub fn update_from_config(&mut self, config: &Config) {
        self.cursor.update_from_config(config);
        self.prompt = config.theme.input_cursor_prefix.clone();
        self.config = config.clone();
    }

    pub fn reset_for_language_change(&mut self) {
        self.system_processor.reset_for_language_change(); // ‚úÖ ZENTRAL
        self.clear_input();
    }

    // ‚úÖ NEUE ZENTRALE FUNKTION: History-Clear
    pub fn clear_history(&mut self) {
        self.history_manager.clear();
    }

    // =====================================================
    // HAUPTFUNKTION: INPUT HANDLING
    // =====================================================

    pub fn handle_key_event(&mut self, key: KeyEvent) -> Option<String> {
        // History navigation
        if let Some(action) = HistoryKeyboardHandler::get_history_action(&key) {
            return self.handle_history(action);
        }

        if key.code == KeyCode::Esc {
            return None;
        }

        let action = self.keyboard_manager.get_action(&key);

        // ‚úÖ BEST√ÑTIGUNGS-MODUS: Nur bestimmte Zeichen erlauben
        if self.system_processor.is_waiting_for_confirmation() {
            return self.handle_confirmation_input(action);
        }

        // ‚úÖ NORMALER MODUS: Alle Aktionen
        match action {
            KeyAction::Submit => self.handle_submit(),
            KeyAction::PasteBuffer => self.handle_paste(),
            KeyAction::CopySelection => self.handle_copy(),
            KeyAction::ClearLine => self.handle_clear_line(),
            KeyAction::InsertChar(c) => {
                self.insert_char(c);
                None
            }
            KeyAction::MoveLeft => {
                self.cursor.move_left();
                None
            }
            KeyAction::MoveRight => {
                self.cursor.move_right();
                None
            }
            KeyAction::MoveToStart => {
                self.cursor.move_to_start();
                None
            }
            KeyAction::MoveToEnd => {
                self.cursor.move_to_end();
                None
            }
            KeyAction::Backspace => {
                self.handle_backspace();
                None
            }
            KeyAction::Delete => {
                self.handle_delete();
                None
            }
            _ => None,
        }
    }

    /// ‚úÖ BEST√ÑTIGUNGS-INPUT (nur j/n erlaubt)
    fn handle_confirmation_input(&mut self, action: KeyAction) -> Option<String> {
        match action {
            KeyAction::Submit => {
                let result = self.system_processor.process_command(&self.content);
                self.clear_input();
                self.convert_system_result(result)
            }
            KeyAction::InsertChar(c) => {
                if self.system_processor.is_valid_confirmation_char(c) {
                    self.content.clear();
                    self.content.push(c);
                    self.cursor.update_text_length(&self.content);
                    self.cursor.move_to_end();
                }
                None
            }
            KeyAction::Backspace | KeyAction::Delete | KeyAction::ClearLine => {
                self.clear_input();
                None
            }
            _ => None,
        }
    }

    /// ‚úÖ SUBMIT: Zentrale Verarbeitung
    fn handle_submit(&mut self) -> Option<String> {
        if self.content.is_empty() || self.content.trim().is_empty() {
            return None;
        }

        if self.content.graphemes(true).count() > 1024 {
            return Some(get_translation("system.input.too_long", &["1024"]));
        }

        let input = self.content.trim().to_string();

        // 1Ô∏è‚É£ SYSTEM-COMMAND VERARBEITUNG (zentral!)
        let system_result = self.system_processor.process_command(&input);
        if system_result != SystemCommandResult::NotSystemCommand {
            self.clear_input();
            return self.convert_system_result(system_result);
        }

        // 2Ô∏è‚É£ NORMALE COMMAND VERARBEITUNG
        let content = std::mem::take(&mut self.content);
        self.cursor.reset_for_empty_text();
        self.history_manager.add_entry(content.clone());

        let result = self.command_handler.handle_input(&content);

        // 3Ô∏è‚É£ HANDLE SPECIAL RESPONSES
        if let Some(event) = HistoryEventHandler::handle_command_result(&result.message) {
            return Some(self.handle_history_event(event));
        }

        // 4Ô∏è‚É£ PR√úFE AUF SYSTEM-RESPONSES
        let system_result = self.system_processor.process_command(&result.message);
        if system_result != SystemCommandResult::NotSystemCommand {
            return self.convert_system_result(system_result);
        }

        // 5Ô∏è‚É£ STANDARD RESPONSE
        if result.should_exit {
            Some(format!("__EXIT__{}", result.message))
        } else {
            Some(result.message)
        }
    }

    /// ‚úÖ KONVERTIERE System-Result zu String
    fn convert_system_result(&mut self, result: SystemCommandResult) -> Option<String> {
        match result {
            SystemCommandResult::NotSystemCommand => None,
            SystemCommandResult::ClearScreen => Some("__CLEAR__".to_string()),
            SystemCommandResult::Exit => Some("__EXIT__".to_string()),
            SystemCommandResult::Restart => Some("__RESTART__".to_string()),
            SystemCommandResult::ClearHistory => {
                self.clear_history();
                Some(get_translation("system.input.history_cleared", &[]))
            }
            SystemCommandResult::CleanupExecute(force_command) => {
                // F√ºhre Force-Command direkt aus
                let result = self.command_handler.handle_input(&force_command);
                Some(result.message)
            }
            SystemCommandResult::ShowPrompt(prompt) => Some(prompt),
            SystemCommandResult::Message(msg) => Some(msg),
        }
    }

    // =====================================================
    // BESTEHENDE FUNKTIONEN (unver√§ndert)
    // =====================================================

    fn handle_history(&mut self, action: HistoryAction) -> Option<String> {
        let entry = match action {
            HistoryAction::NavigatePrevious => self.history_manager.navigate_previous(),
            HistoryAction::NavigateNext => self.history_manager.navigate_next(),
        };

        if let Some(entry) = entry {
            self.content = entry;
            self.cursor.update_text_length(&self.content);
            self.cursor.move_to_end();
        }
        None
    }

    fn handle_history_event(&mut self, event: HistoryEvent) -> String {
        match event {
            HistoryEvent::Clear => {
                self.clear_history(); // ‚úÖ ZENTRAL
                HistoryEventHandler::create_clear_response()
            }
            HistoryEvent::Add(entry) => {
                self.history_manager.add_entry(entry);
                String::new()
            }
            _ => String::new(),
        }
    }

    // ‚úÖ CLIPBOARD OPERATIONS (unver√§ndert von deinem Code)
    fn handle_paste(&mut self) -> Option<String> {
        let text = self.read_clipboard()?;
        let clean = text
            .replace(['\n', '\r', '\t'], " ")
            .chars()
            .filter(|c| !c.is_control() || *c == ' ')
            .collect::<String>();

        if clean.is_empty() {
            return Some(get_translation("system.input.clipboard.empty", &[]));
        }

        let current_len = self.content.graphemes(true).count();
        let available = self.config.input_max_length.saturating_sub(current_len);
        let paste_text = clean.graphemes(true).take(available).collect::<String>();

        if !paste_text.is_empty() {
            let byte_pos = self.cursor.get_byte_position(&self.content);
            self.content.insert_str(byte_pos, &paste_text);
            let chars_added = paste_text.graphemes(true).count();
            self.cursor.update_text_length(&self.content);

            for _ in 0..chars_added {
                self.cursor.move_right();
            }
            Some(get_translation(
                "system.input.clipboard.pasted",
                &[&chars_added.to_string()],
            ))
        } else {
            Some(get_translation(
                "system.input.clipboard.nothing_to_paste",
                &[],
            ))
        }
    }

    fn handle_copy(&self) -> Option<String> {
        if self.content.is_empty() {
            return Some(get_translation(
                "system.input.clipboard.nothing_to_copy",
                &[],
            ));
        }

        if self.write_clipboard(&self.content) {
            let preview = if self.content.chars().count() > 50 {
                format!("{}...", self.content.chars().take(50).collect::<String>())
            } else {
                self.content.clone()
            };
            Some(get_translation(
                "system.input.clipboard.copied",
                &[&preview],
            ))
        } else {
            Some(get_translation("system.input.clipboard.copy_failed", &[]))
        }
    }

    fn handle_clear_line(&mut self) -> Option<String> {
        if self.content.is_empty() {
            return None;
        }

        let result = if self.write_clipboard(&self.content) {
            let preview = if self.content.chars().count() > 50 {
                format!("{}...", self.content.chars().take(50).collect::<String>())
            } else {
                self.content.clone()
            };
            get_translation("system.input.clipboard.cut", &[&preview])
        } else {
            get_translation("system.input.clipboard.cleared", &[])
        };

        self.clear_input();
        Some(result)
    }

    // ‚úÖ CLIPBOARD SYSTEM (unver√§ndert)
    fn read_clipboard(&self) -> Option<String> {
        let output = self.get_clipboard_cmd("read")?.output().ok()?;
        let text = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if text.is_empty() {
            None
        } else {
            Some(text)
        }
    }

    fn write_clipboard(&self, text: &str) -> bool {
        if text.is_empty() {
            return false;
        }

        if let Some(mut cmd) = self.get_clipboard_cmd("write") {
            if let Ok(mut child) = cmd.stdin(std::process::Stdio::piped()).spawn() {
                if let Some(stdin) = child.stdin.as_mut() {
                    use std::io::Write;
                    let _ = stdin.write_all(text.as_bytes());
                }
                return child.wait().is_ok();
            }
        }
        false
    }

    fn get_clipboard_cmd(&self, op: &str) -> Option<std::process::Command> {
        #[cfg(target_os = "macos")]
        {
            Some(std::process::Command::new(if op == "read" {
                "pbpaste"
            } else {
                "pbcopy"
            }))
        }

        #[cfg(target_os = "linux")]
        {
            let mut cmd = std::process::Command::new("xclip");
            if op == "read" {
                cmd.args(["-selection", "clipboard", "-o"]);
            } else {
                cmd.args(["-selection", "clipboard"]);
            }
            Some(cmd)
        }

        #[cfg(target_os = "windows")]
        {
            if op == "read" {
                let mut cmd = std::process::Command::new("powershell");
                cmd.args(["-Command", "Get-Clipboard"]);
                Some(cmd)
            } else {
                None
            }
        }

        #[cfg(not(any(target_os = "macos", target_os = "linux", target_os = "windows")))]
        None
    }

    // ‚úÖ TEXT EDITING (unver√§ndert)
    fn insert_char(&mut self, c: char) {
        if self.content.graphemes(true).count() < self.config.input_max_length {
            let byte_pos = self.cursor.get_byte_position(&self.content);
            self.content.insert(byte_pos, c);
            self.cursor.update_text_length(&self.content);
            self.cursor.move_right();
        }
    }

    fn handle_backspace(&mut self) {
        if self.content.is_empty() || self.cursor.get_position() == 0 {
            return;
        }

        let current = self.cursor.get_byte_position(&self.content);
        let prev = self.cursor.get_prev_byte_position(&self.content);

        if prev < current && current <= self.content.len() {
            self.cursor.move_left();
            self.content.replace_range(prev..current, "");
            self.cursor.update_text_length(&self.content);

            if self.content.is_empty() {
                self.cursor.reset_for_empty_text();
            }
        }
    }

    fn handle_delete(&mut self) {
        let text_len = self.content.graphemes(true).count();
        if self.cursor.get_position() >= text_len || text_len == 0 {
            return;
        }

        let current = self.cursor.get_byte_position(&self.content);
        let next = self.cursor.get_next_byte_position(&self.content);

        if current < next && next <= self.content.len() {
            self.content.replace_range(current..next, "");
            self.cursor.update_text_length(&self.content);

            if self.content.is_empty() {
                self.cursor.reset_for_empty_text();
            }
        }
    }

    fn clear_input(&mut self) {
        self.content.clear();
        self.history_manager.reset_position();
        self.cursor.move_to_start();
    }

    // ‚úÖ GETTERS
    pub fn get_content(&self) -> &str {
        &self.content
    }

    pub fn get_history_count(&self) -> usize {
        self.history_manager.entry_count()
    }
}

// ‚úÖ WIDGET TRAIT IMPLEMENTATIONS (unver√§ndert)
impl Widget for InputState {
    fn render(&self) -> Paragraph<'_> {
        self.render_with_cursor().0
    }

    fn handle_input(&mut self, key: KeyEvent) -> Option<String> {
        self.handle_key_event(key)
    }
}

impl CursorWidget for InputState {
    fn render_with_cursor(&self) -> (Paragraph<'_>, Option<(u16, u16)>) {
        let graphemes: Vec<&str> = self.content.graphemes(true).collect();
        let cursor_pos = self.cursor.get_position();
        let prompt_width = self.prompt.width();
        let available_width = self
            .config
            .input_max_length
            .saturating_sub(prompt_width + 4);

        // Viewport calculation
        let viewport_start = if cursor_pos > available_width {
            cursor_pos - available_width + 10
        } else {
            0
        };

        // Create spans
        let mut spans = vec![Span::styled(
            &self.prompt,
            Style::default().fg(self.config.theme.input_cursor_color.into()),
        )];

        let end_pos = (viewport_start + available_width).min(graphemes.len());
        let visible = graphemes
            .get(viewport_start..end_pos)
            .unwrap_or(&[])
            .join("");
        spans.push(Span::styled(
            visible,
            Style::default().fg(self.config.theme.input_text.into()),
        ));

        let paragraph = Paragraph::new(Line::from(spans)).block(
            Block::default()
                .padding(Padding::new(3, 1, 1, 1))
                .borders(Borders::NONE)
                .style(Style::default().bg(self.config.theme.input_bg.into())),
        );

        // Cursor coordinates
        let cursor_coord = if self.cursor.is_visible() && cursor_pos >= viewport_start {
            let chars_before = graphemes.get(viewport_start..cursor_pos).unwrap_or(&[]);
            let visible_width: usize = chars_before
                .iter()
                .map(|g| UnicodeWidthStr::width(*g))
                .sum();
            Some(((prompt_width + visible_width) as u16, 0u16))
        } else {
            None
        };

        (paragraph, cursor_coord)
    }
}

impl StatefulWidget for InputState {
    fn export_state(&self) -> InputStateBackup {
        InputStateBackup {
            content: self.content.clone(),
            history: self.history_manager.get_all_entries(),
            cursor_pos: self.cursor.get_current_position(),
        }
    }

    fn import_state(&mut self, state: InputStateBackup) {
        self.content = state.content;
        self.history_manager.import_entries(state.history);
        self.cursor.update_text_length(&self.content);
    }
}

impl AnimatedWidget for InputState {
    fn tick(&mut self) {
        self.cursor.update_blink();
    }
}

// ## END ##

// ## FILE: src/lib.rs
// ## BEGIN ##
// =====================================================
// FILE: src/lib.rs - OPTIMIERTE VERSION
// =====================================================

#[macro_export]
macro_rules! impl_default {
    ($type:ty, $body:expr) => {
        impl Default for $type {
            fn default() -> Self {
                $body
            }
        }
    };
}

#[macro_export]
macro_rules! matches_exact {
    ($cmd:expr, $($pattern:literal)|+) => {
        matches!($cmd.trim().to_lowercase().as_str(), $($pattern)|+)
    };
}

// Module definitions
pub mod commands;
pub mod core;
pub mod embedded;
pub mod i18n;
pub mod input;
pub mod memory;
pub mod output;
pub mod proxy;
pub mod server;
pub mod setup;
pub mod ui;

// Essential re-exports
pub use commands::{Command, CommandHandler, CommandRegistry};
pub use core::config::Config;
pub use core::error::{AppError, Result};
pub use ui::screen::ScreenManager;

// ‚úÖ OPTIMIERT: Lazy static f√ºr Registry - nur einmal erstellen
use std::sync::OnceLock;
static DEFAULT_REGISTRY: OnceLock<CommandRegistry> = OnceLock::new();

pub fn create_default_registry() -> CommandRegistry {
    build_registry()
}

// ‚úÖ EXTRACTED: Registry-Building separiert f√ºr bessere Testbarkeit
fn build_registry() -> CommandRegistry {
    use commands::{
        cleanup::CleanupCommand, clear::ClearCommand, create::CreateCommand, exit::ExitCommand,
        help::HelpCommand, history::HistoryCommand, lang::LanguageCommand, list::ListCommand,
        log_level::LogLevelCommand, memory::command::MemoryCommand, recovery::RecoveryCommand,
        restart::RestartCommand, start::StartCommand, stop::StopCommand, theme::ThemeCommand,
        version::VersionCommand,
    };

    let mut registry = CommandRegistry::new();

    // ‚úÖ OPTIMIERT: Functional-Style Chain f√ºr kompakteren Code
    registry
        // Core Commands
        .register(HelpCommand::new())
        .register(VersionCommand)
        .register(ClearCommand)
        .register(ExitCommand)
        .register(RestartCommand)
        // Configuration Commands
        .register(LogLevelCommand)
        .register(LanguageCommand::new())
        .register(ThemeCommand::new())
        // Utility Commands
        .register(HistoryCommand)
        .register(RecoveryCommand::new())
        .register(MemoryCommand::new())
        // Server Commands
        .register(CleanupCommand::new())
        .register(CreateCommand::new())
        .register(ListCommand::new())
        .register(StartCommand::new())
        .register(StopCommand::new());

    registry
}

// ‚úÖ VEREINFACHT: Main entry point
pub async fn run() -> Result<()> {
    let config = Config::load().await?;
    run_with_config(config).await
}

// ‚úÖ OPTIMIERT: Direkte Implementierung ohne Duplikation
pub async fn run_with_config(config: Config) -> Result<()> {
    let mut screen = ScreenManager::new(&config).await?;
    screen.run().await
}

// ‚úÖ VEREINFACHT: Convenience functions
pub fn create_handler() -> CommandHandler {
    CommandHandler::new()
}

pub async fn load_config() -> Result<Config> {
    Config::load().await
}

// ‚úÖ NEU: Registry-Testing Helper (f√ºr Unit Tests)
#[cfg(test)]
pub fn create_test_registry() -> CommandRegistry {
    // F√ºr Tests immer fresh Registry ohne static caching
    build_registry()
}

// ‚úÖ NEU: Command-Count f√ºr Debugging
pub fn get_command_count() -> usize {
    DEFAULT_REGISTRY.get().map(|r| r.len()).unwrap_or(0)
}

// ## END ##

// ## FILE: src/setup/setup_toml.rs
// ## BEGIN ##
// src/setup/setup_toml.rs - Cleaned and optimized
use crate::core::prelude::*;
use std::path::PathBuf;
use tokio::fs;

// Consolidated DEFAULT_CONFIG - All sections in one place
const DEFAULT_CONFIG: &str = r#"[general]
max_messages = 1000
typewriter_delay = 5
input_max_length = 100
max_history = 30
poll_rate = 16
log_level = "info"
current_theme = "dark"

[language]
current = "en"

# =====================================================
# SERVER CONFIGURATION
# =====================================================
[server]
# Port Management
port_range_start = 8000      # Starting port for auto-allocation
port_range_end = 8200        # Maximum port for auto-allocation
max_concurrent = 10          # Maximum simultaneous servers
shutdown_timeout = 5         # Graceful shutdown timeout (seconds)
startup_delay_ms = 500       # Delay after server creation (milliseconds)
workers = 1                  # Actix workers per server
auto_open_browser = true     # Automatically open browser

# HTTPS/TLS Configuration
enable_https = true          # Enable HTTPS support
https_port_offset = 1000     # HTTPS port = HTTP port + offset
cert_dir = ".rss/certs"      # Certificate storage directory
auto_cert = true             # Generate certificates automatically
cert_validity_days = 365     # Certificate validity (days)

# Production Settings
use_lets_encrypt = false     # Use Let's Encrypt (requires public domain)
production_domain = "localhost"  # Production domain name

# =====================================================
# REVERSE PROXY CONFIGURATION
# =====================================================
[proxy]
enabled = true                  # Enable integrated reverse proxy
port = 3000                     # Proxy listening port
https_port_offset = 443         # Neu hinzuf√ºgen
bind_address = "127.0.0.1"      # Proxy bind address
health_check_interval = 30      # Health check interval (seconds)
timeout_ms = 5000               # Request timeout (milliseconds)

# For production use:
# port = 80                  # Standard HTTP Port
# bind_address = "0.0.0.0"   # All interfaces (for external access)

# =====================================================
# LOGGING CONFIGURATION
# =====================================================
[logging]
max_file_size_mb = 100       # Log rotation size (100MB per file)
max_archive_files = 9        # Archive generations (9 backups)
compress_archives = true     # GZIP compression for archives
log_requests = true          # Enable request logging
log_security_alerts = true  # Enable security monitoring
log_performance = true       # Enable performance metrics

# =====================================================
# THEME DEFINITIONS
# =====================================================
[theme.dark]
output_bg = "Black"
output_text = "White"
output_cursor = "PIPE"
output_cursor_color = "White"
input_bg = "White"
input_text = "Black"
input_cursor_prefix = "/// "
input_cursor = "PIPE"
input_cursor_color = "Black"

[theme.light]
output_bg = "White"
output_text = "Black"
output_cursor = "PIPE"
output_cursor_color = "Black"
input_bg = "Black"
input_text = "White"
input_cursor_prefix = "/// "
input_cursor = "PIPE"
input_cursor_color = "White"

[theme.green]
output_bg = "Black"
output_text = "Green"
output_cursor = "BLOCK"
output_cursor_color = "Green"
input_bg = "LightGreen"
input_text = "Black"
input_cursor_prefix = "$ "
input_cursor = "BLOCK"
input_cursor_color = "Black"

[theme.blue]
output_bg = "White"
output_text = "LightBlue"
output_cursor = "UNDERSCORE"
output_cursor_color = "Blue"
input_bg = "Blue"
input_text = "White"
input_cursor_prefix = "> "
input_cursor = "UNDERSCORE"
input_cursor_color = "White"
"#;

pub async fn ensure_config_exists() -> Result<PathBuf> {
    let config_path = get_primary_config_path()?;

    // Create directory if needed
    if let Some(parent) = config_path.parent() {
        fs::create_dir_all(parent).await.map_err(AppError::Io)?;
    }

    // Create config file if it doesn't exist
    if !config_path.exists() {
        fs::write(&config_path, DEFAULT_CONFIG)
            .await
            .map_err(AppError::Io)?;

        log::info!(
            "{}",
            get_translation(
                "system.config.file_created",
                &[&config_path.display().to_string()]
            )
        );
    }

    Ok(config_path)
}

pub fn get_config_paths() -> Vec<PathBuf> {
    let mut paths = Vec::new();

    if let Ok(exe_path) = std::env::current_exe() {
        if let Some(base_dir) = exe_path.parent() {
            // Primary locations (in order of preference)
            paths.push(base_dir.join(".rss/rush.toml"));
            paths.push(base_dir.join("rush.toml"));
            paths.push(base_dir.join("config/rush.toml"));
        }
    }

    // Development fallbacks
    #[cfg(debug_assertions)]
    {
        paths.push(PathBuf::from("rush.toml"));
        paths.push(PathBuf::from("src/rush.toml"));
    }

    paths
}

fn get_primary_config_path() -> Result<PathBuf> {
    let exe_path = std::env::current_exe().map_err(AppError::Io)?;
    let base_dir = exe_path
        .parent()
        .ok_or_else(|| AppError::Validation(get_translation("system.config.dir_error", &[])))?;

    Ok(base_dir.join(".rss/rush.toml"))
}

// ## END ##

// ## FILE: src/setup/mod.rs
// ## BEGIN ##
// src/setup/mod.rs
pub mod setup_toml;

// ## END ##

// ## FILE: src/output/display.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::ui::color::AppColor;
use crate::ui::cursor::{CursorKind, UiCursor};
use crate::ui::viewport::{ScrollDirection, Viewport, ViewportEvent};
use ratatui::{
    style::Style,
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph, Wrap},
};
use strip_ansi_escapes::strip;
use unicode_segmentation::UnicodeSegmentation;

#[derive(Debug)]
pub struct Message {
    pub content: String,
    pub current_length: usize,
    pub timestamp: Instant,
    pub line_count: usize,
    pub typewriter_cursor: Option<UiCursor>,
}

#[derive(Debug, Clone)]
struct CachedLine {
    content: String,
    message_index: usize,
    is_partial: bool,
    visible_chars: usize,
}

type RenderData<'a> = (
    Vec<(String, usize, bool, bool, bool)>,
    Config,
    crate::ui::viewport::LayoutArea,
    &'a UiCursor,
);

impl Message {
    pub fn new(content: String, typewriter_delay: Duration) -> Self {
        let (initial_length, typewriter_cursor) = if typewriter_delay.as_millis() == 0 {
            (content.graphemes(true).count(), None)
        } else {
            (0, Some(UiCursor::for_typewriter()))
        };

        Self {
            content,
            current_length: initial_length,
            timestamp: Instant::now(),
            line_count: 1,
            typewriter_cursor,
        }
    }

    pub fn calculate_wrapped_line_count(&mut self, viewport: &Viewport) {
        let clean_content = clean_message_for_display(&self.content);
        if clean_content.is_empty() {
            self.line_count = 1;
            return;
        }

        let effective_width = (viewport.output_area().width as usize)
            .saturating_sub(2)
            .max(10);
        let raw_lines: Vec<&str> = clean_content.lines().collect();

        let lines_to_process = if clean_content.ends_with('\n') {
            let mut lines = raw_lines;
            lines.push("");
            lines
        } else if raw_lines.is_empty() {
            vec![""]
        } else {
            raw_lines
        };

        self.line_count = lines_to_process
            .iter()
            .map(|line| {
                if line.is_empty() {
                    1
                } else {
                    ((line.graphemes(true).count().saturating_sub(1)) / effective_width) + 1
                }
            })
            .sum::<usize>()
            .max(1);
    }

    pub fn is_typing(&self) -> bool {
        self.typewriter_cursor.is_some()
            && self.current_length < self.content.graphemes(true).count()
    }
    pub fn is_cursor_visible(&self) -> bool {
        self.typewriter_cursor
            .as_ref()
            .is_some_and(|c| c.is_visible())
    }
}

pub struct MessageDisplay {
    messages: Vec<Message>,
    line_cache: Vec<CachedLine>,
    cache_dirty: bool,
    config: Config,
    viewport: Viewport,
    persistent_cursor: UiCursor,
}

impl MessageDisplay {
    pub fn new(config: &Config, terminal_width: u16, terminal_height: u16) -> Self {
        Self::log_startup();
        Self {
            messages: Vec::with_capacity(config.max_messages),
            line_cache: Vec::new(),
            cache_dirty: true,
            config: config.clone(),
            viewport: Viewport::new(terminal_width, terminal_height),
            persistent_cursor: UiCursor::from_config(config, CursorKind::Output),
        }
    }

    fn rebuild_line_cache(&mut self) {
        self.line_cache.clear();
        let effective_width = (self.viewport.output_area().width as usize)
            .saturating_sub(2)
            .max(10);

        for (msg_idx, message) in self.messages.iter().enumerate() {
            let visible_content = if message.is_typing() {
                let graphemes: Vec<&str> = message.content.graphemes(true).collect();
                graphemes
                    .iter()
                    .take(message.current_length)
                    .copied()
                    .collect::<String>()
            } else {
                message.content.clone()
            };

            let clean_content = clean_message_for_display(&visible_content);
            let lines: Vec<String> = if clean_content.is_empty() {
                vec![String::new()]
            } else {
                let mut lines: Vec<String> = clean_content.lines().map(|s| s.to_string()).collect();
                if clean_content.ends_with('\n') {
                    lines.push(String::new());
                }
                if lines.is_empty() {
                    lines.push(String::new());
                }
                lines
            };

            for (line_idx, raw_line) in lines.iter().enumerate() {
                if raw_line.is_empty() {
                    self.line_cache.push(CachedLine {
                        content: String::new(),
                        message_index: msg_idx,
                        is_partial: false,
                        visible_chars: 0,
                    });
                } else {
                    let graphemes: Vec<&str> = raw_line.graphemes(true).collect();
                    let mut start = 0;
                    while start < graphemes.len() {
                        let end = (start + effective_width).min(graphemes.len());
                        let wrapped_line = graphemes[start..end].join("");
                        let is_last_chunk = end == graphemes.len();
                        let is_last_line = line_idx == lines.len() - 1;

                        self.line_cache.push(CachedLine {
                            content: wrapped_line.clone(),
                            message_index: msg_idx,
                            is_partial: message.is_typing() && is_last_line && is_last_chunk,
                            visible_chars: wrapped_line.graphemes(true).count(),
                        });
                        start = end;
                    }
                }
            }
        }

        if let Some(last_msg) = self.messages.last() {
            if !last_msg.is_typing() {
                self.line_cache.push(CachedLine {
                    content: String::new(),
                    message_index: self.messages.len(),
                    is_partial: false,
                    visible_chars: 0,
                });
            }
        }

        self.cache_dirty = false;
        self.viewport
            .update_content_height_silent(self.line_cache.len());
    }

    pub fn get_visible_messages(&mut self) -> Vec<(String, usize, bool, bool, bool)> {
        if self.cache_dirty {
            self.rebuild_line_cache();
        }

        let window_height = self.viewport.window_height();
        let scroll_offset = self.viewport.scroll_offset();
        let available_lines = self.line_cache.len().saturating_sub(scroll_offset);
        let lines_to_show = available_lines.min(window_height);
        let visible_start = scroll_offset;
        let visible_end = scroll_offset + lines_to_show;

        let mut result = Vec::new();
        if self.line_cache.is_empty() {
            result.push((
                String::new(),
                0,
                false,
                false,
                self.persistent_cursor.is_visible(),
            ));
            return result;
        }

        for line_idx in visible_start..visible_end {
            if let Some(cached_line) = self.line_cache.get(line_idx) {
                let msg_idx = cached_line.message_index;
                let is_last_line = line_idx == self.line_cache.len() - 1;

                let (is_typing, cursor_visible) = if msg_idx < self.messages.len() {
                    self.messages.get(msg_idx).map_or((false, false), |msg| {
                        (
                            cached_line.is_partial && msg.is_typing(),
                            msg.is_cursor_visible() && cached_line.is_partial,
                        )
                    })
                } else {
                    (false, false)
                };

                let persistent_cursor =
                    is_last_line && !is_typing && self.persistent_cursor.is_visible();
                result.push((
                    cached_line.content.clone(),
                    cached_line.visible_chars,
                    is_typing,
                    cursor_visible,
                    persistent_cursor,
                ));
            }
        }

        while result.len() < window_height {
            result.push((String::new(), 0, false, false, false));
        }
        result
    }

    pub fn add_message(&mut self, content: String) {
        self.add_message_with_typewriter(content, true);
    }
    pub fn add_message_instant(&mut self, content: String) {
        self.add_message_with_typewriter(content, false);
    }

    fn add_message_with_typewriter(&mut self, content: String, use_typewriter: bool) {
        let line_count = content.lines().count();
        let force_instant = line_count > 5 || content.len() > 200;

        Self::log_to_file(&content);

        if self.messages.len() >= self.config.max_messages {
            self.messages.remove(0);
            self.cache_dirty = true;
        }

        let typewriter_delay = if use_typewriter && !force_instant {
            self.config.typewriter_delay
        } else {
            Duration::from_millis(0)
        };

        let mut message = Message::new(content, typewriter_delay);
        message.calculate_wrapped_line_count(&self.viewport);
        self.messages.push(message);
        self.cache_dirty = true;
        self.rebuild_line_cache();

        // ‚úÖ HIER EINF√úGEN - nach rebuild_line_cache():
        if force_instant || !use_typewriter {
            self.viewport.enable_auto_scroll_silent();
        }

        if self.viewport.is_auto_scroll_enabled() {
            let content_height = self.line_cache.len();
            let window_height = self.viewport.window_height();
            if content_height > window_height {
                self.viewport
                    .set_scroll_offset_direct_silent(content_height - window_height);
            }
        }
    }

    pub fn update_typewriter(&mut self) {
        self.persistent_cursor.update_blink();
        if self.config.typewriter_delay.as_millis() == 0 {
            return;
        }

        let mut needs_rebuild = false;
        if let Some(last_message) = self.messages.last_mut() {
            let total_length = last_message.content.graphemes(true).count();
            if let Some(ref mut cursor) = last_message.typewriter_cursor {
                cursor.update_blink();
            }

            if last_message.current_length < total_length {
                let elapsed = last_message.timestamp.elapsed();
                if elapsed >= self.config.typewriter_delay {
                    let old_length = last_message.current_length;
                    let chars_to_add = if self.config.typewriter_delay.as_millis() <= 5 {
                        ((elapsed.as_millis() as f64
                            / self.config.typewriter_delay.as_millis() as f64)
                            .floor()
                            .max(1.0)) as usize
                    } else {
                        1
                    };

                    let new_length = (last_message.current_length + chars_to_add).min(total_length);
                    last_message.current_length = new_length;
                    last_message.timestamp = Instant::now();

                    let next_chars = last_message
                        .content
                        .chars()
                        .skip(old_length)
                        .take(chars_to_add)
                        .collect::<String>();
                    if next_chars.contains('\n') || (new_length - old_length) > 50 {
                        needs_rebuild = true;
                    }

                    self.cache_dirty = true;
                    if new_length == total_length {
                        last_message.typewriter_cursor = None;
                        needs_rebuild = true;
                        self.viewport.enable_auto_scroll_silent();
                        self.viewport.scroll_to_bottom();
                    }
                }
            }
        }
        if needs_rebuild && self.cache_dirty {
            self.rebuild_line_cache();
        }
    }

    pub fn handle_scroll(&mut self, direction: ScrollDirection, amount: usize) {
        match direction {
            ScrollDirection::Up => self.viewport.scroll_up(amount.max(1)),
            ScrollDirection::Down => self.viewport.scroll_down(amount.max(1)),
            ScrollDirection::PageUp => self.viewport.page_up(),
            ScrollDirection::PageDown => self.viewport.page_down(),
            ScrollDirection::ToTop => self.viewport.scroll_to_top(),
            ScrollDirection::ToBottom => self.viewport.scroll_to_bottom(),
        }
    }

    pub fn handle_resize(&mut self, width: u16, height: u16) -> bool {
        let changed = self.viewport.update_terminal_size(width, height);
        if changed {
            for message in &mut self.messages {
                message.calculate_wrapped_line_count(&self.viewport);
            }
            self.cache_dirty = true;
            self.viewport.force_auto_scroll();
        }
        changed
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
        self.line_cache.clear();
        self.cache_dirty = false;
        self.viewport.update_content_height_silent(0);
        self.viewport.force_auto_scroll();
        self.persistent_cursor.show_cursor();
    }

    pub fn create_output_widget_for_rendering(&mut self) -> RenderData<'_> {
        (
            self.get_visible_messages(),
            self.config.clone(),
            self.viewport.output_area(),
            &self.persistent_cursor,
        )
    }

    pub fn update_config(&mut self, new_config: &Config) {
        self.config = new_config.clone();
        self.persistent_cursor = UiCursor::from_config(new_config, CursorKind::Output);
        self.cache_dirty = true;
        if self.messages.len() > self.config.max_messages {
            let excess = self.messages.len() - self.config.max_messages;
            self.messages.drain(0..excess);
            self.cache_dirty = true;
        }
    }

    // Getters
    pub fn viewport(&self) -> &Viewport {
        &self.viewport
    }
    pub fn viewport_mut(&mut self) -> &mut Viewport {
        &mut self.viewport
    }
    pub fn get_messages_count(&self) -> usize {
        self.messages.len()
    }
    pub fn get_line_count(&self) -> usize {
        if self.cache_dirty {
            self.messages.iter().map(|m| m.line_count).sum()
        } else {
            self.line_cache.len()
        }
    }
    pub fn get_content_height(&self) -> usize {
        self.viewport.content_height()
    }
    pub fn get_window_height(&self) -> usize {
        self.viewport.window_height()
    }

    pub fn debug_scroll_status(&self) -> String {
        format!(
            "Scroll: offset={}, lines={}, window={}, auto={}, msgs={}, cache={}",
            self.viewport.scroll_offset(),
            self.viewport.content_height(),
            self.viewport.window_height(),
            self.viewport.is_auto_scroll_enabled(),
            self.messages.len(),
            self.line_cache.len()
        )
    }

    pub fn handle_viewport_event(&mut self, event: ViewportEvent) -> bool {
        let changed = self.viewport.handle_event(event);
        if changed {
            for message in &mut self.messages {
                message.calculate_wrapped_line_count(&self.viewport);
            }
            self.cache_dirty = true;
        }
        changed
    }

    pub fn log(&mut self, level: &str, message: &str) {
        self.add_message(format!("[{}] {}", level, message));
    }

    fn log_to_file(content: &str) {
        if content.starts_with("__") || content.trim().is_empty() {
            return;
        }
        if let Ok(exe_path) = std::env::current_exe() {
            if let Some(base_dir) = exe_path.parent() {
                let log_path = base_dir.join(".rss").join("rush.logs");
                let _ = std::fs::create_dir_all(log_path.parent().unwrap());
                let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
                let log_line = format!("[{}] {}\n", timestamp, content);
                let _ = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&log_path)
                    .and_then(|mut file| {
                        use std::io::Write;
                        file.write_all(log_line.as_bytes())
                    });
            }
        }
    }

    fn log_startup() {
        if let Ok(exe_path) = std::env::current_exe() {
            if let Some(base_dir) = exe_path.parent() {
                let log_path = base_dir.join(".rss").join("rush.logs");
                let _ = std::fs::create_dir_all(log_path.parent().unwrap());
                let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
                let version = crate::core::constants::VERSION;
                let startup_line = format!(
                    "[{}] === Rush Sync Server v{} Started ===\n",
                    timestamp, version
                );
                let _ = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(&log_path)
                    .and_then(|mut file| {
                        use std::io::Write;
                        file.write_all(startup_line.as_bytes())
                    });
            }
        }
    }
}

// Utility functions
fn clean_ansi_codes(message: &str) -> String {
    String::from_utf8_lossy(&strip(message.as_bytes()).unwrap_or_default()).into_owned()
}

fn clean_message_for_display(message: &str) -> String {
    clean_ansi_codes(message)
        .replace("__CONFIRM_EXIT__", "")
        .replace("__CLEAR__", "")
        .trim()
        .to_string()
}

fn parse_message_parts(message: &str) -> Vec<(String, bool)> {
    let mut parts = Vec::new();
    let mut chars = message.char_indices().peekable();
    let mut start = 0;

    while let Some((i, c)) = chars.peek().cloned() {
        if c == '[' {
            if start < i {
                let text = &message[start..i];
                if !text.trim().is_empty() {
                    parts.push((text.to_owned(), false));
                }
            }
            if let Some(end_idx) = message[i..].find(']') {
                let end = i + end_idx + 1;
                parts.push((message[i..end].to_owned(), true));
                start = end;
                while let Some(&(ci, _)) = chars.peek() {
                    if ci < end {
                        chars.next();
                    } else {
                        break;
                    }
                }
            } else {
                parts.push((message[i..].to_owned(), false));
                break;
            }
        } else {
            chars.next();
        }
    }

    if start < message.len() {
        let remaining = &message[start..];
        if !remaining.trim().is_empty() {
            parts.push((remaining.to_owned(), false));
        }
    }
    if parts.is_empty() {
        parts.push((message.to_owned(), false));
    }
    parts
}

fn get_marker_color(marker: &str) -> AppColor {
    let display_text = marker.trim_start_matches('[').trim_end_matches(']');
    AppColor::from_display_text(display_text) // ‚Üê NUR EINE ZEILE!
}

pub fn create_output_widget<'a>(
    messages: &'a [(String, usize, bool, bool, bool)],
    layout_area: crate::ui::viewport::LayoutArea,
    config: &'a Config,
    cursor_state: &'a UiCursor,
) -> Paragraph<'a> {
    let max_lines = layout_area.height as usize;
    if max_lines == 0 || layout_area.width == 0 {
        return Paragraph::new(vec![Line::from(vec![Span::raw(get_translation(
            "screen.render.invalid_layout",
            &[],
        ))])])
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(config.theme.output_bg.into())),
        );
    }

    let safe_max_lines = max_lines.min(1000);
    let mut lines = Vec::new();

    if messages.is_empty() {
        return Paragraph::new(vec![Line::from(vec![Span::raw("")]); safe_max_lines])
            .block(
                Block::default()
                    .borders(Borders::NONE)
                    .style(Style::default().bg(config.theme.output_bg.into())),
            )
            .wrap(Wrap { trim: true });
    }

    for (
        message_idx,
        (message, current_length, is_typing, msg_cursor_visible, persistent_cursor_visible),
    ) in messages.iter().enumerate()
    {
        let is_last_message = message_idx == messages.len() - 1;

        if message.is_empty() {
            if *persistent_cursor_visible {
                lines.push(Line::from(vec![cursor_state.create_cursor_span(config)]));
            } else {
                lines.push(Line::from(vec![Span::raw("")]));
            }
            continue;
        }

        let clean_message = clean_message_for_display(message);
        let message_lines: Vec<&str> = clean_message.lines().collect();

        if message_lines.is_empty() {
            lines.push(Line::from(vec![Span::raw("")]));
        } else {
            for (line_idx, line_content) in message_lines.iter().enumerate() {
                if lines.len() >= safe_max_lines {
                    break;
                }

                let is_last_line = line_idx == message_lines.len() - 1;
                let visible_chars = if is_last_message && is_last_line {
                    let chars_before_this_line: usize = message_lines
                        .iter()
                        .take(line_idx)
                        .map(|l| l.graphemes(true).count() + 1)
                        .sum();
                    current_length
                        .saturating_sub(chars_before_this_line)
                        .min(line_content.graphemes(true).count())
                } else {
                    line_content.graphemes(true).count()
                };

                let message_parts = parse_message_parts(line_content);
                let mut spans = Vec::new();
                let mut chars_used = 0;

                for (part_text, is_marker) in message_parts {
                    let part_chars = part_text.graphemes(true).count();
                    let part_style = if is_marker {
                        Style::default().fg(get_marker_color(&part_text).into())
                    } else {
                        Style::default().fg(config.theme.output_text.into())
                    };

                    if chars_used >= visible_chars {
                        break;
                    }
                    let chars_needed = visible_chars - chars_used;
                    if chars_needed >= part_chars {
                        spans.push(Span::styled(part_text, part_style));
                        chars_used += part_chars;
                    } else {
                        let graphemes: Vec<&str> = part_text.graphemes(true).collect();
                        spans.push(Span::styled(
                            graphemes
                                .iter()
                                .take(chars_needed)
                                .copied()
                                .collect::<String>(),
                            part_style,
                        ));
                        break;
                    }
                }

                if is_last_message
                    && is_last_line
                    && ((*is_typing && *msg_cursor_visible)
                        || (!*is_typing && *persistent_cursor_visible))
                {
                    spans.push(cursor_state.create_cursor_span(config));
                }
                if spans.is_empty() {
                    spans.push(Span::raw(""));
                }
                lines.push(Line::from(spans));
            }
        }
        if lines.len() >= safe_max_lines {
            break;
        }
    }

    while lines.len() < safe_max_lines {
        lines.push(Line::from(vec![Span::raw("")]));
    }
    lines.truncate(safe_max_lines);
    if lines.is_empty() {
        lines.push(Line::from(vec![Span::raw(get_translation(
            "screen.render.empty_buffer_error",
            &[],
        ))]));
    }

    Paragraph::new(lines)
        .block(
            Block::default()
                .borders(Borders::NONE)
                .style(Style::default().bg(config.theme.output_bg.into())),
        )
        .wrap(Wrap { trim: true })
}

// ## END ##

// ## FILE: src/output/mod.rs
// ## BEGIN ##
pub mod display;

// Legacy re-exports f√ºr Kompatibilit√§t
pub use display::MessageDisplay;

// ## END ##

// ## FILE: src/server/types.rs
// ## BEGIN ##
// ## FILE: src/server/types.rs - KOMPLETT KORRIGIERT
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    pub id: String,
    pub name: String,
    pub port: u16,
    pub status: ServerStatus,
    pub created_at: String,
    pub created_timestamp: u64,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum ServerStatus {
    Stopped,
    Running,
    Failed,
}

impl std::fmt::Display for ServerStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Stopped => "STOPPED",
                Self::Running => "RUNNING",
                Self::Failed => "FAILED",
            }
        )
    }
}

impl Default for ServerInfo {
    fn default() -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        Self {
            id: String::new(),
            name: String::new(),
            port: 0,
            status: ServerStatus::Stopped,
            created_at: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            created_timestamp: now,
        }
    }
}

// WICHTIG: ServerData-Struktur hinzugef√ºgt
#[derive(Debug, Clone)]
pub struct ServerData {
    pub id: String,
    pub port: u16,
    pub name: String,
}

pub type ServerMap = Arc<RwLock<HashMap<String, ServerInfo>>>;
pub type ServerHandles = Arc<RwLock<HashMap<String, actix_web::dev::ServerHandle>>>;

#[derive(Debug, Clone, Default)]
pub struct ServerContext {
    pub servers: ServerMap,
    pub handles: ServerHandles,
}

// ## END ##

// ## FILE: src/server/redirect.rs
// ## BEGIN ##
// src/server/redirect.rs
use crate::core::prelude::*;
use actix_web::{web, App, HttpRequest, HttpResponse, HttpServer};

/// HTTP‚ÜíHTTPS Redirect Server - Teil des Server-Systems
pub struct HttpRedirectServer {
    port: u16,
    target_port: u16,
}

impl HttpRedirectServer {
    pub fn new(port: u16, target_port: u16) -> Self {
        Self { port, target_port }
    }

    async fn redirect_handler(req: HttpRequest, target_port: web::Data<u16>) -> HttpResponse {
        let host = req
            .headers()
            .get("host")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("localhost");

        // Host ohne Port
        let host_clean = host.split(':').next().unwrap_or(host);

        let path = req.uri().path();
        let query = req.uri().query().unwrap_or("");

        // Redirect URL bauen
        let redirect_url = if *target_port.get_ref() == 443 {
            format!("https://{}{}", host_clean, path)
        } else {
            format!("https://{}:{}{}", host_clean, target_port.get_ref(), path)
        };

        let final_url = if !query.is_empty() {
            format!("{}?{}", redirect_url, query)
        } else {
            redirect_url
        };

        log::debug!("HTTP‚ÜíHTTPS: {} ‚Üí {}", req.uri(), final_url);

        HttpResponse::MovedPermanently()
            .insert_header(("Location", final_url))
            .insert_header(("Strict-Transport-Security", "max-age=31536000"))
            .finish()
    }

    pub async fn run(self) -> Result<()> {
        log::info!("HTTP redirect server starting on port {}", self.port);
        log::info!("Redirecting to HTTPS port {}", self.target_port);

        let target_port = self.target_port;

        HttpServer::new(move || {
            App::new()
                .app_data(web::Data::new(target_port))
                .default_service(web::route().to(Self::redirect_handler))
        })
        .bind(("0.0.0.0", self.port))
        .map_err(|e| AppError::Validation(format!("Port {} bind failed: {}", self.port, e)))?
        .run()
        .await
        .map_err(|e| AppError::Io(e))
    }
}

// ## END ##

// ## FILE: src/server/config.rs
// ## BEGIN ##
// ## FILE: src/server/config.rs - DEDUPLIZIERT
use crate::core::config::Config;

pub const SERVER_VERSION: &str = env!("CARGO_PKG_VERSION");
pub const SERVER_NAME: &str = env!("CARGO_PKG_NAME");

pub fn get_server_version() -> &'static str {
    SERVER_VERSION
}
pub fn get_server_name() -> &'static str {
    SERVER_NAME
}

pub fn get_server_config(config: &Config) -> &crate::core::config::ServerConfig {
    &config.server
}

pub fn get_logging_config(config: &Config) -> &crate::core::config::LoggingConfig {
    &config.logging
}

// ## END ##

// ## FILE: src/server/persistence.rs
// ## BEGIN ##
// ## FILE: src/server/persistence.rs - OPTIMIERT
use crate::core::prelude::*;
use crate::server::types::{ServerInfo, ServerStatus};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PersistentServerInfo {
    pub id: String,
    pub name: String,
    pub port: u16,
    pub status: ServerStatus,
    pub created_at: String,
    pub created_timestamp: u64,
    pub auto_start: bool,
    pub last_started: Option<String>,
    pub start_count: u32,
}

impl From<ServerInfo> for PersistentServerInfo {
    fn from(info: ServerInfo) -> Self {
        Self {
            id: info.id,
            name: info.name,
            port: info.port,
            status: info.status,
            created_at: info.created_at,
            created_timestamp: info.created_timestamp,
            auto_start: false,
            last_started: None,
            start_count: 0,
        }
    }
}

impl From<PersistentServerInfo> for ServerInfo {
    fn from(info: PersistentServerInfo) -> Self {
        Self {
            id: info.id,
            name: info.name,
            port: info.port,
            status: info.status,
            created_at: info.created_at,
            created_timestamp: info.created_timestamp,
        }
    }
}

pub struct ServerRegistry {
    file_path: PathBuf,
}

impl ServerRegistry {
    pub fn new() -> Result<Self> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let file_path = base_dir.join(".rss").join("servers.list");

        if let Some(parent) = file_path.parent() {
            std::fs::create_dir_all(parent).map_err(AppError::Io)?;
        }

        Ok(Self { file_path })
    }

    pub fn get_file_path(&self) -> &PathBuf {
        &self.file_path
    }

    pub async fn load_servers(&self) -> Result<HashMap<String, PersistentServerInfo>> {
        if !self.file_path.exists() {
            return Ok(HashMap::new());
        }

        let content = tokio::fs::read_to_string(&self.file_path)
            .await
            .map_err(AppError::Io)?;
        if content.trim().is_empty() {
            return Ok(HashMap::new());
        }

        let servers: Vec<PersistentServerInfo> = serde_json::from_str(&content)
            .map_err(|e| AppError::Validation(format!("Failed to parse server registry: {}", e)))?;

        Ok(servers.into_iter().map(|s| (s.id.clone(), s)).collect())
    }

    pub async fn save_servers(
        &self,
        servers: &HashMap<String, PersistentServerInfo>,
    ) -> Result<()> {
        let mut server_list: Vec<PersistentServerInfo> = servers.values().cloned().collect();
        server_list.sort_by_key(|s| s.created_timestamp);

        let content = serde_json::to_string_pretty(&server_list)
            .map_err(|e| AppError::Validation(format!("Failed to serialize servers: {}", e)))?;

        let temp_path = self.file_path.with_extension("tmp");
        tokio::fs::write(&temp_path, content)
            .await
            .map_err(AppError::Io)?;
        tokio::fs::rename(&temp_path, &self.file_path)
            .await
            .map_err(AppError::Io)?;

        Ok(())
    }

    // Vereinfachte Update-Methoden mit weniger Boilerplate
    async fn update_server(
        &self,
        server_id: &str,
        update_fn: impl Fn(&mut PersistentServerInfo),
    ) -> Result<HashMap<String, PersistentServerInfo>> {
        let mut servers = self.load_servers().await?;
        if let Some(server) = servers.get_mut(server_id) {
            update_fn(server);
            self.save_servers(&servers).await?;
        }
        Ok(servers)
    }

    pub async fn update_server_status(
        &self,
        server_id: &str,
        status: ServerStatus,
    ) -> Result<HashMap<String, PersistentServerInfo>> {
        self.update_server(server_id, |server| {
            server.status = status;
            if status == ServerStatus::Running {
                server.last_started =
                    Some(chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string());
                server.start_count += 1;
            }
        })
        .await
    }

    pub async fn set_auto_start(
        &self,
        server_id: &str,
        auto_start: bool,
    ) -> Result<HashMap<String, PersistentServerInfo>> {
        self.update_server(server_id, |server| {
            server.auto_start = auto_start;
        })
        .await
    }

    pub async fn add_server(
        &self,
        server_info: ServerInfo,
    ) -> Result<HashMap<String, PersistentServerInfo>> {
        let mut servers = self.load_servers().await?;
        let persistent_info = PersistentServerInfo::from(server_info);
        servers.insert(persistent_info.id.clone(), persistent_info);
        self.save_servers(&servers).await?;
        Ok(servers)
    }

    pub async fn remove_server(
        &self,
        server_id: &str,
    ) -> Result<HashMap<String, PersistentServerInfo>> {
        let mut servers = self.load_servers().await?;
        servers.remove(server_id);
        self.save_servers(&servers).await?;
        Ok(servers)
    }

    pub async fn cleanup_servers(
        &self,
        cleanup_type: CleanupType,
    ) -> Result<(HashMap<String, PersistentServerInfo>, usize)> {
        let mut servers = self.load_servers().await?;
        let initial_count = servers.len();

        servers.retain(|_, s| match cleanup_type {
            CleanupType::Stopped => s.status != ServerStatus::Stopped,
            CleanupType::Failed => s.status != ServerStatus::Failed,
            CleanupType::All => s.status == ServerStatus::Running,
        });

        let removed_count = initial_count - servers.len();
        if removed_count > 0 {
            self.save_servers(&servers).await?;
        }

        Ok((servers, removed_count))
    }

    pub fn get_auto_start_servers(
        &self,
        servers: &HashMap<String, PersistentServerInfo>,
    ) -> Vec<PersistentServerInfo> {
        servers
            .values()
            .filter(|s| s.auto_start && s.status != ServerStatus::Failed)
            .cloned()
            .collect()
    }

    // Utility-Methoden mit besserer Error-Behandlung
    pub async fn cleanup_server_directory(&self, server_name: &str, port: u16) -> Result<()> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let server_dir = base_dir
            .join("www")
            .join(format!("{}-[{}]", server_name, port));

        if server_dir.exists() {
            std::fs::remove_dir_all(&server_dir).map_err(AppError::Io)?;
            log::info!("Removed server directory: {:?}", server_dir);
        }
        Ok(())
    }

    pub fn list_www_directories(&self) -> Result<Vec<PathBuf>> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let www_dir = base_dir.join("www");
        if !www_dir.exists() {
            return Ok(vec![]);
        }

        let mut directories = Vec::new();
        for entry in std::fs::read_dir(&www_dir).map_err(AppError::Io)? {
            let entry = entry.map_err(AppError::Io)?;
            if entry.file_type().map_err(AppError::Io)?.is_dir() {
                directories.push(entry.path());
            }
        }
        directories.sort();
        Ok(directories)
    }
}

#[derive(Debug)]
pub enum CleanupType {
    Stopped,
    Failed,
    All,
}

// ## END ##

// ## FILE: src/server/watchdog.rs
// ## BEGIN ##
use crate::core::prelude::*;
use actix::ActorContext;
use actix::{Actor, AsyncContext, Handler, Message, StreamHandler};
use actix_web::{web, HttpRequest, HttpResponse};
use actix_web_actors::ws;
use notify::{Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::Duration;
use tokio::sync::broadcast;

#[derive(Debug, Clone, Serialize, Deserialize, Message)]
#[rtype(result = "()")]
pub struct FileChangeEvent {
    pub event_type: String,
    pub file_path: String,
    pub server_name: String,
    pub port: u16,
    pub timestamp: u64,
    pub file_extension: Option<String>,
}

#[derive(Debug)]
pub struct WatchdogManager {
    watchers: Arc<RwLock<HashMap<String, RecommendedWatcher>>>,
    sender: broadcast::Sender<FileChangeEvent>,
}

impl Default for WatchdogManager {
    fn default() -> Self {
        let (sender, _) = broadcast::channel(1000);
        Self {
            watchers: Arc::new(RwLock::new(HashMap::new())),
            sender,
        }
    }
}

impl WatchdogManager {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn subscribe(&self) -> broadcast::Receiver<FileChangeEvent> {
        self.sender.subscribe()
    }

    pub fn start_watching(&self, server_name: &str, port: u16) -> Result<()> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let watch_path = base_dir
            .join("www")
            .join(format!("{}-[{}]", server_name, port));

        if !watch_path.exists() {
            return Err(AppError::Validation(format!(
                "Server directory does not exist: {:?}",
                watch_path
            )));
        }

        let server_key = format!("{}:{}", server_name, port);
        let sender = self.sender.clone();
        let server_name_owned = server_name.to_owned();

        let mut watcher =
            notify::recommended_watcher(move |res: notify::Result<Event>| match res {
                Ok(event) => {
                    if let Err(e) = handle_file_event(&event, &server_name_owned, port, &sender) {
                        log::error!("Error handling file event: {}", e);
                    }
                }
                Err(e) => log::error!("Watch error: {:?}", e),
            })
            .map_err(|e| AppError::Validation(format!("Failed to create watcher: {}", e)))?;

        watcher
            .watch(&watch_path, RecursiveMode::Recursive)
            .map_err(|e| AppError::Validation(format!("Failed to start watching: {}", e)))?;

        let mut watchers = self.watchers.write().unwrap();
        watchers.insert(server_key.clone(), watcher);

        log::info!(
            "Started file watching for server {} on port {} at {:?}",
            server_name,
            port,
            watch_path
        );
        Ok(())
    }

    pub fn stop_watching(&self, server_name: &str, port: u16) -> Result<()> {
        let server_key = format!("{}:{}", server_name, port);
        let mut watchers = self.watchers.write().unwrap();

        if let Some(_watcher) = watchers.remove(&server_key) {
            log::info!(
                "Stopped file watching for server {} on port {}",
                server_name,
                port
            );
        }

        Ok(())
    }

    pub fn get_active_watchers(&self) -> Vec<String> {
        let watchers = self.watchers.read().unwrap();
        watchers.keys().cloned().collect()
    }
}

fn handle_file_event(
    event: &Event,
    server_name: &str,
    port: u16,
    sender: &broadcast::Sender<FileChangeEvent>,
) -> Result<()> {
    // Nur relevante Events verarbeiten
    let event_type = match event.kind {
        EventKind::Create(_) => "created",
        EventKind::Modify(_) => "modified",
        EventKind::Remove(_) => "deleted",
        _ => return Ok(()), // Ignore andere Events
    };

    for path in &event.paths {
        // Skip tempor√§re Dateien und Backups
        if let Some(file_name) = path.file_name() {
            let name = file_name.to_string_lossy();
            if name.starts_with('.')
                || name.ends_with('~')
                || name.contains(".tmp")
                || name.contains(".swp")
            {
                continue;
            }
        }

        let file_extension = path
            .extension()
            .and_then(|ext| ext.to_str())
            .map(|s| s.to_string());

        // Nur Web-relevante Dateien
        if let Some(ref ext) = file_extension {
            if ![
                "html", "css", "js", "json", "txt", "md", "svg", "png", "jpg", "jpeg", "gif", "ico",
            ]
            .contains(&ext.as_str())
            {
                continue;
            }
        }

        let change_event = FileChangeEvent {
            event_type: event_type.to_string(),
            file_path: path.to_string_lossy().to_string(),
            server_name: server_name.to_string(),
            port,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            file_extension,
        };

        if let Err(e) = sender.send(change_event) {
            log::error!("Failed to send file change event: {}", e);
        }
    }

    Ok(())
}

// WebSocket Actor f√ºr Hot Reload
pub struct HotReloadWs {
    receiver: Option<broadcast::Receiver<FileChangeEvent>>,
    server_filter: Option<String>, // Format: "name:port"
}

impl Actor for HotReloadWs {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        log::debug!("WebSocket connection established for hot reload");

        if let Some(mut receiver) = self.receiver.take() {
            let addr = ctx.address();

            tokio::spawn(async move {
                loop {
                    match receiver.recv().await {
                        Ok(event) => {
                            addr.do_send(event);
                        }
                        Err(broadcast::error::RecvError::Lagged(skipped)) => {
                            log::warn!("WebSocket lagged, skipped {} events", skipped);
                        }
                        Err(broadcast::error::RecvError::Closed) => {
                            log::debug!("WebSocket event channel closed");
                            break;
                        }
                    }
                }
            });
        }

        // Ping alle 30 Sekunden
        ctx.run_interval(Duration::from_secs(30), |_, ctx| {
            ctx.ping(b"");
        });
    }
}

impl StreamHandler<std::result::Result<ws::Message, ws::ProtocolError>> for HotReloadWs {
    fn handle(
        &mut self,
        msg: std::result::Result<ws::Message, ws::ProtocolError>,
        ctx: &mut Self::Context,
    ) {
        match msg {
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Pong(_)) => {}
            Ok(ws::Message::Text(text)) => {
                log::debug!("WebSocket received: {}", text);
            }
            Ok(ws::Message::Close(reason)) => {
                log::debug!("WebSocket closing: {:?}", reason);
                ctx.stop();
            }
            _ => ctx.stop(),
        }
    }
}

impl Handler<FileChangeEvent> for HotReloadWs {
    type Result = ();

    fn handle(&mut self, msg: FileChangeEvent, ctx: &mut Self::Context) -> Self::Result {
        // Filter nach Server wenn gesetzt
        if let Some(ref filter) = self.server_filter {
            let event_key = format!("{}:{}", msg.server_name, msg.port);
            if *filter != event_key {
                return;
            }
        }

        let json = match serde_json::to_string(&msg) {
            Ok(json) => json,
            Err(e) => {
                log::error!("Failed to serialize file change event: {}", e);
                return;
            }
        };

        ctx.text(json);
    }
}

// WebSocket Endpoint Handler
pub async fn ws_hot_reload(
    req: HttpRequest,
    stream: web::Payload,
    data: web::Data<Arc<WatchdogManager>>,
) -> std::result::Result<HttpResponse, actix_web::Error> {
    let server_filter = req
        .query_string()
        .split('&')
        .find_map(|param| {
            if param.starts_with("server=") {
                param.strip_prefix("server=")
            } else {
                None
            }
        })
        .map(|s| s.to_string());

    let ws_actor = HotReloadWs {
        receiver: Some(data.subscribe()),
        server_filter,
    };

    ws::start(ws_actor, &req, stream)
}

// Static globals f√ºr Manager
use std::sync::OnceLock;
static WATCHDOG_MANAGER: OnceLock<Arc<WatchdogManager>> = OnceLock::new();

pub fn get_watchdog_manager() -> &'static Arc<WatchdogManager> {
    WATCHDOG_MANAGER.get_or_init(|| Arc::new(WatchdogManager::new()))
}

pub fn start_server_watching(server_name: &str, port: u16) -> Result<()> {
    get_watchdog_manager().start_watching(server_name, port)
}

pub fn stop_server_watching(server_name: &str, port: u16) -> Result<()> {
    get_watchdog_manager().stop_watching(server_name, port)
}

// ## END ##

// ## FILE: src/server/logging.rs
// ## BEGIN ##
// ## FILE: src/server/logging.rs - ALLE FIXES APPLIED
use crate::core::config::LoggingConfig;
use crate::core::prelude::*;
use actix_web::HttpMessage; // HINZUGEF√úGT
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ServerLogEntry {
    pub timestamp: String,
    pub timestamp_unix: u64,
    pub event_type: LogEventType,
    pub ip_address: String,
    pub user_agent: Option<String>,
    pub method: String,
    pub path: String,
    pub status_code: Option<u16>,
    pub response_time_ms: Option<u64>,
    pub bytes_sent: Option<u64>,
    pub referer: Option<String>,
    pub query_string: Option<String>,
    pub headers: HashMap<String, String>,
    pub session_id: Option<String>,
}

// Copy-Trait hinzugef√ºgt f√ºr LogEventType
#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
pub enum LogEventType {
    Request,
    ServerStart,
    ServerStop,
    ServerError,
    SecurityAlert,
    PerformanceWarning,
}

#[derive(Debug, Clone)]
pub struct LogRotationConfig {
    pub max_file_size_bytes: u64,
    pub max_archive_files: u8,
    pub compress_archives: bool,
}

impl From<&LoggingConfig> for LogRotationConfig {
    fn from(config: &LoggingConfig) -> Self {
        Self {
            max_file_size_bytes: config.max_file_size_mb * 1024 * 1024,
            max_archive_files: config.max_archive_files,
            compress_archives: config.compress_archives,
        }
    }
}

impl Default for LogRotationConfig {
    fn default() -> Self {
        Self {
            max_file_size_bytes: 100 * 1024 * 1024,
            max_archive_files: 9,
            compress_archives: true,
        }
    }
}

pub struct ServerLogger {
    log_file_path: PathBuf,
    config: LogRotationConfig,
    log_requests: bool,
    log_security: bool,
    log_performance: bool,
}

impl ServerLogger {
    pub fn new_with_config(
        server_name: &str,
        port: u16,
        logging_config: &LoggingConfig,
    ) -> Result<Self> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let log_file_path = base_dir
            .join(".rss")
            .join("servers")
            .join(format!("{}-[{}].log", server_name, port));

        if let Some(parent) = log_file_path.parent() {
            std::fs::create_dir_all(parent).map_err(AppError::Io)?;
        }

        Ok(Self {
            log_file_path,
            config: LogRotationConfig::from(logging_config),
            log_requests: logging_config.log_requests,
            log_security: logging_config.log_security_alerts,
            log_performance: logging_config.log_performance,
        })
    }

    pub fn new(server_name: &str, port: u16) -> Result<Self> {
        Self::new_with_config(server_name, port, &LoggingConfig::default())
    }

    // Vereinfachte System-Log Methoden
    pub async fn log_server_start(&self) -> Result<()> {
        self.write_system_entry(LogEventType::ServerStart).await
    }

    pub async fn log_server_stop(&self) -> Result<()> {
        self.write_system_entry(LogEventType::ServerStop).await
    }

    async fn write_system_entry(&self, event_type: LogEventType) -> Result<()> {
        let entry = ServerLogEntry {
            timestamp: chrono::Local::now()
                .format("%Y-%m-%d %H:%M:%S%.3f")
                .to_string(),
            timestamp_unix: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            event_type,
            ip_address: "127.0.0.1".to_string(),
            user_agent: None,
            method: "SYSTEM".to_string(),
            path: "/".to_string(),
            status_code: None,
            response_time_ms: None,
            bytes_sent: None,
            referer: None,
            query_string: None,
            headers: HashMap::new(),
            session_id: None,
        };
        self.write_log_entry(entry).await
    }

    // Optimierte Request Logging
    pub async fn log_request(
        &self,
        req: &actix_web::HttpRequest,
        status: u16,
        response_time: u64,
        bytes_sent: u64,
    ) -> Result<()> {
        if !self.log_requests {
            return Ok(());
        }

        let ip = {
            let connection_info = req.connection_info();
            connection_info
                .realip_remote_addr()
                .or_else(|| connection_info.peer_addr())
                .unwrap_or("unknown")
                .split(':')
                .next()
                .unwrap_or("unknown")
                .to_string()
        };

        // Nur relevante Headers filtern
        let headers = req
            .headers()
            .iter()
            .filter_map(|(name, value)| {
                let header_name = name.as_str().to_lowercase();
                match header_name.as_str() {
                    "authorization" | "cookie" | "x-api-key" => {
                        Some((name.as_str().to_string(), "[FILTERED]".to_string()))
                    }
                    _ => value
                        .to_str()
                        .ok()
                        .map(|v| (name.as_str().to_string(), v.to_string())),
                }
            })
            .collect();

        let entry = ServerLogEntry {
            timestamp: chrono::Local::now()
                .format("%Y-%m-%d %H:%M:%S%.3f")
                .to_string(),
            timestamp_unix: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            event_type: LogEventType::Request,
            ip_address: ip.to_string(),
            user_agent: req
                .headers()
                .get("user-agent")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
            method: req.method().to_string(),
            path: req.path().to_string(),
            status_code: Some(status),
            response_time_ms: Some(response_time),
            bytes_sent: Some(bytes_sent),
            referer: req
                .headers()
                .get("referer")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
            query_string: if req.query_string().is_empty() {
                None
            } else {
                Some(req.query_string().to_string())
            },
            headers,
            session_id: req.extensions().get::<String>().cloned(), // Jetzt funktioniert es mit HttpMessage import
        };

        self.write_log_entry(entry).await
    }

    // Vereinfachte Alert-Logging
    pub async fn log_security_alert(&self, ip: &str, reason: &str, details: &str) -> Result<()> {
        if !self.log_security {
            return Ok(());
        }
        self.write_alert_entry(LogEventType::SecurityAlert, ip, reason, details, None)
            .await
    }

    pub async fn log_performance_warning(
        &self,
        metric: &str,
        value: u64,
        threshold: u64,
    ) -> Result<()> {
        if !self.log_performance {
            return Ok(());
        }
        self.write_alert_entry(
            LogEventType::PerformanceWarning,
            "127.0.0.1",
            metric,
            &format!("value={}, threshold={}", value, threshold),
            Some(value),
        )
        .await
    }

    // KORRIGIERTE write_alert_entry Method
    async fn write_alert_entry(
        &self,
        event_type: LogEventType,
        ip: &str,
        reason: &str,
        details: &str,
        response_time: Option<u64>,
    ) -> Result<()> {
        let mut headers = HashMap::new();
        headers.insert("alert_reason".to_string(), reason.to_string());
        headers.insert("alert_details".to_string(), details.to_string());

        let method_name = match event_type {
            LogEventType::SecurityAlert => "SECURITY",
            LogEventType::PerformanceWarning => "PERFORMANCE",
            _ => "SYSTEM",
        };

        let entry = ServerLogEntry {
            timestamp: chrono::Local::now()
                .format("%Y-%m-%d %H:%M:%S%.3f")
                .to_string(),
            timestamp_unix: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            event_type, // Jetzt Copy-able, kein Move-Problem mehr
            ip_address: ip.to_string(),
            user_agent: None,
            method: method_name.to_string(),
            path: "/".to_string(),
            status_code: None,
            response_time_ms: response_time,
            bytes_sent: None,
            referer: None,
            query_string: None,
            headers,
            session_id: None,
        };

        self.write_log_entry(entry).await
    }

    pub async fn write_log_entry(&self, entry: ServerLogEntry) -> Result<()> {
        self.check_and_rotate_if_needed().await?;

        let json_line = serde_json::to_string(&entry)
            .map_err(|e| AppError::Validation(format!("Failed to serialize log entry: {}", e)))?;

        let mut file = tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file_path)
            .await
            .map_err(AppError::Io)?;

        use tokio::io::AsyncWriteExt;
        file.write_all(format!("{}\n", json_line).as_bytes())
            .await
            .map_err(AppError::Io)?;
        file.flush().await.map_err(AppError::Io)?;
        Ok(())
    }

    async fn check_and_rotate_if_needed(&self) -> Result<()> {
        if !self.log_file_path.exists() {
            return Ok(());
        }

        let metadata = tokio::fs::metadata(&self.log_file_path)
            .await
            .map_err(AppError::Io)?;
        if metadata.len() >= self.config.max_file_size_bytes {
            self.rotate_log_files().await?;
        }
        Ok(())
    }

    async fn rotate_log_files(&self) -> Result<()> {
        let base_path = &self.log_file_path;
        let base_name = base_path.file_stem().unwrap().to_string_lossy();
        let parent_dir = base_path.parent().unwrap();

        // Rotate existing archives
        for i in (1..self.config.max_archive_files).rev() {
            let old_path = parent_dir.join(format!("{}.{}.log.gz", base_name, i));
            let new_path = parent_dir.join(format!("{}.{}.log.gz", base_name, i + 1));

            if old_path.exists() {
                tokio::fs::rename(&old_path, &new_path)
                    .await
                    .map_err(AppError::Io)?;
            }
        }

        // Move current log to archive
        let archive_path = parent_dir.join(format!("{}.1.log", base_name));
        tokio::fs::rename(base_path, &archive_path)
            .await
            .map_err(AppError::Io)?;

        if self.config.compress_archives {
            self.compress_log_file(&archive_path).await?;
        }

        // Cleanup old files
        let cleanup_path = parent_dir.join(format!(
            "{}.{}.log.gz",
            base_name,
            self.config.max_archive_files + 1
        ));
        if cleanup_path.exists() {
            tokio::fs::remove_file(&cleanup_path)
                .await
                .map_err(AppError::Io)?;
        }

        Ok(())
    }

    async fn compress_log_file(&self, file_path: &std::path::Path) -> Result<()> {
        use flate2::write::GzEncoder;
        use flate2::Compression;
        use std::io::Write;

        let content = tokio::fs::read(file_path).await.map_err(AppError::Io)?;
        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(&content).map_err(AppError::Io)?;
        let compressed = encoder.finish().map_err(AppError::Io)?;

        let gz_path = file_path.with_file_name(format!(
            "{}.gz",
            file_path
                .file_name()
                .ok_or_else(|| AppError::Validation("Invalid file path".to_string()))?
                .to_string_lossy()
        ));

        tokio::fs::write(&gz_path, compressed)
            .await
            .map_err(AppError::Io)?;
        tokio::fs::remove_file(file_path)
            .await
            .map_err(AppError::Io)?;

        Ok(())
    }

    pub fn get_log_file_size_bytes(&self) -> Result<u64> {
        if !self.log_file_path.exists() {
            return Ok(0);
        }
        let metadata = std::fs::metadata(&self.log_file_path).map_err(AppError::Io)?;
        Ok(metadata.len())
    }

    pub fn list_log_files(&self) -> Result<Vec<PathBuf>> {
        let parent_dir = self.log_file_path.parent().unwrap();
        let base_name = self.log_file_path.file_stem().unwrap().to_string_lossy();
        let mut files = Vec::new();

        if self.log_file_path.exists() {
            files.push(self.log_file_path.clone());
        }

        for i in 1..=10 {
            for ext in &["log", "log.gz"] {
                let path = parent_dir.join(format!("{}.{}.{}", base_name, i, ext));
                if path.exists() {
                    files.push(path);
                    break; // Only add one version (prefer compressed)
                }
            }
        }

        Ok(files)
    }

    // Optimierte Stats-Berechnung
    pub async fn get_request_stats(&self) -> Result<ServerStats> {
        use tokio::io::{AsyncBufReadExt, BufReader};

        if !self.log_file_path.exists() {
            return Ok(ServerStats::default());
        }

        let file = tokio::fs::File::open(&self.log_file_path)
            .await
            .map_err(AppError::Io)?;
        let mut reader = BufReader::new(file).lines();

        let mut stats = ServerStats::default();
        let mut unique_ips = std::collections::HashSet::new();
        let mut response_times = Vec::new();

        while let Some(line) = reader.next_line().await.map_err(AppError::Io)? {
            if let Ok(entry) = serde_json::from_str::<ServerLogEntry>(&line) {
                match entry.event_type {
                    LogEventType::Request => {
                        stats.total_requests += 1;
                        unique_ips.insert(entry.ip_address);

                        if let Some(status) = entry.status_code {
                            if status >= 400 {
                                stats.error_requests += 1;
                            }
                        }
                        if let Some(rt) = entry.response_time_ms {
                            response_times.push(rt);
                        }
                        if let Some(bytes) = entry.bytes_sent {
                            stats.total_bytes_sent += bytes;
                        }
                    }
                    LogEventType::SecurityAlert => stats.security_alerts += 1,
                    LogEventType::PerformanceWarning => stats.performance_warnings += 1,
                    _ => {}
                }
            }
        }

        stats.unique_ips = unique_ips.len() as u64;
        if !response_times.is_empty() {
            stats.avg_response_time =
                response_times.iter().sum::<u64>() / response_times.len() as u64;
            stats.max_response_time = *response_times.iter().max().unwrap_or(&0);
        }

        Ok(stats)
    }

    pub fn get_config_summary(&self) -> String {
        format!(
            "Log Config: {}MB max, {} archives, compression: {}, requests: {}, security: {}, performance: {}",
            self.config.max_file_size_bytes / 1024 / 1024,
            self.config.max_archive_files,
            self.config.compress_archives,
            self.log_requests,
            self.log_security,
            self.log_performance
        )
    }
}

#[derive(Debug, Default)]
pub struct ServerStats {
    pub total_requests: u64,
    pub unique_ips: u64,
    pub error_requests: u64,
    pub security_alerts: u64,
    pub performance_warnings: u64,
    pub total_bytes_sent: u64,
    pub avg_response_time: u64,
    pub max_response_time: u64,
}

// ## END ##

// ## FILE: src/server/utils/port.rs
// ## BEGIN ##
use crate::core::config::Config;
use crate::core::prelude::*;

pub enum PortStatus {
    Available,
    OccupiedByUs,
    OccupiedByOther,
}

pub fn check_port_status(port: u16) -> PortStatus {
    use std::net::{IpAddr, Ipv4Addr, SocketAddr, TcpListener};

    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);

    // frei?
    if let Ok(listener) = TcpListener::bind(addr) {
        drop(listener);
        return PortStatus::Available;
    }

    // belegt ‚Äì pr√ºfen ob von uns
    let ctx = crate::server::shared::get_shared_context();
    if let Ok(servers) = ctx.servers.read() {
        if servers.values().any(|s| s.port == port) {
            return PortStatus::OccupiedByUs;
        }
    }

    PortStatus::OccupiedByOther
}

pub fn is_port_available(port: u16) -> bool {
    std::net::TcpListener::bind(("127.0.0.1", port))
        .map(|l| {
            drop(l);
            true
        })
        .unwrap_or(false)
}

pub fn find_next_available_port(config: &Config) -> Result<u16> {
    let ctx = crate::server::shared::get_shared_context();
    let servers = ctx.servers.read().unwrap();
    let mut used_ports: Vec<u16> = servers.values().map(|s| s.port).collect();
    used_ports.sort();

    let mut candidate_port = config.server.port_range_start;
    let max_port = config.server.port_range_end;

    loop {
        if candidate_port > max_port {
            return Err(AppError::Validation(format!(
                "No available ports in range {}-{}",
                config.server.port_range_start, config.server.port_range_end
            )));
        }

        if !used_ports.contains(&candidate_port) && is_port_available(candidate_port) {
            return Ok(candidate_port);
        }

        candidate_port += 1;
    }
}

pub fn find_next_available_port_legacy() -> Result<u16> {
    let ctx = crate::server::shared::get_shared_context();
    let servers = ctx.servers.read().unwrap();
    let mut used_ports: Vec<u16> = servers.values().map(|s| s.port).collect();
    used_ports.sort();

    let mut candidate_port = 8080;

    loop {
        if !used_ports.contains(&candidate_port) && is_port_available(candidate_port) {
            return Ok(candidate_port);
        }

        candidate_port += 1;
        if candidate_port > 8180 {
            return Err(AppError::Validation(
                "No available ports found in default range 8080-8180".to_string(),
            ));
        }
    }
}

// ## END ##

// ## FILE: src/server/utils/mod.rs
// ## BEGIN ##
pub mod port;
pub mod validation;

pub use port::*;
pub use validation::*;

// ## END ##

// ## FILE: src/server/utils/validation.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::server::types::ServerInfo;
use std::collections::HashMap;

pub fn find_server<'a>(
    servers: &'a HashMap<String, ServerInfo>,
    identifier: &str,
) -> Result<&'a ServerInfo> {
    if let Ok(index) = identifier.parse::<usize>() {
        if index > 0 && index <= servers.len() {
            let mut server_list: Vec<_> = servers.values().collect();
            server_list.sort_by(|a, b| a.created_at.cmp(&b.created_at));
            return server_list
                .get(index - 1)
                .copied()
                .ok_or_else(|| AppError::Validation("Server index out of range".to_string()));
        }
    }

    for server in servers.values() {
        if server.name == identifier || server.id.starts_with(identifier) {
            return Ok(server);
        }
    }

    Err(AppError::Validation(format!(
        "Server '{}' nicht gefunden",
        identifier
    )))
}

pub fn validate_server_name(name: &str) -> Result<()> {
    if name.is_empty() {
        return Err(AppError::Validation(
            "Server name cannot be empty".to_string(),
        ));
    }
    if name.len() > 50 {
        return Err(AppError::Validation("Server name too long".to_string()));
    }
    if !name
        .chars()
        .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
    {
        return Err(AppError::Validation(
            "Server name can only contain alphanumeric characters, hyphens and underscores"
                .to_string(),
        ));
    }
    Ok(())
}

pub fn validate_port(port: u16) -> Result<()> {
    if port < 1024 {
        return Err(AppError::Validation("Port must be >= 1024".to_string()));
    }
    Ok(())
}

// ## END ##

// ## FILE: src/server/manager.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerInfo};

#[derive(Debug, Default)]
pub struct ServerManager {
    ctx: ServerContext,
}

impl ServerManager {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn get_server_info(&self, identifier: &str) -> Result<ServerInfo> {
        let servers = self.ctx.servers.read().unwrap();
        let server = crate::server::utils::validation::find_server(&servers, identifier)?;
        Ok(server.clone())
    }

    pub fn get_context(&self) -> &ServerContext {
        &self.ctx
    }
}

// ## END ##

// ## FILE: src/server/mod.rs
// ## BEGIN ##
pub mod config;
pub mod handlers;
pub mod logging;
pub mod manager;
pub mod middleware;
pub mod persistence;
pub mod redirect;
pub mod shared;
pub mod tls;
pub mod types;
pub mod utils;
pub mod watchdog;

pub use logging::ServerLogger;
pub use manager::ServerManager;
pub use middleware::LoggingMiddleware;
pub use persistence::{CleanupType, PersistentServerInfo, ServerRegistry};
pub use redirect::HttpRedirectServer;
pub use types::{ServerInfo, ServerStatus};

// ## END ##

// ## FILE: src/server/middleware.rs
// ## BEGIN ##
use actix_web::{
    dev::{Service, ServiceRequest, ServiceResponse, Transform},
    Error,
};
use futures_util::future::LocalBoxFuture;
use std::{
    future::{ready, Ready},
    sync::Arc,
    time::Instant,
};

pub struct LoggingMiddleware {
    server_logger: Arc<crate::server::logging::ServerLogger>,
}

impl LoggingMiddleware {
    pub fn new(server_logger: Arc<crate::server::logging::ServerLogger>) -> Self {
        Self { server_logger }
    }
}

impl<S, B> Transform<S, ServiceRequest> for LoggingMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type InitError = ();
    type Transform = LoggingMiddlewareService<S>;
    type Future = Ready<std::result::Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ready(Ok(LoggingMiddlewareService {
            service,
            server_logger: self.server_logger.clone(),
        }))
    }
}

pub struct LoggingMiddlewareService<S> {
    service: S,
    server_logger: Arc<crate::server::logging::ServerLogger>,
}

impl<S, B> Service<ServiceRequest> for LoggingMiddlewareService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Future = LocalBoxFuture<'static, std::result::Result<Self::Response, Self::Error>>;

    actix_web::dev::forward_ready!(service);

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let start_time = Instant::now();
        let server_logger = self.server_logger.clone();

        let ip = {
            let connection_info = req.connection_info();
            connection_info
                .realip_remote_addr()
                .or_else(|| connection_info.peer_addr())
                .unwrap_or("unknown")
                .split(':')
                .next()
                .unwrap_or("unknown")
                .to_string()
        };

        let path = req.path().to_string();
        let method = req.method().to_string();
        let query_string = req.query_string().to_string();

        let suspicious = path.contains("..")
            || path.contains("<script")
            || path.contains("sql")
            || path.len() > 1000;

        if suspicious {
            let logger_clone = server_logger.clone();
            let ip_clone = ip.clone();
            let path_clone = path.clone();
            tokio::spawn(async move {
                let _ = logger_clone
                    .log_security_alert(
                        &ip_clone,
                        "Suspicious Request",
                        &format!("Suspicious path: {}", path_clone),
                    )
                    .await;
            });
        }

        let headers: std::collections::HashMap<String, String> = req
            .headers()
            .iter()
            .filter_map(|(name, value)| {
                let header_name = name.as_str().to_lowercase();
                if !["authorization", "cookie", "x-api-key"].contains(&header_name.as_str()) {
                    value
                        .to_str()
                        .ok()
                        .map(|v| (name.as_str().to_string(), v.to_string()))
                } else {
                    Some((name.as_str().to_string(), "[FILTERED]".to_string()))
                }
            })
            .collect();

        let fut = self.service.call(req);

        Box::pin(async move {
            let res = fut.await?;
            let response_time = start_time.elapsed().as_millis() as u64;
            let status = res.status().as_u16();
            let bytes_sent = res
                .response()
                .headers()
                .get("content-length")
                .and_then(|h| h.to_str().ok())
                .and_then(|s| s.parse().ok())
                .unwrap_or(0);

            let entry = crate::server::logging::ServerLogEntry {
                timestamp: chrono::Local::now()
                    .format("%Y-%m-%d %H:%M:%S%.3f")
                    .to_string(),
                timestamp_unix: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs(),
                event_type: crate::server::logging::LogEventType::Request,
                ip_address: ip,
                user_agent: headers.get("user-agent").cloned(),
                method,
                path,
                status_code: Some(status),
                response_time_ms: Some(response_time),
                bytes_sent: Some(bytes_sent),
                referer: headers.get("referer").cloned(),
                query_string: if query_string.is_empty() {
                    None
                } else {
                    Some(query_string)
                },
                headers,
                session_id: None,
            };

            if let Err(e) = server_logger.write_log_entry(entry).await {
                log::error!("Failed to log request: {}", e);
            }

            Ok(res)
        })
    }
}

// ## END ##

// ## FILE: src/server/tls.rs
// ## BEGIN ##
use crate::core::prelude::*;
use rcgen::{Certificate, CertificateParams, DistinguishedName};
use rustls::{Certificate as RustlsCertificate, PrivateKey, ServerConfig};
use rustls_pemfile::{certs, pkcs8_private_keys};
use std::fs;
use std::io::BufReader;
use std::path::{Path, PathBuf};
use std::sync::Arc;

#[derive(Debug)]
pub struct TlsManager {
    cert_dir: PathBuf,
    validity_days: u32,
}

impl TlsManager {
    pub fn new(cert_dir: &str, validity_days: u32) -> Result<Self> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let cert_path = base_dir.join(cert_dir);
        fs::create_dir_all(&cert_path).map_err(AppError::Io)?;

        Ok(Self {
            cert_dir: cert_path,
            validity_days,
        })
    }

    pub fn get_rustls_config(&self, server_name: &str, port: u16) -> Result<Arc<ServerConfig>> {
        let cert_file = self.get_cert_path(server_name, port);
        let key_file = self.get_key_path(server_name, port);

        // Zertifikat erstellen falls nicht vorhanden
        if !cert_file.exists() || !key_file.exists() {
            self.generate_certificate(server_name, port)?;
        }

        // Zertifikat und Key laden
        let cert_chain = self.load_certificates(&cert_file)?;
        let private_key = self.load_private_key(&key_file)?;

        // Rustls Konfiguration erstellen
        let config = ServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(cert_chain, private_key)
            .map_err(|e| AppError::Validation(format!("TLS config error: {}", e)))?;

        Ok(Arc::new(config))
    }

    fn generate_certificate(&self, server_name: &str, port: u16) -> Result<()> {
        log::info!("Generating TLS certificate for {}:{}", server_name, port);

        // Subject Alternative Names - Wildcard f√ºr Proxy, spezifisch f√ºr Server
        let subject_alt_names = if server_name == "proxy" {
            vec![
                "localhost".to_string(),
                "127.0.0.1".to_string(),
                "*.localhost".to_string(), // Wildcard f√ºr alle Subdomains
                "proxy.localhost".to_string(),
            ]
        } else {
            vec![
                "localhost".to_string(),
                "127.0.0.1".to_string(),
                format!("{}.localhost", server_name), // spezifische Subdomain
                format!("{}:{}", server_name, port),
            ]
        };

        let mut params = CertificateParams::new(subject_alt_names);

        // Distinguished Name - Korrekte Common Names
        let mut dn = DistinguishedName::new();
        dn.push(rcgen::DnType::OrganizationName, "Rush Sync Server");

        let common_name = if server_name == "proxy" {
            "*.localhost" // Wildcard CN f√ºr Proxy
        } else {
            &format!("{}.localhost", server_name)
        };

        dn.push(rcgen::DnType::CommonName, common_name);
        params.distinguished_name = dn;

        // Rest der Funktion bleibt gleich...
        params.not_before = time::OffsetDateTime::now_utc() - time::Duration::days(1);
        params.not_after =
            time::OffsetDateTime::now_utc() + time::Duration::days(self.validity_days as i64);

        params.key_usages = vec![
            rcgen::KeyUsagePurpose::DigitalSignature,
            rcgen::KeyUsagePurpose::KeyEncipherment,
        ];

        params.extended_key_usages = vec![rcgen::ExtendedKeyUsagePurpose::ServerAuth];

        // Zertifikat generieren
        let cert = Certificate::from_params(params)
            .map_err(|e| AppError::Validation(format!("Certificate generation failed: {}", e)))?;

        let cert_pem = cert.serialize_pem().map_err(|e| {
            AppError::Validation(format!("Certificate serialization failed: {}", e))
        })?;
        let key_pem = cert.serialize_private_key_pem();

        let cert_file = self.get_cert_path(server_name, port);
        let key_file = self.get_key_path(server_name, port);

        fs::write(&cert_file, cert_pem).map_err(AppError::Io)?;
        fs::write(&key_file, key_pem).map_err(AppError::Io)?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&key_file).map_err(AppError::Io)?.permissions();
            perms.set_mode(0o600);
            fs::set_permissions(&key_file, perms).map_err(AppError::Io)?;
        }

        log::info!("TLS certificate generated with CN: {}", common_name);
        log::info!("Certificate: {:?}", cert_file);
        log::info!("Private Key: {:?}", key_file);

        Ok(())
    }

    fn load_certificates(&self, path: &Path) -> Result<Vec<RustlsCertificate>> {
        let cert_file = fs::File::open(path).map_err(AppError::Io)?;
        let mut reader = BufReader::new(cert_file);

        let cert_chain = certs(&mut reader)
            .map_err(|e| AppError::Validation(format!("Certificate parsing error: {}", e)))?
            .into_iter()
            .map(RustlsCertificate)
            .collect();

        Ok(cert_chain)
    }

    fn load_private_key(&self, path: &Path) -> Result<PrivateKey> {
        let key_file = fs::File::open(path).map_err(AppError::Io)?;
        let mut reader = BufReader::new(key_file);

        let keys = pkcs8_private_keys(&mut reader)
            .map_err(|e| AppError::Validation(format!("Private key parsing error: {}", e)))?;

        if keys.is_empty() {
            return Err(AppError::Validation("No private key found".to_string()));
        }

        Ok(PrivateKey(keys[0].clone()))
    }

    fn get_cert_path(&self, server_name: &str, port: u16) -> PathBuf {
        self.cert_dir.join(format!("{}-{}.cert", server_name, port))
    }

    fn get_key_path(&self, server_name: &str, port: u16) -> PathBuf {
        self.cert_dir.join(format!("{}-{}.key", server_name, port))
    }

    pub fn certificate_exists(&self, server_name: &str, port: u16) -> bool {
        let cert_file = self.get_cert_path(server_name, port);
        let key_file = self.get_key_path(server_name, port);
        cert_file.exists() && key_file.exists()
    }

    pub fn remove_certificate(&self, server_name: &str, port: u16) -> Result<()> {
        let cert_file = self.get_cert_path(server_name, port);
        let key_file = self.get_key_path(server_name, port);

        if cert_file.exists() {
            fs::remove_file(&cert_file).map_err(AppError::Io)?;
            log::info!("Removed certificate: {:?}", cert_file);
        }

        if key_file.exists() {
            fs::remove_file(&key_file).map_err(AppError::Io)?;
            log::info!("Removed private key: {:?}", key_file);
        }

        Ok(())
    }

    pub fn get_certificate_info(&self, server_name: &str, port: u16) -> Option<CertificateInfo> {
        let cert_file = self.get_cert_path(server_name, port);

        if !cert_file.exists() {
            return None;
        }

        let metadata = fs::metadata(&cert_file).ok()?;
        let size = metadata.len();
        let modified = metadata.modified().ok()?;

        Some(CertificateInfo {
            cert_path: cert_file,
            key_path: self.get_key_path(server_name, port),
            file_size: size,
            created: modified,
            valid_days: self.validity_days,
        })
    }

    pub fn list_certificates(&self) -> Result<Vec<CertificateInfo>> {
        let mut certificates = Vec::new();

        let entries = fs::read_dir(&self.cert_dir).map_err(AppError::Io)?;

        for entry in entries {
            let entry = entry.map_err(AppError::Io)?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("cert") {
                if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                    // Parse server-port aus Dateiname
                    if let Some((server, port_str)) = stem.rsplit_once('-') {
                        if let Ok(port) = port_str.parse::<u16>() {
                            if let Some(info) = self.get_certificate_info(server, port) {
                                certificates.push(info);
                            }
                        }
                    }
                }
            }
        }

        certificates.sort_by(|a, b| b.created.cmp(&a.created));
        Ok(certificates)
    }

    pub fn get_production_config(&self, domain: &str) -> Result<Arc<ServerConfig>> {
        // Pr√ºfen ob bereits Let's Encrypt Zertifikat existiert
        let cert_file = self.cert_dir.join(format!("{}.fullchain.pem", domain));
        let key_file = self.cert_dir.join(format!("{}.privkey.pem", domain));

        if cert_file.exists() && key_file.exists() {
            log::info!("Loading existing Let's Encrypt certificate for {}", domain);
            let cert_chain = self.load_certificates(&cert_file)?;
            let private_key = self.load_private_key(&key_file)?;

            let config = ServerConfig::builder()
                .with_safe_defaults()
                .with_no_client_auth()
                .with_single_cert(cert_chain, private_key)
                .map_err(|e| AppError::Validation(format!("TLS config error: {}", e)))?;

            return Ok(Arc::new(config));
        }

        log::warn!("No Let's Encrypt certificate found for {}", domain);
        log::info!("Using self-signed certificate for development");

        // Fallback zu self-signed
        self.get_rustls_config("proxy", 443)
    }
}

#[derive(Debug)]
pub struct CertificateInfo {
    pub cert_path: PathBuf,
    pub key_path: PathBuf,
    pub file_size: u64,
    pub created: std::time::SystemTime,
    pub valid_days: u32,
}

impl CertificateInfo {
    pub fn is_expired(&self) -> bool {
        if let Ok(elapsed) = self.created.elapsed() {
            elapsed.as_secs() > (self.valid_days as u64 * 24 * 60 * 60)
        } else {
            true
        }
    }

    pub fn days_until_expiry(&self) -> i64 {
        if let Ok(elapsed) = self.created.elapsed() {
            let elapsed_days = elapsed.as_secs() / (24 * 60 * 60);
            (self.valid_days as i64) - (elapsed_days as i64)
        } else {
            0
        }
    }
}

// ## END ##

// ## FILE: src/server/handlers/web/server.rs
// ## BEGIN ##
use super::ServerDataWithConfig;
use actix_web::{web, HttpRequest, HttpResponse, Result as ActixResult};

pub async fn serve_fallback_or_inject(
    req: HttpRequest,
    data: web::Data<ServerDataWithConfig>,
) -> ActixResult<HttpResponse> {
    let path = req.path();
    log::info!("Requested path: {}", path);

    let exe_path = std::env::current_exe().unwrap();
    let base_dir = exe_path.parent().unwrap();
    let server_dir = base_dir
        .join("www")
        .join(format!("{}-[{}]", data.server.name, data.server.port));

    let file_path = if path == "/" {
        server_dir.join("index.html")
    } else {
        server_dir.join(path.trim_start_matches('/'))
    };

    log::info!("Looking for file: {:?}", file_path);

    if file_path.exists() {
        if let Some(extension) = file_path.extension() {
            if extension == "html" {
                log::info!("Loading custom HTML file");
                match tokio::fs::read_to_string(&file_path).await {
                    Ok(mut html_content) => {
                        if !html_content.contains("/rss.js") {
                            html_content = inject_rss_script(html_content);
                        }

                        return Ok(HttpResponse::Ok()
                            .content_type("text/html; charset=utf-8")
                            .body(html_content));
                    }
                    Err(e) => {
                        log::error!("Failed to read HTML file: {}", e);
                    }
                }
            } else {
                log::info!("Serving static file: {:?}", file_path);
                match tokio::fs::read(&file_path).await {
                    Ok(content) => {
                        let content_type = match extension.to_str() {
                            Some("css") => "text/css",
                            Some("js") => "application/javascript",
                            Some("png") => "image/png",
                            Some("jpg") | Some("jpeg") => "image/jpeg",
                            Some("svg") => "image/svg+xml",
                            _ => "application/octet-stream",
                        };

                        return Ok(HttpResponse::Ok().content_type(content_type).body(content));
                    }
                    Err(e) => {
                        log::error!("Failed to read file: {}", e);
                    }
                }
            }
        }
    }

    if path == "/" {
        log::info!("Serving system fallback");
        serve_system_fallback(data).await
    } else {
        log::info!("File not found: {}", path);
        Ok(HttpResponse::NotFound()
            .content_type("text/plain")
            .body("File not found"))
    }
}

async fn serve_system_fallback(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let template = include_str!("../templates/rss/dashboard.html");

    let html_content = template
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string()) // KORRIGIERT: HTTP Port
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string()) // KORRIGIERT: HTTPS Port
        .replace("{{VERSION}}", crate::server::config::get_server_version())
        .replace("{{CREATION_TIME}}", &chrono::Local::now().to_rfc3339());

    let html_with_script = inject_rss_script(html_content);

    Ok(HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html_with_script))
}

pub fn inject_rss_script(html: String) -> String {
    // ES6 Module statt normales Script
    let script_tag = r#"<script type="module" src="/rss.js"></script>"#;
    let css_link = r#"<link rel="stylesheet" href="/.rss/_reset.css">"#;

    // ERST: CSS in <head> einf√ºgen
    let html_with_css = if let Some(head_end) = html.find("</head>") {
        let (before, after) = html.split_at(head_end);
        format!("{}\n    {}\n{}", before, css_link, after)
    } else {
        format!("{}\n{}", css_link, html)
    };

    // DANN: JavaScript Module ganz am Ende einf√ºgen
    if let Some(body_end) = html_with_css.rfind("</body>") {
        let (before, after) = html_with_css.split_at(body_end);
        format!("{}\n    {}\n{}", before, script_tag, after)
    } else if let Some(html_end) = html_with_css.rfind("</html>") {
        let (before, after) = html_with_css.split_at(html_end);
        format!("{}\n{}\n{}", before, script_tag, after)
    } else {
        format!("{}\n{}", html_with_css, script_tag)
    }
}

// ## END ##

// ## FILE: src/server/handlers/web/mod.rs
// ## BEGIN ##
// src/server/handlers/web/mod.rs
pub mod api;
pub mod assets;
pub mod logs;
pub mod server;
pub mod templates;

pub use api::*;
pub use assets::*;
pub use logs::*;
pub use server::*;
pub use templates::*;

use crate::core::config::Config;
use crate::server::logging::ServerLogger;
use crate::server::middleware::LoggingMiddleware;
use crate::server::tls::TlsManager;
use crate::server::types::{ServerContext, ServerData, ServerInfo};
use crate::server::watchdog::{get_watchdog_manager, ws_hot_reload};
use actix_cors::Cors;
use actix_web::{middleware, web, App, HttpServer};
use std::path::PathBuf;
use std::sync::Arc;
use std::sync::OnceLock;
use std::time::Duration;

static GLOBAL_CONFIG: OnceLock<Config> = OnceLock::new();

// Funktion um Config zu setzen
pub fn set_global_config(config: Config) {
    let _ = GLOBAL_CONFIG.set(config);
}

// KORRIGIERTE Port-Funktionen mit TOML-Config
pub fn get_proxy_http_port() -> u16 {
    // HTTP Proxy l√§uft auf dem konfigurierten Proxy-Port (3000)
    GLOBAL_CONFIG.get().map(|c| c.proxy.port).unwrap_or(3000)
}

pub fn get_proxy_https_port() -> u16 {
    // HTTPS Proxy l√§uft auf HTTP-Port + https_port_offset
    GLOBAL_CONFIG
        .get()
        .map(|c| c.proxy.port + c.proxy.https_port_offset)
        .unwrap_or(3443)
}

// Alternative: Falls Config erweitert wird
pub fn get_proxy_https_port_from_config() -> u16 {
    GLOBAL_CONFIG
        .get()
        .map(|c| {
            // Wenn Config sp√§ter https_port_offset hat:
            // c.proxy.port + c.proxy.https_port_offset

            // Aktuell: Standardoffset
            c.proxy.port + 443
        })
        .unwrap_or(3443)
}

pub fn create_server_directory_and_files(
    server_name: &str,
    port: u16,
) -> crate::core::error::Result<PathBuf> {
    let exe_path = std::env::current_exe().map_err(crate::core::error::AppError::Io)?;
    let base_dir = exe_path.parent().ok_or_else(|| {
        crate::core::error::AppError::Validation(
            "Cannot determine executable directory".to_string(),
        )
    })?;

    let server_dir = base_dir
        .join("www")
        .join(format!("{}-[{}]", server_name, port));
    std::fs::create_dir_all(&server_dir).map_err(crate::core::error::AppError::Io)?;

    // Template-Pfade korrigiert f√ºr neue Struktur
    let readme_template = include_str!("../templates/README.md");
    let readme_content = readme_template
        .replace("{{SERVER_NAME}}", server_name)
        .replace("{{PORT}}", &port.to_string());
    std::fs::write(server_dir.join("README.md"), readme_content)
        .map_err(crate::core::error::AppError::Io)?;

    let robots_template = include_str!("../templates/robots.txt");
    let robots_content = robots_template.replace("{{PORT}}", &port.to_string());
    std::fs::write(server_dir.join("robots.txt"), robots_content)
        .map_err(crate::core::error::AppError::Io)?;

    log::info!("Created development directory: {:?}", server_dir);
    log::info!("Files created: README.md, robots.txt");
    Ok(server_dir)
}

pub fn create_web_server(
    ctx: &ServerContext,
    server_info: ServerInfo,
    config: &Config,
) -> std::result::Result<actix_web::dev::ServerHandle, String> {
    let server_id = server_info.id.clone();
    let server_name = server_info.name.clone();
    let server_port = server_info.port;
    let servers_clone = Arc::clone(&ctx.servers);

    let server_logger =
        match ServerLogger::new_with_config(&server_name, server_info.port, &config.logging) {
            Ok(logger) => Arc::new(logger),
            Err(e) => return Err(format!("Logger creation failed: {}", e)),
        };

    if let Err(e) = crate::server::watchdog::start_server_watching(&server_name, server_port) {
        log::warn!("Failed to start file watching for {}: {}", server_name, e);
    } else {
        log::info!(
            "File watching started for server {} on port {}",
            server_name,
            server_port
        );
    }

    let logger_for_start = server_logger.clone();
    tokio::spawn(async move {
        if let Err(e) = logger_for_start.log_server_start().await {
            log::error!("Failed to log server start: {}", e);
        }
    });

    // KORRIGIERTE ServerDataWithConfig mit richtigen Ports
    let server_data = web::Data::new(ServerDataWithConfig {
        server: ServerData {
            id: server_id.clone(),
            port: server_info.port,
            name: server_name.clone(),
        },
        proxy_http_port: get_proxy_http_port(),
        proxy_https_port: get_proxy_https_port(),
    });

    let server_logger_for_app = server_logger.clone();
    let watchdog_manager = get_watchdog_manager().clone();

    let tls_config = if config.server.enable_https && config.server.auto_cert {
        match TlsManager::new(&config.server.cert_dir, config.server.cert_validity_days) {
            Ok(tls_manager) => match tls_manager.get_rustls_config(&server_name, server_port) {
                Ok(rustls_config) => {
                    log::info!("TLS certificate loaded for {}:{}", server_name, server_port);
                    Some(rustls_config)
                }
                Err(e) => {
                    log::error!("TLS setup failed: {}", e);
                    None
                }
            },
            Err(e) => {
                log::error!("TLS manager creation failed: {}", e);
                None
            }
        }
    } else {
        None
    };

    let mut http_server = HttpServer::new(move || {
        App::new()
            .app_data(server_data.clone())
            .app_data(web::Data::new(watchdog_manager.clone()))
            .wrap(LoggingMiddleware::new(server_logger_for_app.clone()))
            .wrap(middleware::Compress::default())
            .wrap(LoggingMiddleware::new(server_logger_for_app.clone()))
            .wrap(Cors::permissive())
            // Assets
            .route("/.rss/_reset.css", web::get().to(serve_global_reset_css))
            .route("/.rss/style.css", web::get().to(serve_system_css))
            .route("/.rss/favicon.svg", web::get().to(serve_system_favicon))
            .route("/.rss/", web::get().to(serve_system_dashboard))
            // Font Assets
            .route("/.rss/fonts/{font}", web::get().to(serve_quicksand_font))
            // JavaScript Assets
            .route("/rss.js", web::get().to(serve_rss_js))
            .route("/.rss/js/rush-app.js", web::get().to(serve_rush_app_js))
            .route("/.rss/js/rush-api.js", web::get().to(serve_rush_api_js))
            .route("/.rss/js/rush-ui.js", web::get().to(serve_rush_ui_js))
            // API Routes - SPEZIFISCH VOR GENERISCH
            .route("/api/status", web::get().to(status_handler))
            .route("/api/health", web::get().to(health_handler))
            .route("/api/info", web::get().to(info_handler))
            .route("/api/metrics", web::get().to(metrics_handler))
            .route("/api/stats", web::get().to(stats_handler))
            .route("/api/ping", web::post().to(ping_handler))
            .route("/api/message", web::post().to(message_handler))
            .route("/api/messages", web::get().to(messages_handler))
            .route("/api/close-browser", web::get().to(close_browser_handler))
            .route("/api/logs", web::get().to(logs_handler))
            .route("/api/logs/raw", web::get().to(logs_raw_handler))
            // WebSocket Routes
            .route("/ws/hot-reload", web::get().to(ws_hot_reload))
            // ===== FALLBACK ZULETZT =====
            .default_service(web::route().to(serve_fallback_or_inject))
    })
    .workers(config.server.workers)
    .shutdown_timeout(config.server.shutdown_timeout)
    .disable_signals();

    http_server = http_server
        .bind(("127.0.0.1", server_info.port))
        .map_err(|e| format!("HTTP bind failed: {}", e))?;

    if tls_config.is_some() {
        let https_port = server_port + 443; // FIXME: config.server.https_port_offset existiert nicht
        log::info!("TLS certificate ready for HTTPS on port {}", https_port);
        log::info!(
            "Certificate: .rss/certs/{}-{}.cert",
            server_name,
            server_port
        );
    }

    let server_result = http_server.run();
    let server_handle = server_result.handle();

    let server_id_for_thread = server_id.clone();
    let logger_for_cleanup = server_logger.clone();
    let startup_delay = config.server.startup_delay_ms;
    let server_name_for_cleanup = server_name.clone();
    let server_port_for_cleanup = server_port;

    if config.proxy.enabled {
        let proxy_manager = crate::server::shared::get_proxy_manager();
        let proxy_server_name = server_name.clone();
        let proxy_server_id = server_id.clone();
        let proxy_server_port = server_port;
        let startup_delay_clone = startup_delay;

        tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(
                startup_delay_clone + 100,
            ))
            .await;

            if let Err(e) = proxy_manager
                .add_route(&proxy_server_name, &proxy_server_id, proxy_server_port)
                .await
            {
                log::error!(
                    "Failed to register server {} with proxy: {}",
                    proxy_server_name,
                    e
                );
            } else {
                log::info!(
                    "Server {} registered with proxy: {}.localhost -> 127.0.0.1:{}",
                    proxy_server_name,
                    proxy_server_name,
                    proxy_server_port
                );
            }
        });
    }

    std::thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async move {
            match server_result.await {
                Ok(_) => log::info!("Server {} ended normally", server_id_for_thread),
                Err(e) => {
                    log::error!("Server {} error: {}", server_id_for_thread, e);
                    if let Ok(mut servers) = servers_clone.write() {
                        if let Some(server) = servers.get_mut(&server_id_for_thread) {
                            server.status = crate::server::types::ServerStatus::Failed;
                        }
                    }
                }
            }

            if let Err(e) = crate::server::watchdog::stop_server_watching(
                &server_name_for_cleanup,
                server_port_for_cleanup,
            ) {
                log::warn!("Failed to stop file watching: {}", e);
            } else {
                log::info!(
                    "File watching stopped for server {}",
                    server_name_for_cleanup
                );
            }

            if let Err(e) = logger_for_cleanup.log_server_stop().await {
                log::error!("Failed to log server stop: {}", e);
            }

            if let Ok(mut servers) = servers_clone.write() {
                if let Some(server) = servers.get_mut(&server_id_for_thread) {
                    server.status = crate::server::types::ServerStatus::Stopped;
                }
            }
        });
    });

    std::thread::sleep(Duration::from_millis(startup_delay));
    Ok(server_handle)
}

#[derive(Debug, Clone)]
pub struct ServerDataWithConfig {
    pub server: ServerData,
    pub proxy_http_port: u16,
    pub proxy_https_port: u16,
}

// ## END ##

// ## FILE: src/server/handlers/web/assets.rs
// ## BEGIN ##
// src/server/handlers/web/assets.rs
use super::ServerDataWithConfig;
use actix_web::{web, HttpResponse, Result as ActixResult};

pub async fn serve_rss_js(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let js_content = include_str!("../templates/rss/rss.js")
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string())
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string());

    Ok(HttpResponse::Ok()
        .content_type("application/javascript; charset=utf-8")
        .insert_header(("Cache-Control", "no-cache"))
        .body(js_content))
}

// App Controller Module
pub async fn serve_rush_app_js(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let js_content = include_str!("../templates/rss/js/rush-app.js")
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string())
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string());
    Ok(HttpResponse::Ok()
        .content_type("application/javascript; charset=utf-8")
        .insert_header(("Cache-Control", "no-cache"))
        .body(js_content))
}

pub async fn serve_rush_api_js(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let js_content = include_str!("../templates/rss/js/rush-api.js")
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string())
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string());

    Ok(HttpResponse::Ok()
        .content_type("application/javascript; charset=utf-8")
        .insert_header(("Cache-Control", "no-cache"))
        .body(js_content))
}

pub async fn serve_rush_ui_js(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let js_content = include_str!("../templates/rss/js/rush-ui.js")
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string())
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string());

    Ok(HttpResponse::Ok()
        .content_type("application/javascript; charset=utf-8")
        .insert_header(("Cache-Control", "no-cache"))
        .insert_header(("X-Content-Type-Options", "nosniff"))
        .body(js_content))
}

pub async fn serve_system_css() -> ActixResult<HttpResponse> {
    let css_content = include_str!("../templates/rss/style.css");

    Ok(HttpResponse::Ok()
        .content_type("text/css; charset=utf-8")
        .insert_header(("Cache-Control", "no-cache"))
        .body(css_content))
}

pub async fn serve_system_favicon() -> ActixResult<HttpResponse> {
    let favicon_content = include_str!("../templates/rss/favicon.svg");

    Ok(HttpResponse::Ok()
        .content_type("image/svg+xml")
        .body(favicon_content))
}

pub async fn serve_quicksand_font(req: actix_web::HttpRequest) -> ActixResult<HttpResponse> {
    let path = req
        .match_info()
        .get("font")
        .unwrap_or("Kenyan_Coffee_Bd.otf");

    let valid_fonts = [
        "Kenyan_Coffee_Bd_It.otf",
        "Kenyan_Coffee_Bd.otf",
        "Kenyan_Coffee_Rg_It.otf",
        "Kenyan_Coffee_Rg.otf",
    ];

    if !valid_fonts.contains(&path) {
        return Ok(HttpResponse::NotFound().body("Font not found"));
    }

    let font_data: &[u8] = match path {
        "Kenyan_Coffee_Bd_It.otf" => {
            include_bytes!("../templates/rss/fonts/Kenyan_Coffee_Bd_It.otf").as_slice()
        }
        "Kenyan_Coffee_Bd.otf" => {
            include_bytes!("../templates/rss/fonts/Kenyan_Coffee_Bd.otf").as_slice()
        }
        "Kenyan_Coffee_Rg_It.otf" => {
            include_bytes!("../templates/rss/fonts/Kenyan_Coffee_Rg_It.otf").as_slice()
        }
        "Kenyan_Coffee_Rg.otf" => {
            include_bytes!("../templates/rss/fonts/Kenyan_Coffee_Rg.otf").as_slice()
        }
        _ => return Ok(HttpResponse::NotFound().body("Font not found")),
    };

    Ok(HttpResponse::Ok()
        .content_type("font/otf")
        .insert_header(("Cache-Control", "public, max-age=31536000, immutable"))
        .insert_header(("Access-Control-Allow-Origin", "*"))
        .body(font_data))
}

pub async fn serve_global_reset_css() -> ActixResult<HttpResponse> {
    let reset_css = include_str!("../templates/rss/_reset.css");

    Ok(HttpResponse::Ok()
        .content_type("text/css; charset=utf-8")
        .insert_header(("Cache-Control", "public, max-age=3600"))
        .body(reset_css))
}

// ## END ##

// ## FILE: src/server/handlers/web/templates.rs
// ## BEGIN ##
use super::ServerDataWithConfig;
use actix_web::{web, HttpResponse, Result as ActixResult};

pub async fn serve_system_dashboard(
    data: web::Data<ServerDataWithConfig>,
) -> ActixResult<HttpResponse> {
    let template = include_str!("../templates/rss/dashboard.html");

    // KORREKTE Template-Ersetzung:
    let html_content = template
        .replace("{{SERVER_NAME}}", &data.server.name)
        .replace("{{PORT}}", &data.server.port.to_string())
        .replace("{{PROXY_PORT}}", &data.proxy_http_port.to_string()) // HTTP = 3000
        .replace("{{PROXY_HTTPS_PORT}}", &data.proxy_https_port.to_string()) // HTTPS = 3443
        .replace("{{VERSION}}", crate::server::config::get_server_version())
        .replace("{{CREATION_TIME}}", &chrono::Local::now().to_rfc3339());

    let html_with_script = crate::server::handlers::web::server::inject_rss_script(html_content);

    Ok(HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html_with_script))
}

// ## END ##

// ## FILE: src/server/handlers/web/api.rs
// ## BEGIN ##
use super::ServerDataWithConfig;
use crate::server::{config, logging::ServerLogger};
use actix_web::{web, HttpResponse, Result as ActixResult};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Message {
    message: String,
    from: String,
    timestamp: String,
    id: u32,
}

pub async fn status_handler(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let uptime = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let server_dir = format!("www/{}-[{}]", data.server.name, data.server.port);

    Ok(HttpResponse::Ok().json(json!({
        "status": "running",
        "server_id": data.server.id,
        "server_name": data.server.name,
        "port": data.server.port,
        "proxy_port": data.proxy_https_port, // Verwende https proxy port
        "server": config::get_server_name(),
        "version": config::get_server_version(),
        "uptime_seconds": uptime,
        "static_files": true,
        "template_system": true,
        "hot_reload": true,
        "websocket_endpoint": "/ws/hot-reload",
        "server_directory": server_dir,
        "log_file": format!(".rss/servers/{}-[{}].log", data.server.name, data.server.port),
        "certificate_file": format!(".rss/certs/{}-{}.cert", data.server.name, data.server.port),
        "private_key_file": format!(".rss/certs/{}-{}.key", data.server.name, data.server.port),
        "urls": {
            "http": format!("http://127.0.0.1:{}", data.server.port),
            "proxy": format!("https://{}.localhost:{}", data.server.name, data.proxy_https_port)
        }
    })))
}

pub async fn info_handler(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let server_dir = format!("www/{}-[{}]", data.server.name, data.server.port);

    Ok(HttpResponse::Ok().json(json!({
        "name": "Rush Sync Server",
        "version": config::get_server_version(),
        "server_id": data.server.id,
        "server_name": data.server.name,
        "port": data.server.port,
        "proxy_port": data.proxy_https_port, // Verwende https proxy port
        "static_files_enabled": true,
        "template_system": "enabled",
        "hot_reload_enabled": true,
        "websocket_url": format!("ws://127.0.0.1:{}/ws/hot-reload", data.server.port),
        "server_directory": server_dir,
        "certificate": {
            "cert_file": format!(".rss/certs/{}-{}.cert", data.server.name, data.server.port),
            "key_file": format!(".rss/certs/{}-{}.key", data.server.name, data.server.port),
            "common_name": format!("{}.localhost", data.server.name)
        },
        "urls": {
            "http": format!("http://127.0.0.1:{}", data.server.port),
            "proxy": format!("https://{}.localhost:{}", data.server.name, data.proxy_https_port),
            "websocket": format!("ws://127.0.0.1:{}/ws/hot-reload", data.server.port)
        },
        "endpoints": [
            { "path": "/", "method": "GET", "description": "Static files from server directory", "type": "static" },
            { "path": "/.rss/favicon.svg", "method": "GET", "description": "SVG favicon", "type": "static" },
            { "path": "/api/status", "method": "GET", "description": "Server status", "type": "api" },
            { "path": "/api/info", "method": "GET", "description": "API information", "type": "api" },
            { "path": "/api/metrics", "method": "GET", "description": "Server metrics", "type": "api" },
            { "path": "/api/stats", "method": "GET", "description": "Request statistics", "type": "api" },
            { "path": "/api/logs", "method": "GET", "description": "Live server logs", "type": "api" },
            { "path": "/api/logs/raw", "method": "GET", "description": "Raw log data (JSON)", "type": "api" },
            { "path": "/api/health", "method": "GET", "description": "Health check", "type": "api" },
            { "path": "/ws/hot-reload", "method": "GET", "description": "WebSocket hot reload", "type": "websocket" }
        ]
    })))
}

pub async fn metrics_handler(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let uptime = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let server_dir = format!("www/{}-[{}]", data.server.name, data.server.port);
    let log_file_size = if let Ok(logger) = ServerLogger::new(&data.server.name, data.server.port) {
        logger.get_log_file_size_bytes().unwrap_or(0)
    } else {
        0
    };

    let file_count = std::fs::read_dir(&server_dir)
        .map(|entries| entries.count())
        .unwrap_or(0);

    Ok(HttpResponse::Ok().json(json!({
        "server_id": data.server.id,
        "server_name": data.server.name,
        "port": data.server.port,
        "uptime_seconds": uptime,
        "status": "running",
        "hot_reload": {
            "enabled": true,
            "websocket_url": format!("ws://127.0.0.1:{}/ws/hot-reload", data.server.port),
            "watching_directory": server_dir,
            "file_watcher": "active"
        },
        "static_files": {
            "directory": server_dir,
            "file_count": file_count,
            "enabled": true,
            "template_based": true
        },
        "logging": {
            "file_size_bytes": log_file_size,
            "enabled": true
        },
        "endpoints_count": 10,
        "last_updated": uptime
    })))
}

pub async fn stats_handler(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let server_dir = format!("www/{}-[{}]", data.server.name, data.server.port);

    let stats = if let Ok(logger) = ServerLogger::new(&data.server.name, data.server.port) {
        logger.get_request_stats().await.unwrap_or_default()
    } else {
        Default::default()
    };

    Ok(HttpResponse::Ok().json(json!({
        "server_id": data.server.id,
        "server_name": data.server.name,
        "server_directory": server_dir,
        "total_requests": stats.total_requests,
        "unique_ips": stats.unique_ips,
        "error_requests": stats.error_requests,
        "security_alerts": stats.security_alerts,
        "performance_warnings": stats.performance_warnings,
        "avg_response_time_ms": stats.avg_response_time,
        "max_response_time_ms": stats.max_response_time,
        "total_bytes_sent": stats.total_bytes_sent,
        "uptime_seconds": SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
        "hot_reload_status": "active"
    })))
}

pub async fn health_handler(_data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();

    Ok(HttpResponse::Ok().json(json!({
        "status": "healthy",
        "timestamp": timestamp,
        "uptime": "running",
        "logging": "active",
        "static_files": "enabled",
        "template_system": "active",
        "hot_reload": "active",
        "file_watcher": "monitoring",
        "config": "loaded from TOML"
    })))
}

pub async fn ping_handler() -> ActixResult<HttpResponse> {
    Ok(HttpResponse::Ok().json(json!({
        "status": "pong",
        "timestamp": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),
        "server": "rush-sync-server",
        "message": "Ping received successfully"
    })))
}

// Static Message Store (In-Memory f√ºr Demo)
lazy_static::lazy_static! {
    static ref MESSAGES: Arc<Mutex<VecDeque<Message>>> = Arc::new(Mutex::new(VecDeque::new()));
    static ref MESSAGE_COUNTER: Arc<Mutex<u32>> = Arc::new(Mutex::new(0));
}

// POST /api/message - Nachricht empfangen
pub async fn message_handler(body: web::Json<serde_json::Value>) -> ActixResult<HttpResponse> {
    let message_text = body
        .get("message")
        .and_then(|v| v.as_str())
        .unwrap_or("No message");

    let from = body
        .get("from")
        .and_then(|v| v.as_str())
        .unwrap_or("Unknown");

    let timestamp = body
        .get("timestamp")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .unwrap_or_else(|| chrono::Local::now().to_rfc3339());

    // Message speichern
    {
        let mut messages = MESSAGES.lock().unwrap();
        let mut counter = MESSAGE_COUNTER.lock().unwrap();
        *counter += 1;

        let message = Message {
            message: message_text.to_string(),
            from: from.to_string(),
            timestamp: timestamp.to_string(),
            id: *counter,
        };

        messages.push_back(message);

        // Max 100 Messages behalten
        if messages.len() > 100 {
            messages.pop_front();
        }
    }

    // Message ID f√ºr Response merken
    let message_id = {
        let counter = MESSAGE_COUNTER.lock().unwrap();
        *counter
    };

    log::info!("Message received from {}: {}", from, message_text);

    Ok(HttpResponse::Ok().json(json!({
        "status": "received",
        "timestamp": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),
        "message_id": message_id
    })))
}

// GET /api/messages - Alle Nachrichten abrufen
pub async fn messages_handler() -> ActixResult<HttpResponse> {
    let messages = {
        let messages_lock = MESSAGES.lock().unwrap();
        messages_lock.iter().cloned().collect::<Vec<_>>()
    };

    Ok(HttpResponse::Ok().json(json!({
        "messages": messages,
        "count": messages.len(),
        "status": "success"
    })))
}

pub async fn close_browser_handler() -> ActixResult<HttpResponse> {
    let html = r#"
<script>
setTimeout(() => { window.close(); }, 100);
document.write('<h1>Server stopped - closing...</h1>');
</script>
"#;
    Ok(HttpResponse::Ok().content_type("text/html").body(html))
}

// ## END ##

// ## FILE: src/server/handlers/web/logs.rs
// ## BEGIN ##
use super::ServerDataWithConfig;
use crate::server::logging::ServerLogger;
use actix_web::{web, HttpRequest, HttpResponse, Result as ActixResult};
use serde_json::json;
use std::path::PathBuf;
use tokio::fs;
use tokio::io::{AsyncBufReadExt, BufReader};

pub async fn logs_raw_handler(
    req: HttpRequest,
    data: web::Data<ServerDataWithConfig>,
) -> ActixResult<HttpResponse> {
    let exe_path = std::env::current_exe().unwrap();
    let base_dir = exe_path.parent().unwrap();
    let log_file_path = base_dir
        .join(".rss")
        .join("servers")
        .join(format!("{}-[{}].log", data.server.name, data.server.port));

    if !log_file_path.exists() {
        return Ok(HttpResponse::Ok().json(json!({
            "new_entries": [],
            "file_size": 0,
            "total_lines": 0,
            "status": "no_log_file"
        })));
    }

    let metadata = match fs::metadata(&log_file_path).await {
        Ok(meta) => meta,
        Err(e) => {
            log::error!("Failed to read log file metadata: {}", e);
            return Ok(HttpResponse::InternalServerError().json(json!({
                "error": "Failed to access log file"
            })));
        }
    };

    let current_file_size = metadata.len();

    let last_known_size: u64 = req
        .headers()
        .get("X-Log-Size")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.parse().ok())
        .unwrap_or(0);

    if current_file_size <= last_known_size {
        return Ok(HttpResponse::Ok().json(json!({
            "new_entries": [],
            "file_size": current_file_size,
            "total_lines": 0,
            "status": "no_new_data"
        })));
    }

    let new_entries = match read_log_entries_from_offset(&log_file_path, last_known_size).await {
        Ok(entries) => entries,
        Err(e) => {
            log::error!("Failed to read log entries: {}", e);
            return Ok(HttpResponse::InternalServerError().json(json!({
                "error": "Failed to read log entries"
            })));
        }
    };

    let stats = get_log_stats(&log_file_path).await.ok();

    Ok(HttpResponse::Ok().json(json!({
        "new_entries": new_entries,
        "file_size": current_file_size,
        "total_lines": new_entries.len(),
        "status": "success",
        "stats": stats
    })))
}

pub async fn logs_handler(data: web::Data<ServerDataWithConfig>) -> ActixResult<HttpResponse> {
    let server_dir = format!("www/{}-[{}]", data.server.name, data.server.port);
    let log_path = format!(
        ".rss/servers/{}-[{}].log",
        data.server.name, data.server.port
    );

    let log_entries = if let Ok(logger) = ServerLogger::new(&data.server.name, data.server.port) {
        match logger.get_log_file_size_bytes() {
            Ok(size) if size > 0 => format!("Log file size: {} bytes", size),
            _ => "No log entries yet".to_string(),
        }
    } else {
        "Logger unavailable".to_string()
    };

    let html = format!(
        r#"<!DOCTYPE html>
<html lang="de">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Server Logs - {}</title>
   <link rel="icon" href="/.rss/favicon.svg" type="image/svg+xml">
   <style>
       body {{
           font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Monaco', monospace;
           margin: 0;
           background: #1a1d23;
           color: #ffffff;
           padding: 1rem;
       }}
       .header {{
           background: #252830;
           padding: 1rem;
           border-radius: 6px;
           border: 1px solid #3a3f47;
           margin-bottom: 1rem;
       }}
       .header h1 {{
           margin: 0 0 0.75rem 0;
           font-size: 18px;
           color: #ffffff;
       }}
       .server-info {{
           font-size: 11px;
           color: #a0a6b1;
           line-height: 1.5;
       }}
       .back-link {{
           color: #00d4ff;
           text-decoration: none;
           font-size: 11px;
       }}
       .back-link:hover {{
           background: #00d4ff;
           color: #1a1d23;
           padding: 2px 4px;
           border-radius: 3px;
       }}
       .hot-reload-status {{
           color: #00ff88;
           font-weight: bold;
       }}
       .log-container {{
           background: #0d1117;
           border: 1px solid #3a3f47;
           border-radius: 6px;
           padding: 1rem;
           max-height: 600px;
           overflow-y: auto;
       }}
       .log-entry {{
           margin: 2px 0;
           font-size: 11px;
           color: #58a6ff;
           line-height: 1.3;
       }}
   </style>
   <script>setInterval(function() {{ location.reload(); }}, 5000);</script>
</head>
<body>
   <div class="header">
       <h1>Server Logs: {}</h1>
       <div class="server-info">
           <p>ID: {} | HTTP: {} | Proxy: {}.localhost:{}</p>
           <p>Directory: {} | Log: {}</p>
           <p class="hot-reload-status">Hot Reload: ACTIVE (WebSocket on /ws/hot-reload)</p>
           <p><a href="/" class="back-link">‚Üê Zur√ºck zur Hauptseite</a></p>
       </div>
   </div>
   <div class="log-container">
       <div class="log-entry">Server Directory: {}</div>
       <div class="log-entry">HTTP: http://127.0.0.1:{}</div>
       <div class="log-entry">Proxy: https://{}.localhost:{}</div>
       <div class="log-entry">TLS Certificate: .rss/certs/{}-{}.cert</div>
       <div class="log-entry">Log Status: {}</div>
       <div class="log-entry">Static Files: Enabled (Template-based)</div>
       <div class="log-entry">Hot Reload: WebSocket active on /ws/hot-reload</div>
       <div class="log-entry">File Watcher: Monitoring www directory for changes</div>
       <div class="log-entry">Configuration: Loaded from rush.toml</div>
       <div class="log-entry">--- REAL LOG ENTRIES WOULD APPEAR HERE ---</div>
       <div class="log-entry">Live logging with rotation, security alerts, and performance monitoring</div>
   </div>
</body>
</html>"#,
        data.server.name,
        data.server.name,
        data.server.id,
        data.server.port,
        data.server.name,
        data.proxy_https_port, // FIXED: Verwende proxy_https_port aus data
        server_dir,
        log_path,
        server_dir,
        data.server.port,
        data.server.name,
        data.proxy_https_port, // FIXED: Verwende proxy_https_port aus data
        data.server.name,
        data.server.port,
        log_entries
    );

    Ok(HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html))
}

async fn read_log_entries_from_offset(
    file_path: &PathBuf,
    offset: u64,
) -> Result<Vec<serde_json::Value>, Box<dyn std::error::Error + Send + Sync>> {
    let file = fs::File::open(file_path).await?;
    let mut reader = BufReader::new(file);

    if offset > 0 {
        use tokio::io::AsyncSeekExt;
        let mut file_with_seek = fs::File::open(file_path).await?;
        file_with_seek
            .seek(std::io::SeekFrom::Start(offset))
            .await?;
        reader = BufReader::new(file_with_seek);
    }

    let mut entries = Vec::new();
    let mut line = String::new();
    let mut lines_read = 0;
    const MAX_LINES_PER_REQUEST: usize = 100;

    while lines_read < MAX_LINES_PER_REQUEST {
        line.clear();
        let bytes_read = reader.read_line(&mut line).await?;

        if bytes_read == 0 {
            break;
        }

        let trimmed_line = line.trim();
        if trimmed_line.is_empty() {
            continue;
        }

        if let Ok(json_entry) = serde_json::from_str::<serde_json::Value>(trimmed_line) {
            entries.push(json_entry);
        } else {
            entries.push(json!({
                "timestamp": chrono::Local::now().to_rfc3339(),
                "timestamp_unix": chrono::Utc::now().timestamp(),
                "event_type": "PlainText",
                "message": trimmed_line,
                "level": "INFO"
            }));
        }

        lines_read += 1;
    }

    Ok(entries)
}

async fn get_log_stats(
    file_path: &PathBuf,
) -> Result<serde_json::Value, Box<dyn std::error::Error + Send + Sync>> {
    let file = fs::File::open(file_path).await?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();

    let mut total_requests = 0;
    let mut error_requests = 0;
    let mut unique_ips = std::collections::HashSet::new();
    let mut total_bytes = 0u64;
    let mut response_times = Vec::new();

    let mut line_count = 0;
    const MAX_LINES_FOR_STATS: usize = 1000;

    while let Ok(Some(line)) = lines.next_line().await {
        if line_count >= MAX_LINES_FOR_STATS {
            break;
        }

        if let Ok(log_entry) = serde_json::from_str::<serde_json::Value>(&line) {
            if log_entry.get("event_type").and_then(|v| v.as_str()) == Some("Request") {
                total_requests += 1;

                if let Some(ip) = log_entry.get("ip_address").and_then(|v| v.as_str()) {
                    unique_ips.insert(ip.to_string());
                }

                if let Some(status) = log_entry.get("status_code").and_then(|v| v.as_u64()) {
                    if status >= 400 {
                        error_requests += 1;
                    }
                }

                if let Some(bytes) = log_entry.get("bytes_sent").and_then(|v| v.as_u64()) {
                    total_bytes += bytes;
                }

                if let Some(rt) = log_entry.get("response_time_ms").and_then(|v| v.as_u64()) {
                    response_times.push(rt);
                }
            }
        }

        line_count += 1;
    }

    let avg_response_time = if response_times.is_empty() {
        0
    } else {
        response_times.iter().sum::<u64>() / response_times.len() as u64
    };

    let max_response_time = response_times.iter().max().copied().unwrap_or(0);

    Ok(json!({
        "total_requests": total_requests,
        "error_requests": error_requests,
        "unique_ips": unique_ips.len(),
        "total_bytes_sent": total_bytes,
        "avg_response_time_ms": avg_response_time,
        "max_response_time_ms": max_response_time,
        "lines_processed": line_count
    }))
}

// ## END ##

// ## FILE: src/server/handlers/mod.rs
// ## BEGIN ##
pub mod web;
pub use web::*;

// ## END ##

// ## FILE: src/server/shared.rs
// ## BEGIN ##
use crate::core::config::Config;
use crate::proxy::ProxyManager;
use crate::server::persistence::ServerRegistry;
use crate::server::types::{ServerContext, ServerStatus};
use crate::server::utils::port::is_port_available;
use std::sync::{Arc, OnceLock};

static SHARED_CONTEXT: OnceLock<ServerContext> = OnceLock::new();
static PERSISTENT_REGISTRY: OnceLock<ServerRegistry> = OnceLock::new();
static PROXY_MANAGER: OnceLock<Arc<ProxyManager>> = OnceLock::new();

pub fn get_shared_context() -> &'static ServerContext {
    SHARED_CONTEXT.get_or_init(ServerContext::default)
}

pub fn get_persistent_registry() -> &'static ServerRegistry {
    PERSISTENT_REGISTRY
        .get_or_init(|| ServerRegistry::new().expect("Failed to initialize server registry"))
}

pub fn get_proxy_manager() -> &'static Arc<ProxyManager> {
    PROXY_MANAGER.get_or_init(|| {
        // Config laden und Proxy Manager erstellen
        let config = tokio::task::block_in_place(|| {
            tokio::runtime::Handle::current().block_on(async {
                crate::core::config::Config::load()
                    .await
                    .unwrap_or_default()
            })
        });

        Arc::new(ProxyManager::new(config.proxy))
    })
}

// NEU: Proxy System starten
async fn start_proxy_system(config: &Config) -> crate::core::error::Result<()> {
    if !config.proxy.enabled {
        log::info!("Proxy system disabled in config");
        return Ok(());
    }

    let proxy_manager = get_proxy_manager();

    // Proxy Server starten (HTTP auf 8000 + HTTPS auf 8443)
    Arc::clone(proxy_manager).start_proxy_server().await?;

    log::info!("Proxy system started:");
    log::info!("  HTTP:  http://{{name}}.localhost:{}", config.proxy.port);

    let https_port = config.proxy.port + config.proxy.https_port_offset;
    log::info!("HTTPS: https://{{name}}.localhost:{}", https_port);

    Ok(())
}

// NEU: HTTP Redirect Server starten
// async fn start_http_redirect(config: &Config) -> crate::core::error::Result<()> {
//     if !config.proxy.enabled {
//         return Ok(());
//     }

//     // Port 80 nur wenn verf√ºgbar
//     if !is_port_available(80) {
//         log::warn!("Port 80 already in use - HTTP redirect disabled");
//         log::info!("Tip: Use 'sudo lsof -i :80' to check what's using it");
//         return Ok(());
//     }

//     // Import aus server::redirect
//     use crate::server::redirect::HttpRedirectServer;

//     let redirect = HttpRedirectServer::new(80, 8443); // Redirect zu HTTPS Proxy

//     std::thread::spawn(move || {
//         // Single-thread Tokio-Runtime (keine Send-Anforderung f√ºr Futures)
//         let rt = tokio::runtime::Builder::new_current_thread()
//             .enable_all()
//             .build()
//             .expect("failed to build single-thread runtime");

//         rt.block_on(async move {
//             if let Err(e) = redirect.run().await {
//                 log::error!("HTTP redirect server failed: {}", e);
//             }
//         });
//     });

//     log::info!("HTTP‚ÜíHTTPS redirect active on port 80");
//     Ok(())
// }

pub async fn initialize_server_system() -> crate::core::error::Result<()> {
    let config = Config::load().await?;

    crate::server::handlers::web::set_global_config(config.clone());

    let registry = get_persistent_registry();
    let context = get_shared_context();

    let mut persistent_servers = registry.load_servers().await?;
    let mut corrected_servers = 0;

    for (_server_id, persistent_info) in persistent_servers.iter_mut() {
        if persistent_info.status == ServerStatus::Running {
            if !is_port_available(persistent_info.port) {
                log::warn!(
                    "Server {} claims to be running on port {}, but port is occupied",
                    persistent_info.name,
                    persistent_info.port
                );
                persistent_info.status = ServerStatus::Failed;
                corrected_servers += 1;
            } else {
                log::info!(
                    "Server {} was running but is no longer active, correcting status",
                    persistent_info.name
                );
                persistent_info.status = ServerStatus::Stopped;
                corrected_servers += 1;
            }
        }
    }

    if corrected_servers > 0 {
        registry.save_servers(&persistent_servers).await?;
        log::info!(
            "Corrected {} server statuses after program restart",
            corrected_servers
        );
    }

    {
        let mut servers = context.servers.write().unwrap();
        servers.clear();
        for (id, persistent_info) in persistent_servers.iter() {
            let server_info = crate::server::types::ServerInfo::from(persistent_info.clone());
            servers.insert(id.clone(), server_info);
        }
    }

    log::info!(
        "Server system initialized with {} persistent servers",
        persistent_servers.len()
    );
    log::info!(
        "Server Config: Port Range {}-{}, Max Concurrent: {}, Workers: {}",
        config.server.port_range_start,
        config.server.port_range_end,
        config.server.max_concurrent,
        config.server.workers
    );
    log::info!(
        "Logging Config: Max Size {}MB, Archives: {}, Compression: {}, Request Logging: {}",
        config.logging.max_file_size_mb,
        config.logging.max_archive_files,
        config.logging.compress_archives,
        config.logging.log_requests
    );

    let auto_start_servers = registry.get_auto_start_servers(&persistent_servers);
    if !auto_start_servers.is_empty() {
        log::info!(
            "Found {} servers marked for auto-start",
            auto_start_servers.len()
        );

        if auto_start_servers.len() > config.server.max_concurrent {
            log::warn!(
                "Auto-start servers ({}) exceed max_concurrent ({}), some will be skipped",
                auto_start_servers.len(),
                config.server.max_concurrent
            );
        }
    }

    // √úBERARBEITET: Proxy Manager mit verbesserter Struktur
    if config.proxy.enabled {
        // 1. Proxy System starten (HTTP + HTTPS)
        if let Err(e) = start_proxy_system(&config).await {
            log::error!("Failed to start proxy system: {}", e);
            // Proxy ist optional - wir laufen trotzdem weiter
        } else {
            // 2. HTTP Redirect starten (optional, braucht sudo f√ºr Port 80)
            if let Err(e) = start_http_redirect_server(&config).await {
                log::warn!("Failed to start HTTP redirect: {}", e);
                // Nicht fatal - l√§uft auch ohne
            }

            // 3. Bereits laufende Server beim Proxy registrieren
            let proxy_manager = get_proxy_manager();
            for (_id, persistent_info) in persistent_servers.iter() {
                if persistent_info.status == ServerStatus::Running {
                    if let Err(e) = proxy_manager
                        .add_route(
                            &persistent_info.name,
                            &persistent_info.id,
                            persistent_info.port,
                        )
                        .await
                    {
                        log::error!(
                            "Failed to register server {} with proxy: {}",
                            persistent_info.name,
                            e
                        );
                    } else {
                        log::info!(
                            "Registered existing server {} with proxy",
                            persistent_info.name
                        );
                    }
                }
            }
        }

        if is_port_available(80) {
            log::info!("  With sudo: http://{{name}}.localhost ‚Üí redirects to HTTPS");
        }
        log::info!("  Add to /etc/hosts: 127.0.0.1 {{name}}.localhost");
    } else {
        log::info!("Reverse Proxy disabled in configuration");
    }

    Ok(())
}

pub async fn persist_server_update(server_id: &str, status: crate::server::types::ServerStatus) {
    let registry = get_persistent_registry();
    if let Err(e) = registry.update_server_status(server_id, status).await {
        log::error!("Failed to persist server status update: {}", e);
    }
}

pub async fn shutdown_all_servers_on_exit() -> crate::core::error::Result<()> {
    let config = Config::load().await.unwrap_or_default();
    let registry = get_persistent_registry();
    let context = get_shared_context();

    let server_handles: Vec<_> = {
        let mut handles = context.handles.write().unwrap();
        handles.drain().collect()
    };

    log::info!("Shutting down {} active servers...", server_handles.len());

    let shutdown_timeout = std::time::Duration::from_secs(config.server.shutdown_timeout);

    for (server_id, handle) in server_handles {
        log::info!("Stopping server {}", server_id);

        if tokio::time::timeout(shutdown_timeout, handle.stop(true))
            .await
            .is_err()
        {
            log::warn!("Server {} shutdown timeout, forcing stop", server_id);
            handle.stop(false).await;
        }

        // Korrigierte API-Aufrufe
        let _ = registry
            .update_server_status(&server_id, ServerStatus::Stopped)
            .await;
    }

    log::info!("Server system shutdown complete");
    Ok(())
}

pub async fn validate_server_creation(
    name: &str,
    port: Option<u16>,
) -> crate::core::error::Result<()> {
    let config = Config::load().await?;
    let context = get_shared_context();
    let servers = context.servers.read().unwrap();

    if servers.len() >= config.server.max_concurrent {
        return Err(crate::core::error::AppError::Validation(format!(
            "Server limit reached: {}/{}. Use 'cleanup' command to remove stopped servers.",
            servers.len(),
            config.server.max_concurrent
        )));
    }

    if let Some(port) = port {
        if port < config.server.port_range_start || port > config.server.port_range_end {
            return Err(crate::core::error::AppError::Validation(format!(
                "Port {} outside configured range {}-{}",
                port, config.server.port_range_start, config.server.port_range_end
            )));
        }
    }

    if servers.values().any(|s| s.name == name) {
        return Err(crate::core::error::AppError::Validation(format!(
            "Server name '{}' already exists",
            name
        )));
    }

    Ok(())
}

pub async fn get_server_system_stats() -> serde_json::Value {
    let config = Config::load().await.unwrap_or_default();
    let context = get_shared_context();
    let servers = context.servers.read().unwrap();

    let running_count = servers
        .values()
        .filter(|s| s.status == ServerStatus::Running)
        .count();
    let stopped_count = servers
        .values()
        .filter(|s| s.status == ServerStatus::Stopped)
        .count();
    let failed_count = servers
        .values()
        .filter(|s| s.status == ServerStatus::Failed)
        .count();

    serde_json::json!({
        "total_servers": servers.len(),
        "running": running_count,
        "stopped": stopped_count,
        "failed": failed_count,
        "max_concurrent": config.server.max_concurrent,
        "utilization_percent": (servers.len() as f64 / config.server.max_concurrent as f64 * 100.0),
        "port_range": format!("{}-{}", config.server.port_range_start, config.server.port_range_end),
        "available_ports": config.server.port_range_end - config.server.port_range_start + 1,
        "proxy": {
            "enabled": config.proxy.enabled,
            "http_port": config.proxy.port,
            "https_port": 8443,
            "redirect_port": if is_port_available(80) { None } else { Some(80) }
        },
        "config": {
            "workers_per_server": config.server.workers,
            "shutdown_timeout_sec": config.server.shutdown_timeout,
            "startup_delay_ms": config.server.startup_delay_ms,
            "logging": {
                "max_file_size_mb": config.logging.max_file_size_mb,
                "max_archives": config.logging.max_archive_files,
                "compression": config.logging.compress_archives,
                "request_logging": config.logging.log_requests,
                "security_alerts": config.logging.log_security_alerts,
                "performance_monitoring": config.logging.log_performance
            }
        }
    })
}

pub async fn auto_start_servers() -> crate::core::error::Result<Vec<String>> {
    let config = Config::load().await?;
    let registry = get_persistent_registry();
    let auto_start_servers = {
        let servers = registry.load_servers().await?;
        registry.get_auto_start_servers(&servers)
    };

    if auto_start_servers.is_empty() {
        return Ok(vec![]);
    }

    let max_to_start = config.server.max_concurrent.min(auto_start_servers.len());
    let mut started_servers = Vec::new();

    for server in auto_start_servers.iter().take(max_to_start) {
        log::info!(
            "Auto-starting server: {} on port {}",
            server.name,
            server.port
        );
        started_servers.push(format!("{}:{}", server.name, server.port));
    }

    if auto_start_servers.len() > max_to_start {
        log::warn!(
            "Skipped {} auto-start servers due to max_concurrent limit of {}",
            auto_start_servers.len() - max_to_start,
            config.server.max_concurrent
        );
    }

    Ok(started_servers)
}

// F√ºge das ganz am Ende der Datei ein, nach der letzten Funktion
// Ersetze die start_http_redirect_server Funktion in src/server/shared.rs

async fn start_http_redirect_server(_config: &Config) -> crate::core::error::Result<()> {
    let redirect_port = 80;
    let target_https_port = 8443;

    if !crate::server::utils::port::is_port_available(redirect_port) {
        log::warn!(
            "Port {} already in use - HTTP redirect disabled",
            redirect_port
        );
        return Ok(());
    }

    log::info!(
        "Starting HTTP‚ÜíHTTPS redirect server on port {}",
        redirect_port
    );

    // L√ñSUNG: std::thread::spawn statt tokio::spawn verwenden
    std::thread::spawn(move || {
        // Single-thread Tokio-Runtime (keine Send-Anforderung f√ºr Futures)
        let rt = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .expect("Failed to build single-thread runtime for redirect server");

        rt.block_on(async move {
            let redirect_server =
                crate::server::redirect::HttpRedirectServer::new(redirect_port, target_https_port);

            if let Err(e) = redirect_server.run().await {
                log::error!("HTTP redirect server error: {}", e);
            }
        });
    });

    // Kurz warten f√ºr Startup
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
    log::info!(
        "HTTP redirect active: Port {} ‚Üí HTTPS Port {}",
        redirect_port,
        target_https_port
    );

    Ok(())
}

// ## END ##

// ## FILE: src/bootstrap.rs
// ## BEGIN ##
// use rush_sync_server::embedded::{register_dir, TEMPLATES_DIR};
// use rush_sync_server::memory::{register_embedded, ResourceKind};

// const BOOT_SENTINEL: &[u8] = b".";

// pub fn early_boot() {
//     // 1 Byte ‚Äì bleibt wie gehabt
//     register_embedded(
//         "boot:sentinel@v1",
//         ResourceKind::EmbeddedAsset,
//         BOOT_SENTINEL.len() as u64,
//     );

//     // NEU: kompletten Templates-Ordner automatisch registrieren
//     // => legt IDs wie "asset:tpl:rss/favicon.svg@v1", "asset:tpl:rss/_reset.css@v1", ...
//     register_dir(&TEMPLATES_DIR, "asset:tpl");

//     #[cfg(debug_assertions)]
//     {
//         rush_sync_server::memory::debug_dump_to_log();
//     }
// }

// ## END ##

// ## FILE: src/main.rs
// ## BEGIN ##
use rush_sync_server::core::config::Config;
use rush_sync_server::embedded;
use rush_sync_server::ui::screen::ScreenManager;
use rush_sync_server::{i18n, Result};
use std::io::Write;
use std::path::PathBuf;

use rush_sync_server::memory;

#[tokio::main]
async fn main() -> Result<()> {
    // 0) Bootstrap
    {
        let _s = memory::begin_scope("phase:bootstrap@v1");
        embedded::register_all_src(); // oder register_all_src_filtered()
        rush_sync_server::core::constants::register_constants_to_memory();
    }

    // 1) Logger
    {
        let _s = memory::begin_scope("phase:logger_setup@v1");
        setup_panic_handler();
        setup_logger();
    }

    // 2) i18n
    {
        let _s = memory::begin_scope("phase:i18n_init@v1");
        i18n::init()
            .await
            .map_err(|e| log::error!("i18n failed: {e}"))
            .ok();
    }

    // 3) Server-System
    {
        let _s = memory::begin_scope("phase:server_init@v1");
        log::info!("Initializing server system...");
        rush_sync_server::server::shared::initialize_server_system().await?;
    }

    // 4) TUI
    let config = {
        let _s = memory::begin_scope("phase:config_load@v1");
        Config::load_with_messages(false).await?
    };
    let mut screen = {
        let _s = memory::begin_scope("phase:tui_init@v1");
        ScreenManager::new(&config).await?
    };

    // 5) Run
    log::info!("Starting application...");
    let result = screen.run().await;

    // 6) Shutdown (einmal!)
    {
        let _s = memory::begin_scope("phase:server_shutdown@v1");
        log::info!("Shutting down...");
        if let Err(e) = rush_sync_server::server::shared::shutdown_all_servers_on_exit().await {
            log::error!("Cleanup error: {e}");
        }
    }

    result
}

fn setup_panic_handler() {
    std::panic::set_hook(Box::new(|panic_info| {
        let _ = crossterm::terminal::disable_raw_mode();
        let _ = crossterm::execute!(
            std::io::stdout(),
            crossterm::terminal::LeaveAlternateScreen,
            crossterm::cursor::Show
        );

        write_debug_log("PANIC", &format!("{}", panic_info));

        tokio::spawn(async {
            let _ = rush_sync_server::server::shared::shutdown_all_servers_on_exit().await;
        });
    }));
}

fn setup_logger() {
    struct DebugLogger;

    impl log::Log for DebugLogger {
        fn enabled(&self, metadata: &log::Metadata) -> bool {
            metadata.level() <= log::Level::Debug
        }

        fn log(&self, record: &log::Record) {
            if self.enabled(record.metadata()) {
                write_debug_log(&record.level().to_string(), &record.args().to_string());
            }
        }

        fn flush(&self) {}
    }

    if log::set_boxed_logger(Box::new(DebugLogger)).is_ok() {
        log::set_max_level(log::LevelFilter::Debug);
    }
}

fn write_debug_log(level: &str, message: &str) {
    let log_path = get_debug_log_path();
    let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
    let log_line = format!("[{}] [{}] {}\n", timestamp, level, message);

    let _ = std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(log_path)
        .and_then(|mut file| file.write_all(log_line.as_bytes()));
}

fn get_debug_log_path() -> PathBuf {
    std::env::current_exe()
        .ok()
        .and_then(|exe| exe.parent().map(|p| p.join(".rss").join("rush.debug")))
        .unwrap_or_else(|| PathBuf::from("rush.debug"))
}

// ## END ##

// ## FILE: src/commands/memory/command.rs
// ## BEGIN ##
use crate::memory;
use crate::{matches_exact, Result};

#[derive(Debug)]
pub struct MemoryCommand;

impl MemoryCommand {
    pub fn new() -> Self {
        Self
    }
}

#[derive(Debug, Clone)]
enum MemorySubcommand {
    Help,
    Info {
        json: bool,
        top: Option<usize>,
        all: bool,
    },
}

#[async_trait::async_trait]
impl crate::commands::command::Command for MemoryCommand {
    fn name(&self) -> &'static str {
        "mem"
    }

    fn description(&self) -> &'static str {
        "Zeigt Memory-Registry/Snapshot und Prozessdetails an"
    }

    fn matches(&self, command: &str) -> bool {
        if let Some(first) = command.split_whitespace().next() {
            return matches_exact!(first, "mem");
        }
        false
    }

    async fn execute(&self, args: &[&str]) -> Result<String> {
        // Beispiele:
        // - ["mem"] ‚Üí Help
        // - ["mem","help"]
        // - ["mem","info","--top","10","--json","--all"]
        // - ["info","--all"] (wenn Handler "mem" schon abgeschnitten hat)
        let sub = parse_from_args(args);

        match sub {
            MemorySubcommand::Help => {
                return Ok(help_text());
            }
            MemorySubcommand::Info { json, top, all } => {
                let items = memory::snapshot();

                if json {
                    let total = memory::total_bytes();
                    let rss = crate::memory::process_rss_bytes();
                    let total_ram = crate::memory::total_ram_bytes();

                    let total_kb = (total as f64) / 1024.0;
                    let total_mb = total_kb / 1024.0;
                    let rss_kb = (rss as f64) / 1024.0;
                    let rss_mb = rss_kb / 1024.0;

                    let pct_registry_over_rss = if rss > 0 {
                        (total as f64) * 100.0 / (rss as f64)
                    } else {
                        0.0
                    };
                    let pct_rss_over_totalram = if total_ram > 0 {
                        (rss as f64) * 100.0 / (total_ram as f64)
                    } else {
                        0.0
                    };

                    let mut rows: Vec<_> = items
                        .iter()
                        .map(|r| (r.id.as_str(), format!("{:?}", r.kind), r.bytes))
                        .collect();
                    rows.sort_by(|a, b| b.2.cmp(&a.2));
                    if let Some(n) = top {
                        rows.truncate(n);
                    }

                    let mut out = String::new();
                    out.push_str("{\n  \"resources\": [\n");
                    for (i, (id, kind, bytes)) in rows.iter().enumerate() {
                        out.push_str(&format!(
                            "    {{ \"id\": \"{}\", \"kind\": \"{}\", \"bytes\": {} }}{}",
                            id,
                            kind,
                            bytes,
                            if i + 1 != rows.len() { ",\n" } else { "\n" }
                        ));
                    }
                    out.push_str("  ],\n");
                    out.push_str(&format!(
                        "  \"total_bytes\": {},\n  \"total_kb\": {:.2},\n  \"total_mb\": {:.3},\n",
                        total, total_kb, total_mb
                    ));
                    out.push_str(&format!(
                        "  \"rss_bytes\": {},\n  \"rss_kb\": {:.2},\n  \"rss_mb\": {:.3},\n",
                        rss, rss_kb, rss_mb
                    ));
                    out.push_str(&format!("  \"total_ram_bytes\": {},\n", total_ram));
                    out.push_str(&format!(
                        "  \"pct_registry_over_rss\": {:.2},\n",
                        pct_registry_over_rss
                    ));
                    out.push_str(&format!(
                        "  \"pct_rss_over_totalram\": {:.2}",
                        pct_rss_over_totalram
                    ));

                    // --all: zus√§tzliche Prozessinfos als JSON-Felder anh√§ngen
                    if all {
                        let fds = fd_summary();
                        out.push_str(",\n  \"fd_summary\": {\n");
                        out.push_str(&format!("    \"total\": {},\n", fds.total));
                        out.push_str(&format!("    \"sockets\": {},\n", fds.sockets));
                        out.push_str(&format!("    \"pipes\": {},\n", fds.pipes));
                        out.push_str(&format!("    \"regular\": {},\n", fds.regular));
                        out.push_str(&format!("    \"chardev\": {},\n", fds.chardev));
                        out.push_str(&format!("    \"dir\": {},\n", fds.dir));
                        out.push_str(&format!("    \"symlink\": {},\n", fds.symlink));
                        out.push_str(&format!("    \"other\": {}\n", fds.other));
                        out.push_str("  }");

                        if let Some(status) = linux_proc_status_json() {
                            out.push_str(",\n  \"proc_status\": ");
                            out.push_str(&status);
                        }
                        if let Some(limits) = linux_proc_limits_json() {
                            out.push_str(",\n  \"proc_limits\": ");
                            out.push_str(&limits);
                        }
                    }
                    out.push_str("\n}\n");
                    return Ok(out);
                }

                // ===== TUI/CLI-Textausgabe =====
                let mut rows: Vec<(&str, &str, u64)> = items
                    .iter()
                    .map(|r| (r.id.as_str(), kind_str(&r.kind), r.bytes))
                    .collect();
                rows.sort_by(|a, b| b.2.cmp(&a.2));
                if let Some(n) = top {
                    rows.truncate(n);
                }

                let total = memory::total_bytes();
                let (total_b, total_h) = fmt_bytes(total);

                let rss = crate::memory::process_rss_bytes();
                let (rss_b, rss_h) = fmt_bytes(rss);

                let vms = crate::memory::process_vms_bytes();
                let (vms_b, vms_h) = fmt_bytes(vms);

                let total_ram = crate::memory::total_ram_bytes();
                let pct_registry_over_rss = if rss > 0 {
                    (total as f64) * 100.0 / (rss as f64)
                } else {
                    0.0
                };
                let pct_rss_over_totalram = if total_ram > 0 {
                    (rss as f64) * 100.0 / (total_ram as f64)
                } else {
                    0.0
                };

                let mut out = String::new();
                out.push_str("MEMORY SNAPSHOT\n");
                out.push_str("================\n");
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "ID", "KIND", "BYTES"));
                out.push_str(&format!("{}\n", "-".repeat(36 + 2 + 16 + 2 + 12)));

                for (id, kind, bytes) in rows {
                    out.push_str(&format!(
                        "{:<36}  {:<16}  {:>12}\n",
                        truncate(id, 36),
                        truncate(kind, 16),
                        bytes
                    ));
                }

                out.push_str(&format!("{}\n", "-".repeat(36 + 2 + 16 + 2 + 12)));
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "TOTAL", "", total_b));
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "", "", total_h));

                out.push_str("\nLEGEND\n");
                out.push_str("------\n");
                out.push_str("Registry: explizit registrierte Ressourcen (Assets, Constants, Phasen-Deltas)\n");
                out.push_str(
                    "RSS:      tats√§chlicher RAM-Verbrauch des Prozesses (Resident Set Size)\n",
                );
                out.push_str("VMS:      virtueller Adressraum (nicht gleich realer RAM)\n");

                // ‚úÖ referenziert das bereits existierende `items` (lebt bis zum Funktionsende)
                let mut phases: Vec<_> = items
                    .iter()
                    .filter(|r| matches!(r.kind, crate::memory::ResourceKind::Phase))
                    .map(|r| (r.id.as_str(), r.bytes))
                    .collect();

                phases.sort_by(|a, b| b.1.cmp(&a.1));
                if let Some(n) = top {
                    phases.truncate(n);
                }

                if !phases.is_empty() {
                    out.push_str("\nPHASES (ŒîRSS)\n");
                    out.push_str("--------------\n");
                    out.push_str(&format!("{:<36}  {:>12}\n", "PHASE ID", "BYTES"));
                    out.push_str(&format!("{}\n", "-".repeat(36 + 2 + 12)));
                    for (id, bytes) in phases {
                        out.push_str(&format!("{:<36}  {:>12}\n", truncate(id, 36), bytes));
                    }
                }

                // RUNTIME
                let thread_count = crate::memory::process_thread_count();
                let thread_text = if thread_count == 0 && cfg!(not(target_os = "linux")) {
                    "n/a".to_string()
                } else {
                    thread_count.to_string()
                };

                out.push_str("\nRUNTIME\n");
                out.push_str("-------\n");
                out.push_str(&format!(
                    "{:<36}  {:<16}  {:>12}\n",
                    "Threads", "", thread_text
                ));

                out.push_str("\nPROCESS MEMORY (RSS)\n");
                out.push_str("--------------------\n");
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "RSS", "", rss_b));
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "", "", rss_h));

                out.push_str("\nVIRTUAL MEMORY (VMS)\n");
                out.push_str("--------------------\n");
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "VMS", "", vms_b));
                out.push_str(&format!("{:<36}  {:<16}  {:>12}\n", "", "", vms_h));

                out.push_str("\nPERCENTAGES\n");
                out.push_str("-----------\n");
                out.push_str(&format!(
                    "{:<36}  {:<16}  {:>11.2}%\n",
                    "Registry TOTAL / RSS", "", pct_registry_over_rss
                ));
                out.push_str(&format!(
                    "{:<36}  {:<16}  {:>11.2}%\n",
                    "RSS / Total RAM", "", pct_rss_over_totalram
                ));

                // --all: tiefe Prozessinfos
                if all {
                    let fds = fd_summary();
                    out.push_str("\nOPEN FILE DESCRIPTORS\n");
                    out.push_str("----------------------\n");
                    out.push_str(&format!("{:<24} {:>12}\n", "Total", fds.total));
                    out.push_str(&format!("{:<24} {:>12}\n", "Sockets", fds.sockets));
                    out.push_str(&format!("{:<24} {:>12}\n", "Pipes", fds.pipes));
                    out.push_str(&format!("{:<24} {:>12}\n", "Regular Files", fds.regular));
                    out.push_str(&format!("{:<24} {:>12}\n", "Char Devices", fds.chardev));
                    out.push_str(&format!("{:<24} {:>12}\n", "Directories", fds.dir));
                    out.push_str(&format!("{:<24} {:>12}\n", "Symlinks", fds.symlink));
                    out.push_str(&format!("{:<24} {:>12}\n", "Other", fds.other));

                    if let Some(status_txt) = linux_proc_status_text() {
                        out.push_str("\nPROC STATUS (/proc/self/status)\n");
                        out.push_str("-------------------------------\n");
                        out.push_str(&status_txt);
                    } else {
                        out.push_str("\nPROC STATUS: n/a on this platform\n");
                    }

                    if let Some(limits_txt) = linux_proc_limits_text() {
                        out.push_str("\nPROC LIMITS (/proc/self/limits)\n");
                        out.push_str("-------------------------------\n");
                        out.push_str(&limits_txt);
                    }
                }

                return Ok(out);
            }
        }
    }
}

// ---------- intern: Parser & Helpers (nur in dieser Datei) ----------

fn parse_from_args(args: &[&str]) -> MemorySubcommand {
    // Falls args mit "mem" beginnt, Index verschieben
    let offset = if args
        .first()
        .map(|s| s.eq_ignore_ascii_case("mem"))
        .unwrap_or(false)
    {
        1
    } else {
        0
    };

    let sub = args
        .get(offset)
        .map(|s| s.to_ascii_lowercase())
        .unwrap_or_else(|| "help".into());

    let mut json = false;
    let mut all = false;
    let mut top: Option<usize> = None;

    // Flags ab offset+1 einsammeln
    let mut i = offset + 1;
    while i < args.len() {
        let a = args[i];
        if a == "--json" {
            json = true;
            i += 1;
            continue;
        }
        if a == "--all" {
            all = true;
            i += 1; // <‚Äî Deins hatte hier i = 1; (Bug)
            continue;
        }
        if a.starts_with("--top=") {
            if let Some(n) = a.split_once('=').and_then(|(_, v)| v.parse::<usize>().ok()) {
                top = Some(n);
            }
            i += 1;
            continue;
        }
        if a == "--top" {
            if let Some(n) = args.get(i + 1).and_then(|v| v.parse::<usize>().ok()) {
                top = Some(n);
                i += 2;
            } else {
                i += 1;
            }
            continue;
        }
        i += 1;
    }

    match sub.as_str() {
        "help" | "" => MemorySubcommand::Help,
        "info" => MemorySubcommand::Info { json, top, all },
        _ => MemorySubcommand::Help,
    }
}

fn kind_str(k: &crate::memory::ResourceKind) -> &'static str {
    use crate::memory::ResourceKind::*;
    match k {
        EmbeddedAsset => "EmbeddedAsset",
        Phase => "Phase",
        _ => "Other",
    }
}

fn truncate(s: &str, max: usize) -> &str {
    if s.len() <= max {
        s
    } else {
        &s[..max]
    }
}

fn fmt_bytes(b: u64) -> (String, String) {
    let kb = (b as f64) / 1024.0;
    let mb = kb / 1024.0;
    (format!("{b}"), format!("{kb:.2} KB / {mb:.3} MB"))
}

// ---------- Help ----------
fn help_text() -> String {
    let mut s = String::new();
    s.push_str("mem ‚Äì Memory & Prozess-Introspektion\n");
    s.push_str("===================================\n");
    s.push_str("USAGE:\n");
    s.push_str("  mem help                 Zeigt diese Hilfe\n");
    s.push_str("  mem info [--top N]      Snapshot der Registry + Prozess-RSS/VMS\n");
    s.push_str("  mem info --json         Ausgabe als JSON\n");
    s.push_str("  mem info --all          Erweiterte Prozessinfos (FDs, /proc/status, limits)\n");
    s.push_str("  mem info --json --all   JSON inkl. erweiterter Prozessinfos\n");
    s
}

// ---------- FD-Summary mit feineren Kategorien ----------
#[derive(Debug, Clone, Copy)]
struct FdSummary {
    total: usize,
    sockets: usize,
    pipes: usize,
    regular: usize,
    chardev: usize,
    dir: usize,
    symlink: usize,
    other: usize,
}

#[cfg(unix)]
fn fd_summary() -> FdSummary {
    use std::os::unix::fs::MetadataExt;
    use std::{fs, path::Path};

    let fd_dir = if Path::new("/proc/self/fd").exists() {
        "/proc/self/fd"
    } else {
        "/dev/fd" // macOS/*BSD
    };

    let mut s = FdSummary {
        total: 0,
        sockets: 0,
        pipes: 0,
        regular: 0,
        chardev: 0,
        dir: 0,
        symlink: 0,
        other: 0,
    };

    if let Ok(entries) = fs::read_dir(fd_dir) {
        for e in entries.flatten() {
            s.total += 1;
            if let Ok(md) = e.metadata() {
                // md.mode(): u32, libc::S_IF* kann u16 sein ‚Üí nach u32 casten
                let m = md.mode() & (libc::S_IFMT as u32);

                if m == (libc::S_IFSOCK as u32) {
                    s.sockets += 1;
                } else if m == (libc::S_IFIFO as u32) {
                    s.pipes += 1;
                } else if m == (libc::S_IFREG as u32) {
                    s.regular += 1;
                } else if m == (libc::S_IFCHR as u32) {
                    s.chardev += 1;
                } else if m == (libc::S_IFDIR as u32) {
                    s.dir += 1;
                } else if m == (libc::S_IFLNK as u32) {
                    s.symlink += 1;
                } else {
                    s.other += 1;
                }
            } else {
                s.other += 1;
            }
        }
    }
    s
}

#[cfg(not(unix))]
fn fd_summary() -> FdSummary {
    FdSummary {
        total: 0,
        sockets: 0,
        pipes: 0,
        regular: 0,
        chardev: 0,
        dir: 0,
        symlink: 0,
        other: 0,
    }
}

#[cfg(target_os = "linux")]
fn linux_proc_status_text() -> Option<String> {
    std::fs::read_to_string("/proc/self/status").ok()
}

#[cfg(not(target_os = "linux"))]
fn linux_proc_status_text() -> Option<String> {
    None
}

#[cfg(target_os = "linux")]
fn linux_proc_limits_text() -> Option<String> {
    std::fs::read_to_string("/proc/self/limits").ok()
}

#[cfg(not(target_os = "linux"))]
fn linux_proc_limits_text() -> Option<String> {
    None
}

#[cfg(target_os = "linux")]
fn linux_proc_status_json() -> Option<String> {
    use std::collections::BTreeMap;
    let s = std::fs::read_to_string("/proc/self/status").ok()?;
    let mut map = BTreeMap::new();
    for line in s.lines() {
        if let Some((k, v)) = line.split_once(':') {
            map.insert(k.trim().to_string(), v.trim().to_string());
        }
    }
    Some(serde_json::to_string(&map).unwrap_or_else(|_| "{}".into()))
}

#[cfg(not(target_os = "linux"))]
fn linux_proc_status_json() -> Option<String> {
    None
}

#[cfg(target_os = "linux")]
fn linux_proc_limits_json() -> Option<String> {
    let txt = std::fs::read_to_string("/proc/self/limits").ok()?;
    let mut rows = Vec::<serde_json::Value>::new();
    for line in txt.lines().skip(1) {
        let cols: Vec<_> = line.split_whitespace().collect();
        if cols.len() >= 4 {
            rows.push(serde_json::json!({
                "resource": cols[0],
                "soft": cols[1],
                "hard": cols[2],
                "units": cols[3]
            }));
        }
    }
    Some(serde_json::to_string(&rows).unwrap_or_else(|_| "[]".into()))
}

#[cfg(not(target_os = "linux"))]
fn linux_proc_limits_json() -> Option<String> {
    None
}

// ## END ##

// ## FILE: src/commands/memory/mod.rs
// ## BEGIN ##
pub mod command;

// ## END ##

// ## FILE: src/commands/registry.rs
// ## BEGIN ##
use super::command::Command;
use crate::core::prelude::*;
use std::collections::HashMap;

pub struct CommandRegistry {
    commands: Vec<Box<dyn Command>>,
    name_map: HashMap<String, usize>,
    available_cache: std::sync::RwLock<Vec<usize>>, // Neu: Cache f√ºr verf√ºgbare Commands
    cache_dirty: std::sync::atomic::AtomicBool,     // Neu: Cache-Status
}

impl CommandRegistry {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
            name_map: HashMap::new(),
            available_cache: std::sync::RwLock::new(Vec::new()),
            cache_dirty: std::sync::atomic::AtomicBool::new(true),
        }
    }

    pub fn register<T>(&mut self, command: T) -> &mut Self
    where
        T: Into<Box<dyn Command>>,
    {
        let boxed = command.into();
        let name = boxed.name().to_lowercase();
        let index = self.commands.len();

        self.commands.push(boxed);
        self.name_map.insert(name, index);

        // Cache invalidieren
        self.cache_dirty
            .store(true, std::sync::atomic::Ordering::Release);

        self
    }

    pub fn find_command(&self, input: &str) -> Option<&dyn Command> {
        let input = input.trim().to_lowercase();

        // Exakte √úbereinstimmung (schnellster Pfad)
        if let Some(&index) = self.name_map.get(&input) {
            if let Some(cmd) = self.commands.get(index) {
                if cmd.is_available() {
                    return Some(cmd.as_ref());
                }
            }
        }

        // Cache-basierte Pattern-Matching
        self.update_available_cache_if_needed();

        if let Ok(cache) = self.available_cache.read() {
            for &index in cache.iter() {
                if let Some(cmd) = self.commands.get(index) {
                    if cmd.matches(&input) {
                        return Some(cmd.as_ref());
                    }
                }
            }
        }

        None
    }

    // Neue private Methode hinzuf√ºgen:
    fn update_available_cache_if_needed(&self) {
        if !self.cache_dirty.load(std::sync::atomic::Ordering::Acquire) {
            return;
        }

        if let Ok(mut cache) = self.available_cache.write() {
            cache.clear();
            for (index, cmd) in self.commands.iter().enumerate() {
                if cmd.is_available() {
                    cache.push(index);
                }
            }
            self.cache_dirty
                .store(false, std::sync::atomic::Ordering::Release);
        }
    }

    pub fn execute_sync(&self, command: &str, args: &[&str]) -> Option<Result<String>> {
        self.find_command(command).map(|cmd| cmd.execute_sync(args))
    }

    // src/commands/registry.rs
    pub async fn execute_async(&self, command: &str, args: &[&str]) -> Option<Result<String>> {
        match self.find_command(command) {
            Some(cmd) => Some(cmd.execute(args).await),
            None => None,
        }
    }

    // ‚úÖ OPTIMIERT: Iterator-Chain statt collect
    pub fn list_commands(&self) -> Vec<(&str, &str)> {
        self.update_available_cache_if_needed();

        if let Ok(cache) = self.available_cache.read() {
            cache
                .iter()
                .filter_map(|&index| {
                    self.commands
                        .get(index)
                        .map(|cmd| (cmd.name(), cmd.description()))
                })
                .collect()
        } else {
            // Fallback bei Lock-Fehler
            self.commands
                .iter()
                .filter(|cmd| cmd.is_available())
                .map(|cmd| (cmd.name(), cmd.description()))
                .collect()
        }
    }

    // ‚úÖ VEREINFACHT: Weniger Felder zu debuggen
    pub fn debug_info(&self) -> String {
        format!(
            "CommandRegistry: {} commands registered",
            self.commands.len()
        )
    }

    pub fn len(&self) -> usize {
        self.commands.len()
    }

    pub fn is_empty(&self) -> bool {
        self.commands.is_empty()
    }
}

impl Default for CommandRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// ‚úÖ AUTO-IMPL: Erm√∂glicht register(MyCommand::new()) und register(Box::new(MyCommand::new()))
impl<T: Command> From<T> for Box<dyn Command> {
    fn from(cmd: T) -> Self {
        Box::new(cmd)
    }
}

// ## END ##

// ## FILE: src/commands/handler.rs
// ## BEGIN ##
// =====================================================
// FILE: src/commands/handler.rs - PERFORMANCE & ROBUSTE VERSION
// =====================================================

use super::registry::CommandRegistry;
use crate::core::prelude::*;
use crate::i18n;
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct CommandResult {
    pub message: String,
    pub success: bool,
    pub should_exit: bool,
}

// ‚úÖ PERFORMANCE: Arc f√ºr shared Registry - keine Kopien bei Clone
pub struct CommandHandler {
    registry: Arc<CommandRegistry>,
}

impl CommandHandler {
    pub fn new() -> Self {
        Self {
            registry: Arc::new(crate::create_default_registry()),
        }
    }

    pub fn with_registry(registry: CommandRegistry) -> Self {
        Self {
            registry: Arc::new(registry),
        }
    }

    // ‚úÖ PERFORMANCE: Shared registry reference
    pub fn with_shared_registry(registry: Arc<CommandRegistry>) -> Self {
        Self { registry }
    }

    // ‚úÖ ROBUSTHEIT: Zentrale Input-Verarbeitung mit Error-Handling
    pub fn handle_input(&self, input: &str) -> CommandResult {
        self.process_input(input, false)
    }

    pub async fn handle_input_async(&self, input: &str) -> CommandResult {
        self.process_input_async(input).await
    }

    pub fn add_command<T: crate::commands::command::Command>(&mut self, command: T) -> Result<()> {
        if let Some(registry) = Arc::get_mut(&mut self.registry) {
            registry.register(command);
            Ok(())
        } else {
            // Registry ist geteilt - wir m√ºssen eine neue erstellen
            log::warn!("Registry is shared, creating new instance with added command");

            let mut new_registry = CommandRegistry::new();

            // Alle bestehenden Commands kopieren
            let existing_commands = self.registry.list_commands();
            for (name, _) in existing_commands {
                // TODO: Commands k√∂nnen nicht geklont werden - das ist ein Architektur-Problem
                log::warn!("Cannot copy existing command: {}", name);
            }

            // Neues Command hinzuf√ºgen
            new_registry.register(command);
            self.registry = Arc::new(new_registry);

            Err(AppError::Validation(
                "Registry was shared, created new instance".to_string(),
            ))
        }
    }

    pub fn list_commands(&self) -> Vec<(&str, &str)> {
        self.registry.list_commands()
    }

    pub fn debug_info(&self) -> String {
        self.registry.debug_info()
    }
}

// ‚úÖ PERFORMANCE & ROBUSTHEIT: Optimierte Core-Implementierung
impl CommandHandler {
    // ‚úÖ SHARED: Gemeinsame Logik f√ºr sync/async
    fn process_input(&self, input: &str, is_async: bool) -> CommandResult {
        // ‚úÖ PERFORMANCE: Early returns ohne Allokationen
        let input = input.trim();
        if input.is_empty() {
            return CommandResult::empty();
        }

        // ‚úÖ ROBUSTHEIT: Input-Validierung
        if input.len() > 1000 {
            log::warn!("Command input too long: {} chars", input.len());
            return CommandResult::error("Command input too long (max 1000 characters)");
        }

        // ‚úÖ PERFORMANCE: Single allocation f√ºr parts
        let parts = InputParser::parse(input);

        if is_async {
            log::debug!("Processing async command: '{}'", parts.command);
        } else {
            log::debug!("Processing sync command: '{}'", parts.command);
        }

        // ‚úÖ ROBUSTHEIT: Safe command execution
        match self.registry.execute_sync(parts.command, &parts.args) {
            Some(result) => self.process_command_result(result),
            None => self.create_unknown_command_result(input),
        }
    }

    // ‚úÖ ASYNC: Separate async path
    async fn process_input_async(&self, input: &str) -> CommandResult {
        let input = input.trim();
        if input.is_empty() {
            return CommandResult::empty();
        }

        if input.len() > 1000 {
            log::warn!("Async command input too long: {} chars", input.len());
            return CommandResult::error("Command input too long (max 1000 characters)");
        }

        let parts = InputParser::parse(input);
        log::debug!("Processing async command: '{}'", parts.command);

        match self
            .registry
            .execute_async(parts.command, &parts.args)
            .await
        {
            Some(result) => self.process_command_result(result),
            None => self.create_unknown_command_result(input),
        }
    }

    // ‚úÖ PERFORMANCE: Optimierte Result-Verarbeitung
    fn process_command_result(&self, result: Result<String>) -> CommandResult {
        match result {
            Ok(msg) => {
                // ‚úÖ PERFORMANCE: Conditional logging
                if log::log_enabled!(log::Level::Debug) {
                    self.log_command_success(&msg);
                }

                CommandResult {
                    message: msg.clone(),
                    success: true,
                    should_exit: ExitChecker::should_exit(&msg),
                }
            }
            Err(e) => {
                log::error!("Command execution failed: {}", e);
                CommandResult::error(&e.to_string())
            }
        }
    }

    // ‚úÖ PERFORMANCE: Cached unknown command message
    fn create_unknown_command_result(&self, input: &str) -> CommandResult {
        log::warn!("Unknown command: '{}'", input);
        CommandResult::error(&UnknownCommandCache::get_message(input))
    }

    // ‚úÖ PERFORMANCE: Optimiertes Logging
    fn log_command_success(&self, msg: &str) {
        let char_count = msg.chars().count();

        // Nur die L√§nge loggen ‚Äì kein Preview-Text
        log::debug!("Command returned {} chars", char_count);

        // Vollausgabe nur bei "gro√üen" Outputs wie mem info oder JSON
        if char_count > 500
            && (msg.starts_with("MEMORY SNAPSHOT") || msg.trim_start().starts_with('{'))
        {
            log::debug!("FULL COMMAND OUTPUT:\n{}", msg);
        }
    }
}

// ‚úÖ PERFORMANCE: Optimierte Input-Parsing
struct InputParser;

impl InputParser {
    fn parse(input: &str) -> ParsedInput<'_> {
        // Effizienter: Nur einmal splitten
        let parts: Vec<&str> = input.split_whitespace().collect();

        if parts.is_empty() {
            ParsedInput {
                command: "",
                args: Vec::new(),
            }
        } else {
            ParsedInput {
                command: parts[0],
                args: parts[1..].to_vec(),
            }
        }
    }
}

struct ParsedInput<'a> {
    command: &'a str,
    args: Vec<&'a str>,
}

// ‚úÖ PERFORMANCE: Static Exit-Checker ohne Allokationen
struct ExitChecker;

impl ExitChecker {
    const EXIT_PREFIXES: &'static [&'static str] = &[
        "__EXIT__",
        "__CONFIRM_EXIT__",
        "__RESTART__",
        "__CONFIRM_RESTART__",
    ];

    fn should_exit(message: &str) -> bool {
        Self::EXIT_PREFIXES
            .iter()
            .any(|&prefix| message.starts_with(prefix))
    }
}

// ‚úÖ PERFORMANCE: Cached i18n Messages
use std::sync::OnceLock;

struct UnknownCommandCache;

impl UnknownCommandCache {
    fn get_message(input: &str) -> String {
        static TEMPLATE: OnceLock<String> = OnceLock::new();

        let template = TEMPLATE
            .get_or_init(|| i18n::get_command_translation("system.commands.unknown", &["%INPUT%"]));

        template.replace("%INPUT%", input)
    }
}

// ‚úÖ ROBUSTHEIT: CommandResult Factory mit besseren Methoden
impl CommandResult {
    pub fn empty() -> Self {
        Self {
            message: String::new(),
            success: false,
            should_exit: false,
        }
    }

    pub fn success(message: String) -> Self {
        Self {
            message,
            success: true,
            should_exit: false,
        }
    }

    pub fn error(message: &str) -> Self {
        Self {
            message: message.to_string(),
            success: false,
            should_exit: false,
        }
    }

    pub fn exit(message: String) -> Self {
        Self {
            message,
            success: true,
            should_exit: true,
        }
    }

    // ‚úÖ UTILITY: Convenience checks
    pub fn is_success(&self) -> bool {
        self.success
    }

    pub fn is_error(&self) -> bool {
        !self.success
    }

    pub fn has_message(&self) -> bool {
        !self.message.is_empty()
    }
}

// ‚úÖ PERFORMANCE: Clone f√ºr CommandHandler ist jetzt g√ºnstig (nur Arc clone)
impl Clone for CommandHandler {
    fn clone(&self) -> Self {
        Self {
            registry: Arc::clone(&self.registry),
        }
    }
}

impl Default for CommandHandler {
    fn default() -> Self {
        Self::new()
    }
}

// ‚úÖ ROBUSTHEIT: Thread-safe shared handler
impl CommandHandler {
    pub fn create_shared() -> Arc<Self> {
        Arc::new(Self::new())
    }

    pub fn with_shared_handler(handler: Arc<Self>) -> Self {
        Self {
            registry: Arc::clone(&handler.registry),
        }
    }
}

// ## END ##

// ## FILE: src/commands/recovery/command.rs
// ## BEGIN ##
// NEW: src/commands/recovery/command.rs
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerStatus};
use crate::server::utils::port::is_port_available;

#[derive(Debug, Default)]
pub struct RecoveryCommand;

impl RecoveryCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for RecoveryCommand {
    fn name(&self) -> &'static str {
        "recover"
    }

    fn description(&self) -> &'static str {
        "Recover and fix server status inconsistencies"
    }

    fn matches(&self, command: &str) -> bool {
        let cmd = command.trim().to_lowercase();
        cmd.starts_with("recover") || cmd.starts_with("fix") || cmd == "status-fix"
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        let ctx = crate::server::shared::get_shared_context();

        match args.first() {
            Some(&"all") => Ok(self.recover_all_servers(ctx)),
            Some(&server_id) => Ok(self.recover_single_server(ctx, server_id)),
            None => Ok(self.auto_recover(ctx)),
        }
    }

    fn priority(&self) -> u8 {
        80 // Hohe Priorit√§t f√ºr Recovery
    }
}

impl RecoveryCommand {
    // ‚úÖ AUTO-RECOVERY: Analysiert und repariert alle inkonsistenten Server
    fn auto_recover(&self, ctx: &ServerContext) -> String {
        let mut fixes = Vec::new();
        let registry = crate::server::shared::get_persistent_registry();

        // 1. Handle-Status-Synchronisation
        let (orphaned_handles, missing_handles) = {
            let servers = ctx.servers.read().unwrap();
            let handles = ctx.handles.read().unwrap();

            // Handles ohne entsprechende Server (Orphaned)
            let orphaned: Vec<String> = handles
                .keys()
                .filter(|id| !servers.contains_key(*id))
                .cloned()
                .collect();

            // Running-Server ohne Handle (Missing)
            let missing: Vec<String> = servers
                .iter()
                .filter_map(|(id, server)| {
                    if server.status == ServerStatus::Running && !handles.contains_key(id) {
                        Some(id.clone())
                    } else {
                        None
                    }
                })
                .collect();

            (orphaned, missing)
        };

        // 2. Port-Status-Validierung
        let port_fixes = self.validate_and_fix_ports(ctx);
        fixes.extend(port_fixes);

        // 3. Orphaned Handles bereinigen
        if !orphaned_handles.is_empty() {
            let count = orphaned_handles.len();
            for handle_id in orphaned_handles {
                let mut handles = ctx.handles.write().unwrap();
                if let Some(handle) = handles.remove(&handle_id) {
                    // Handle graceful stoppen
                    tokio::spawn(async move {
                        let _ = handle.stop(true).await;
                    });
                }
            }
            fixes.push(format!("üßπ {} orphaned handles cleaned", count));
        }

        // 4. Missing Handles reparieren
        if !missing_handles.is_empty() {
            for server_id in &missing_handles {
                self.fix_missing_handle(ctx, &server_id);
            }
            fixes.push(format!(
                "üîß {} missing handles fixed",
                missing_handles.len()
            ));
        }

        // 5. Persistence synchronisieren
        tokio::spawn(async move {
            if let Ok(persistent_servers) = registry.load_servers().await {
                // Hier w√ºrde man die aktuelle Runtime-State in die Persistence schreiben
                let _ = registry.save_servers(&persistent_servers).await;
            }
        });

        if fixes.is_empty() {
            "‚úÖ All servers are in consistent state".to_string()
        } else {
            format!("üõ†Ô∏è Recovery completed:\n{}", fixes.join("\n"))
        }
    }

    // ‚úÖ EINZELNEN SERVER REPARIEREN
    fn recover_single_server(&self, ctx: &ServerContext, identifier: &str) -> String {
        let servers = ctx.servers.read().unwrap();

        // Server finden
        let server_info = match servers
            .values()
            .find(|s| s.id.starts_with(identifier) || s.name == identifier)
        {
            Some(server) => server.clone(),
            None => return format!("‚ùå Server '{}' not found", identifier),
        };

        drop(servers); // Lock freigeben

        let fixes = self.diagnose_and_fix_server(ctx, &server_info);

        if fixes.is_empty() {
            format!(
                "‚úÖ Server '{}' is already in consistent state",
                server_info.name
            )
        } else {
            format!(
                "üõ†Ô∏è Fixed server '{}':\n{}",
                server_info.name,
                fixes.join("\n")
            )
        }
    }

    // ‚úÖ ALLE SERVER DURCHGEHEN
    fn recover_all_servers(&self, ctx: &ServerContext) -> String {
        let mut total_fixes = Vec::new();
        let servers: Vec<_> = {
            let servers = ctx.servers.read().unwrap();
            servers.values().cloned().collect()
        };

        for server_info in servers {
            let fixes = self.diagnose_and_fix_server(ctx, &server_info);
            if !fixes.is_empty() {
                total_fixes.push(format!(
                    "Server '{}': {}",
                    server_info.name,
                    fixes.join(", ")
                ));
            }
        }

        if total_fixes.is_empty() {
            "‚úÖ All servers are in consistent state".to_string()
        } else {
            format!("üõ†Ô∏è Recovery results:\n{}", total_fixes.join("\n"))
        }
    }

    // ‚úÖ SERVER DIAGNOSE UND REPARATUR
    fn diagnose_and_fix_server(
        &self,
        ctx: &ServerContext,
        server_info: &crate::server::types::ServerInfo,
    ) -> Vec<String> {
        let mut fixes = Vec::new();

        // Handle-Status pr√ºfen
        let has_handle = {
            let handles = ctx.handles.read().unwrap();
            handles.contains_key(&server_info.id)
        };

        // Port-Status pr√ºfen
        let port_available = is_port_available(server_info.port);

        match (server_info.status, has_handle, port_available) {
            // INKONSISTENZ: Server soll laufen, aber kein Handle
            (ServerStatus::Running, false, _) => {
                if port_available {
                    // Port frei, aber Status Running ‚Üí Korrigieren zu Stopped
                    self.update_server_status(ctx, &server_info.id, ServerStatus::Stopped);
                    fixes.push("Status: Running ‚Üí Stopped (no handle, port free)".to_string());
                } else {
                    // Port belegt, Handle fehlt ‚Üí Neustart versuchen oder Failed setzen
                    self.update_server_status(ctx, &server_info.id, ServerStatus::Failed);
                    fixes.push("Status: Running ‚Üí Failed (no handle, port occupied)".to_string());
                }
            }

            // INKONSISTENZ: Server hat Handle, aber Status nicht Running
            (status, true, _) if status != ServerStatus::Running => {
                self.update_server_status(ctx, &server_info.id, ServerStatus::Running);
                fixes.push(format!("Status: {} ‚Üí Running (handle exists)", status));
            }

            // INKONSISTENZ: Server Failed, aber Port ist frei
            (ServerStatus::Failed, false, true) => {
                self.update_server_status(ctx, &server_info.id, ServerStatus::Stopped);
                fixes.push("Status: Failed ‚Üí Stopped (port now free)".to_string());
            }

            _ => {
                // Server ist konsistent
            }
        }

        fixes
    }

    // ‚úÖ PORT-VALIDIERUNG F√úR ALLE SERVER
    fn validate_and_fix_ports(&self, ctx: &ServerContext) -> Vec<String> {
        let mut fixes = Vec::new();
        let servers: Vec<_> = {
            let servers = ctx.servers.read().unwrap();
            servers.values().cloned().collect()
        };

        for server_info in servers {
            let port_available = is_port_available(server_info.port);
            let has_handle = {
                let handles = ctx.handles.read().unwrap();
                handles.contains_key(&server_info.id)
            };

            // Logik-Matrix f√ºr Port-Fixes
            match (server_info.status, has_handle, port_available) {
                (ServerStatus::Running, true, false) => {
                    // OK: Server l√§uft, Handle da, Port belegt
                }
                (ServerStatus::Running, false, false) => {
                    // Problem: Server soll laufen, aber kein Handle und Port belegt
                    self.update_server_status(ctx, &server_info.id, ServerStatus::Failed);
                    fixes.push(format!(
                        "Fixed '{}': Running ‚Üí Failed (orphaned)",
                        server_info.name
                    ));
                }
                (ServerStatus::Running, false, true) => {
                    // Problem: Server soll laufen, kein Handle, Port frei
                    self.update_server_status(ctx, &server_info.id, ServerStatus::Stopped);
                    fixes.push(format!(
                        "Fixed '{}': Running ‚Üí Stopped (no handle)",
                        server_info.name
                    ));
                }
                _ => {}
            }
        }

        fixes
    }

    // ‚úÖ MISSING HANDLE REPARIEREN
    fn fix_missing_handle(&self, ctx: &ServerContext, server_id: &str) {
        // Server auf Stopped setzen, da wir kein Handle haben
        self.update_server_status(ctx, server_id, ServerStatus::Stopped);

        // Async persistence update
        let server_id_clone = server_id.to_string();
        tokio::spawn(async move {
            crate::server::shared::persist_server_update(&server_id_clone, ServerStatus::Stopped)
                .await;
        });
    }

    // ‚úÖ STATUS UPDATE
    fn update_server_status(&self, ctx: &ServerContext, server_id: &str, status: ServerStatus) {
        if let Ok(mut servers) = ctx.servers.write() {
            if let Some(server) = servers.get_mut(server_id) {
                server.status = status;
            }
        }
    }
}

// ## END ##

// ## FILE: src/commands/recovery/mod.rs
// ## BEGIN ##
// src/commands/recovery/mod.rs
pub mod command;
pub use command::RecoveryCommand;

// ## END ##

// ## FILE: src/commands/command.rs
// ## BEGIN ##
use crate::core::prelude::*;

#[async_trait::async_trait]
pub trait Command: Send + Sync + std::fmt::Debug + 'static {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    fn matches(&self, command: &str) -> bool;

    // Hauptausf√ºhrung - immer implementieren
    async fn execute(&self, args: &[&str]) -> Result<String> {
        // Einfach & robust: vorhandene Sync-Logik nutzen
        self.execute_sync(args)
    }

    // Optional: Sync-Fallback f√ºr Commands die es brauchen
    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        // Default: Blockiert auf async execute
        futures::executor::block_on(self.execute(args))
    }

    fn priority(&self) -> u8 {
        50
    }
    fn is_available(&self) -> bool {
        true
    }
}

// ## END ##

// ## FILE: src/commands/start/command.rs
// ## BEGIN ##
// Enhanced src/commands/start/command.rs - RANGE & BULK SUPPORT
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerStatus};
use crate::server::utils::port::is_port_available;
use crate::server::utils::validation::find_server;
use opener;

#[derive(Debug, Default)]
pub struct StartCommand;

impl StartCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for StartCommand {
    fn name(&self) -> &'static str {
        "start"
    }
    fn description(&self) -> &'static str {
        "Start server(s) - supports ranges and bulk operations"
    }
    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("start")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        if args.is_empty() {
            return Err(AppError::Validation(
                "Server-ID/Name fehlt! Verwende 'start <ID>', 'start 1-3', 'start all'".to_string(),
            ));
        }

        let config = get_config()?;
        let ctx = crate::server::shared::get_shared_context();

        match self.parse_start_args(args) {
            StartMode::Single(identifier) => self.start_single_server(&config, ctx, &identifier),
            StartMode::Range(start, end) => self.start_range_servers(&config, ctx, start, end),
            StartMode::All => self.start_all_servers(&config, ctx),
            StartMode::Invalid(error) => Err(AppError::Validation(error)),
        }
    }

    fn priority(&self) -> u8 {
        66
    }
}

#[derive(Debug)]
enum StartMode {
    Single(String),
    Range(u32, u32),
    All,
    Invalid(String),
}

impl StartCommand {
    // Parse different start argument patterns
    fn parse_start_args(&self, args: &[&str]) -> StartMode {
        if args.len() != 1 {
            return StartMode::Invalid("Too many arguments".to_string());
        }

        let arg = args[0];

        // "start all"
        if arg.eq_ignore_ascii_case("all") {
            return StartMode::All;
        }

        // "start 1-3" or "start 001-005"
        if let Some((start_str, end_str)) = arg.split_once('-') {
            match (start_str.parse::<u32>(), end_str.parse::<u32>()) {
                (Ok(start), Ok(end)) => {
                    if start == 0 || end == 0 {
                        return StartMode::Invalid("Range indices must be > 0".to_string());
                    }
                    if start > end {
                        return StartMode::Invalid("Start must be <= end in range".to_string());
                    }
                    if end - start > 20 {
                        return StartMode::Invalid(
                            "Maximum 20 servers in range operation".to_string(),
                        );
                    }
                    StartMode::Range(start, end)
                }
                _ => StartMode::Single(arg.to_string()),
            }
        } else {
            // Single server by ID/name/number
            StartMode::Single(arg.to_string())
        }
    }

    // Start single server (existing robust logic)
    fn start_single_server(
        &self,
        config: &Config,
        ctx: &ServerContext,
        identifier: &str,
    ) -> Result<String> {
        let (server_info, existing_handle) =
            {
                let servers_guard = ctx.servers.read().map_err(|_| {
                    AppError::Validation("Server-Context lock poisoned".to_string())
                })?;

                let server_info = find_server(&servers_guard, identifier)?.clone();

                if server_info.status == ServerStatus::Running {
                    let handles_guard = ctx.handles.read().map_err(|_| {
                        AppError::Validation("Handle-Context lock poisoned".to_string())
                    })?;

                    if handles_guard.contains_key(&server_info.id) {
                        return Ok(format!(
                            "Server '{}' is already running on http://127.0.0.1:{}",
                            server_info.name, server_info.port
                        ));
                    }
                }

                let handles_guard = ctx.handles.read().map_err(|_| {
                    AppError::Validation("Handle-Context lock poisoned".to_string())
                })?;
                let existing_handle = handles_guard.get(&server_info.id).cloned();

                (server_info, existing_handle)
            };

        if let Some(_handle) = existing_handle {
            if server_info.status != ServerStatus::Running {
                self.update_server_status(ctx, &server_info.id, ServerStatus::Running);

                let server_id = server_info.id.clone();
                tokio::spawn(async move {
                    crate::server::shared::persist_server_update(&server_id, ServerStatus::Running)
                        .await;
                });
            }

            return Ok(format!(
                "Server '{}' is already running on http://127.0.0.1:{} (status corrected)",
                server_info.name, server_info.port
            ));
        }

        // Port validation
        match self.validate_port_safely(&server_info) {
            PortValidationResult::Available => {}
            PortValidationResult::OccupiedByUs => {
                return Ok(format!(
                    "Port {} wird bereits von unserem System verwendet",
                    server_info.port
                ));
            }
            PortValidationResult::OccupiedByOther => {
                return Ok(format!(
                    "Port {} ist von anderem Prozess belegt! Server '{}' bleibt gestoppt.",
                    server_info.port, server_info.name
                ));
            }
        }

        // Server limit check
        let running_count = self.count_running_servers(ctx);
        if running_count >= config.server.max_concurrent {
            return Err(AppError::Validation(format!(
                "Cannot start server: Running servers limit reached ({}/{})",
                running_count, config.server.max_concurrent
            )));
        }

        self.actually_start_server(config, ctx, server_info, running_count)
    }

    // Start servers by range (e.g., "start 1-3")
    fn start_range_servers(
        &self,
        config: &Config,
        ctx: &ServerContext,
        start: u32,
        end: u32,
    ) -> Result<String> {
        let mut results = Vec::new();
        let mut started_count = 0;
        let mut failed_count = 0;

        for i in start..=end {
            let identifier = format!("{}", i);

            match self.start_single_server(config, ctx, &identifier) {
                Ok(message) => {
                    if message.contains("successfully started") {
                        started_count += 1;
                        results.push(format!("Server {}: Started", i));
                    } else {
                        results.push(format!("Server {}: {}", i, message));
                    }
                }
                Err(e) => {
                    failed_count += 1;
                    results.push(format!("Server {}: Failed - {}", i, e));

                    // Stop on critical errors, continue on limit/port issues
                    if e.to_string().contains("limit reached") {
                        break;
                    }
                }
            }
        }

        let summary = format!(
            "Range start completed: {} started, {} failed (Range: {}-{})",
            started_count, failed_count, start, end
        );

        if results.is_empty() {
            Ok(summary)
        } else {
            Ok(format!("{}\n\nResults:\n{}", summary, results.join("\n")))
        }
    }

    // Start all stopped servers
    fn start_all_servers(&self, config: &Config, ctx: &ServerContext) -> Result<String> {
        let stopped_servers: Vec<_> = {
            let servers = ctx.servers.read().unwrap();
            servers
                .values()
                .filter(|s| s.status == ServerStatus::Stopped)
                .map(|s| (s.id.clone(), s.name.clone()))
                .collect()
        };

        if stopped_servers.is_empty() {
            return Ok("No stopped servers to start".to_string());
        }

        if stopped_servers.len() > 20 {
            return Err(AppError::Validation(
                "Too many servers to start at once (max 20). Use ranges instead.".to_string(),
            ));
        }

        let mut results = Vec::new();
        let mut started_count = 0;
        let mut failed_count = 0;

        for (server_id, server_name) in stopped_servers {
            match self.start_single_server(config, ctx, &server_id) {
                Ok(message) => {
                    if message.contains("successfully started") {
                        started_count += 1;
                        results.push(format!("{}: Started", server_name));
                    } else {
                        results.push(format!("{}: {}", server_name, message));
                    }
                }
                Err(e) => {
                    failed_count += 1;
                    results.push(format!("{}: Failed - {}", server_name, e));

                    if e.to_string().contains("limit reached") {
                        break;
                    }
                }
            }
        }

        let summary = format!(
            "Start all completed: {} started, {} failed",
            started_count, failed_count
        );

        Ok(format!("{}\n\nResults:\n{}", summary, results.join("\n")))
    }

    // Actually start the server (extracted from single server logic)
    fn actually_start_server(
        &self,
        config: &Config,
        ctx: &ServerContext,
        server_info: crate::server::types::ServerInfo,
        current_running_count: usize,
    ) -> Result<String> {
        match self.spawn_server(config, ctx, server_info.clone()) {
            Ok(handle) => {
                {
                    let mut handles = ctx.handles.write().unwrap();
                    handles.insert(server_info.id.clone(), handle);
                }

                self.update_server_status(ctx, &server_info.id, ServerStatus::Running);

                let server_id = server_info.id.clone();
                tokio::spawn(async move {
                    crate::server::shared::persist_server_update(&server_id, ServerStatus::Running)
                        .await;
                });

                let server_url = format!("http://127.0.0.1:{}", server_info.port);

                if config.server.auto_open_browser {
                    self.spawn_browser_opener(server_url.clone(), server_info.name.clone(), config);
                }

                Ok(format!(
                    "Server '{}' successfully started on {} [PERSISTENT] ({}/{} running){}",
                    server_info.name,
                    server_url,
                    current_running_count + 1,
                    config.server.max_concurrent,
                    if config.server.auto_open_browser {
                        " - Browser opening..."
                    } else {
                        ""
                    }
                ))
            }
            Err(e) => {
                self.update_server_status(ctx, &server_info.id, ServerStatus::Failed);

                let server_id = server_info.id.clone();
                tokio::spawn(async move {
                    crate::server::shared::persist_server_update(&server_id, ServerStatus::Failed)
                        .await;
                });

                Err(AppError::Validation(format!("Server start failed: {}", e)))
            }
        }
    }

    // Helper methods (unchanged from robust version)
    fn validate_port_safely(
        &self,
        server_info: &crate::server::types::ServerInfo,
    ) -> PortValidationResult {
        if is_port_available(server_info.port) {
            PortValidationResult::Available
        } else {
            match crate::server::utils::port::check_port_status(server_info.port) {
                crate::server::utils::port::PortStatus::Available => {
                    PortValidationResult::Available
                }
                crate::server::utils::port::PortStatus::OccupiedByUs => {
                    PortValidationResult::OccupiedByUs
                }
                crate::server::utils::port::PortStatus::OccupiedByOther => {
                    PortValidationResult::OccupiedByOther
                }
            }
        }
    }

    fn count_running_servers(&self, ctx: &ServerContext) -> usize {
        let servers = ctx.servers.read().unwrap();
        servers
            .values()
            .filter(|s| s.status == ServerStatus::Running)
            .count()
    }

    fn spawn_server(
        &self,
        config: &Config,
        ctx: &ServerContext,
        server_info: crate::server::types::ServerInfo,
    ) -> std::result::Result<actix_web::dev::ServerHandle, String> {
        crate::server::handlers::web::create_web_server(ctx, server_info, config)
    }

    fn spawn_browser_opener(&self, url: String, name: String, config: &Config) {
        let delay = config.server.startup_delay_ms.min(2000);
        tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(delay as u64)).await;
            if let Err(e) = opener::open(&url) {
                log::warn!("Failed to open browser for '{}': {}", name, e);
            }
        });
    }

    fn update_server_status(&self, ctx: &ServerContext, server_id: &str, status: ServerStatus) {
        if let Ok(mut servers) = ctx.servers.write() {
            if let Some(server) = servers.get_mut(server_id) {
                server.status = status;
            }
        }
    }
}

#[derive(Debug)]
enum PortValidationResult {
    Available,
    OccupiedByUs,
    OccupiedByOther,
}

// ## END ##

// ## FILE: src/commands/start/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::StartCommand;

// ## END ##

// ## FILE: src/commands/stop/command.rs
// ## BEGIN ##
// Enhanced src/commands/stop/command.rs - RANGE & BULK SUPPORT
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerStatus};
use crate::server::utils::validation::find_server;
use std::time::Duration;

#[derive(Debug, Default)]
pub struct StopCommand;

impl StopCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for StopCommand {
    fn name(&self) -> &'static str {
        "stop"
    }

    fn description(&self) -> &'static str {
        "Stop server(s) - supports ranges and bulk operations"
    }

    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("stop")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        if args.is_empty() {
            return Err(AppError::Validation(
                "Server-ID/Name fehlt! Verwende 'stop <ID>', 'stop 1-3', 'stop all'".to_string(),
            ));
        }

        let config = get_config()?;
        let ctx = crate::server::shared::get_shared_context();

        match self.parse_stop_args(args) {
            StopMode::Single(identifier) => self.stop_single_server(&config, ctx, &identifier),
            StopMode::Range(start, end) => self.stop_range_servers(&config, ctx, start, end),
            StopMode::All => self.stop_all_servers(&config, ctx),
            StopMode::Invalid(error) => Err(AppError::Validation(error)),
        }
    }

    fn priority(&self) -> u8 {
        67
    }
}

#[derive(Debug)]
enum StopMode {
    Single(String),
    Range(u32, u32),
    All,
    Invalid(String),
}

impl StopCommand {
    // Parse different stop argument patterns
    fn parse_stop_args(&self, args: &[&str]) -> StopMode {
        if args.len() != 1 {
            return StopMode::Invalid("Too many arguments".to_string());
        }

        let arg = args[0];

        // "stop all"
        if arg.eq_ignore_ascii_case("all") {
            return StopMode::All;
        }

        // "stop 1-3" or "stop 001-005"
        if let Some((start_str, end_str)) = arg.split_once('-') {
            match (start_str.parse::<u32>(), end_str.parse::<u32>()) {
                (Ok(start), Ok(end)) => {
                    if start == 0 || end == 0 {
                        return StopMode::Invalid("Range indices must be > 0".to_string());
                    }
                    if start > end {
                        return StopMode::Invalid("Start must be <= end in range".to_string());
                    }
                    if end - start > 20 {
                        return StopMode::Invalid(
                            "Maximum 20 servers in range operation".to_string(),
                        );
                    }
                    StopMode::Range(start, end)
                }
                _ => StopMode::Single(arg.to_string()),
            }
        } else {
            // Single server by ID/name/number
            StopMode::Single(arg.to_string())
        }
    }

    // Stop single server (enhanced from original)
    fn stop_single_server(
        &self,
        config: &Config,
        ctx: &ServerContext,
        identifier: &str,
    ) -> Result<String> {
        let (server_info, handle) = {
            let servers_guard = ctx
                .servers
                .read()
                .map_err(|_| AppError::Validation("Server-Context lock poisoned".to_string()))?;

            let server_info = find_server(&servers_guard, identifier)?.clone();

            if server_info.status != ServerStatus::Running {
                return Ok(format!(
                    "Server '{}' is not active (Status: {})",
                    server_info.name, server_info.status
                ));
            }

            // Handle atomisch entfernen
            let handle = {
                let mut handles_guard = ctx.handles.write().map_err(|_| {
                    AppError::Validation("Handle-Context lock poisoned".to_string())
                })?;
                handles_guard.remove(&server_info.id)
            };

            (server_info, handle)
        };

        log::info!(
            "Stopping server {} on port {}",
            server_info.id,
            server_info.port
        );

        // Status sofort auf "Stopped" setzen
        self.update_server_status(ctx, &server_info.id, ServerStatus::Stopped);

        // Browser-Benachrichtigung
        self.notify_browser_shutdown(&server_info);

        if let Some(handle) = handle {
            // Graceful shutdown
            self.shutdown_server_gracefully(handle, server_info.id.clone(), config);

            // Persistence update (nicht blockierend)
            let server_id = server_info.id.clone();
            tokio::spawn(async move {
                crate::server::shared::persist_server_update(&server_id, ServerStatus::Stopped)
                    .await;
            });

            // Kurze Pause f√ºr konsistente Timing
            std::thread::sleep(Duration::from_millis(
                config.server.startup_delay_ms.min(500),
            ));

            let running_count = {
                let servers = ctx.servers.read().unwrap_or_else(|e| {
                    log::warn!("Server lock poisoned: {}", e);
                    e.into_inner()
                });
                servers
                    .values()
                    .filter(|s| s.status == ServerStatus::Running)
                    .count()
            };

            Ok(format!(
                "Server '{}' stopped [PERSISTENT] ({}/{} running)",
                server_info.name, running_count, config.server.max_concurrent
            ))
        } else {
            // Handle war bereits weg - nur Status updaten
            let server_id = server_info.id.clone();
            tokio::spawn(async move {
                crate::server::shared::persist_server_update(&server_id, ServerStatus::Stopped)
                    .await;
            });

            Ok(format!(
                "Server '{}' was already stopped [PERSISTENT]",
                server_info.name
            ))
        }
    }

    // Stop servers by range (e.g., "stop 1-3")
    fn stop_range_servers(
        &self,
        config: &Config,
        ctx: &ServerContext,
        start: u32,
        end: u32,
    ) -> Result<String> {
        let mut results = Vec::new();
        let mut stopped_count = 0;
        let mut failed_count = 0;

        for i in start..=end {
            let identifier = format!("{}", i);

            match self.stop_single_server(config, ctx, &identifier) {
                Ok(message) => {
                    if message.contains("stopped [PERSISTENT]") {
                        stopped_count += 1;
                        results.push(format!("Server {}: Stopped", i));
                    } else {
                        results.push(format!("Server {}: {}", i, message));
                    }
                }
                Err(e) => {
                    failed_count += 1;
                    results.push(format!("Server {}: Failed - {}", i, e));
                }
            }
        }

        let summary = format!(
            "Range stop completed: {} stopped, {} failed (Range: {}-{})",
            stopped_count, failed_count, start, end
        );

        if results.is_empty() {
            Ok(summary)
        } else {
            Ok(format!("{}\n\nResults:\n{}", summary, results.join("\n")))
        }
    }

    // Stop all running servers
    fn stop_all_servers(&self, config: &Config, ctx: &ServerContext) -> Result<String> {
        let running_servers: Vec<_> = {
            let servers = ctx.servers.read().unwrap();
            servers
                .values()
                .filter(|s| s.status == ServerStatus::Running)
                .map(|s| (s.id.clone(), s.name.clone()))
                .collect()
        };

        if running_servers.is_empty() {
            return Ok("No running servers to stop".to_string());
        }

        if running_servers.len() > 20 {
            return Err(AppError::Validation(
                "Too many servers to stop at once (max 20). Use ranges instead.".to_string(),
            ));
        }

        let mut results = Vec::new();
        let mut stopped_count = 0;
        let mut failed_count = 0;

        // Stop servers in parallel for better performance
        let server_stops: Vec<_> = running_servers
            .into_iter()
            .map(|(server_id, server_name)| {
                match self.stop_single_server(config, ctx, &server_id) {
                    Ok(message) => {
                        if message.contains("stopped [PERSISTENT]") {
                            stopped_count += 1;
                            (server_name, "Stopped".to_string())
                        } else {
                            (server_name, message)
                        }
                    }
                    Err(e) => {
                        failed_count += 1;
                        (server_name, format!("Failed - {}", e))
                    }
                }
            })
            .collect();

        for (server_name, result) in server_stops {
            results.push(format!("{}: {}", server_name, result));
        }

        let summary = format!(
            "Stop all completed: {} stopped, {} failed",
            stopped_count, failed_count
        );

        Ok(format!("{}\n\nResults:\n{}", summary, results.join("\n")))
    }

    // Browser notification (from original)
    fn notify_browser_shutdown(&self, server_info: &crate::server::types::ServerInfo) {
        let server_port = server_info.port;
        let server_name = server_info.name.clone();

        tokio::spawn(async move {
            let server_url = format!("http://127.0.0.1:{}", server_port);
            log::info!(
                "Notifying browser to close for server {} (async)",
                server_name
            );

            let client = reqwest::Client::new();
            if let Err(e) = client
                .get(format!("{}/api/close-browser", server_url))
                .timeout(std::time::Duration::from_millis(300))
                .send()
                .await
            {
                log::warn!("Failed to notify browser: {}", e);
            }

            tokio::time::sleep(std::time::Duration::from_millis(500)).await;
        });
    }

    // Graceful shutdown (from original)
    fn shutdown_server_gracefully(
        &self,
        handle: actix_web::dev::ServerHandle,
        server_id: String,
        config: &Config,
    ) {
        let shutdown_timeout = config.server.shutdown_timeout;

        tokio::spawn(async move {
            use tokio::time::{timeout, Duration};

            match timeout(Duration::from_secs(shutdown_timeout), handle.stop(true)).await {
                Ok(_) => log::info!("Server {} stopped gracefully", server_id),
                Err(_) => {
                    log::warn!(
                        "Server {} shutdown timeout ({}s), forcing stop",
                        server_id,
                        shutdown_timeout
                    );
                    handle.stop(false).await;
                }
            }
        });
    }

    // Status update helper
    fn update_server_status(&self, ctx: &ServerContext, server_id: &str, status: ServerStatus) {
        if let Ok(mut servers) = ctx.servers.write() {
            if let Some(server) = servers.get_mut(server_id) {
                server.status = status;
            }
        }
    }
}

// ## END ##

// ## FILE: src/commands/stop/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::StopCommand;

// ## END ##

// ## FILE: src/commands/restart/command.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/restart/restart.rs - TRAIT IMPL
// =====================================================

use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::i18n::get_command_translation;

#[derive(Debug)]
pub struct RestartCommand;

impl Command for RestartCommand {
    fn name(&self) -> &'static str {
        "restart"
    }

    fn description(&self) -> &'static str {
        "Restart the application"
    }

    fn matches(&self, command: &str) -> bool {
        crate::matches_exact!(command, "restart" | "reboot" | "reset")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        match args.first() {
            Some(&"--help" | &"-h") => {
                Ok(get_command_translation("system.commands.restart.help", &[]))
            }
            Some(&"--force" | &"-f") => Ok("__RESTART_FORCE__".to_string()),
            None => {
                let msg = get_command_translation("system.commands.restart.confirm", &[]);
                Ok(format!("__CONFIRM:__RESTART__{}", msg))
            }
            _ => Ok(get_command_translation(
                "system.commands.restart.unknown",
                &[],
            )),
        }
    }

    fn priority(&self) -> u8 {
        90 // Sehr hohe Priorit√§t f√ºr System-Commands
    }
}

// ## END ##

// ## FILE: src/commands/restart/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::RestartCommand;

// ## END ##

// ## FILE: src/commands/clear/command.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/clear/clear.rs - TRAIT IMPL
// =====================================================

use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug)]
pub struct ClearCommand;

impl Command for ClearCommand {
    fn name(&self) -> &'static str {
        "clear"
    }

    fn description(&self) -> &'static str {
        "Clear the screen"
    }

    fn matches(&self, command: &str) -> bool {
        crate::matches_exact!(command, "clear" | "cls")
    }

    fn execute_sync(&self, _args: &[&str]) -> Result<String> {
        Ok("__CLEAR__".to_string())
    }

    fn priority(&self) -> u8 {
        80 // Sehr hohe Priorit√§t f√ºr Clear
    }
}

// ## END ##

// ## FILE: src/commands/clear/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::ClearCommand;

// ## END ##

// ## FILE: src/commands/lang/command.rs
// ## BEGIN ##
use super::LanguageService;
use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug)]
pub struct LanguageCommand {
    service: std::sync::Mutex<LanguageService>,
}

impl LanguageCommand {
    pub fn new() -> Self {
        Self {
            service: std::sync::Mutex::new(LanguageService::new()),
        }
    }
}

impl Command for LanguageCommand {
    fn name(&self) -> &'static str {
        "language"
    }

    fn description(&self) -> &'static str {
        "Change application language"
    }

    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("lang")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        let service = match self.service.lock() {
            Ok(guard) => guard,
            Err(poisoned) => {
                log::error!("Mutex poisoned, recovering...");
                poisoned.into_inner()
            }
        };

        match args.first() {
            None => Ok(service.show_status()),
            Some(&lang) => match service.switch_language_only(lang) {
                Ok(()) => {
                    let msg = crate::i18n::get_command_translation(
                        "system.commands.language.changed",
                        &[&lang.to_uppercase()],
                    );
                    Ok(service.create_save_message(lang, &msg))
                }
                Err(e) => Ok(crate::i18n::get_command_translation(
                    "system.commands.language.invalid",
                    &[&e.to_string()],
                )),
            },
        }
    }

    fn priority(&self) -> u8 {
        70
    }
}

impl Default for LanguageCommand {
    fn default() -> Self {
        Self::new()
    }
}

// ## END ##

// ## FILE: src/commands/lang/mod.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::i18n::{get_available_languages, get_current_language, set_language};

pub mod command;
pub use command::LanguageCommand;

#[derive(Debug)]
pub struct LanguageService {
    config_paths: Vec<std::path::PathBuf>,
}

impl LanguageService {
    pub fn new() -> Self {
        Self {
            config_paths: crate::setup::setup_toml::get_config_paths(),
        }
    }

    pub fn show_status(&self) -> String {
        let current_lang = get_current_language();
        let available_langs = get_available_languages().join(", ");

        let current = crate::i18n::get_command_translation(
            "system.commands.language.current",
            &[&current_lang],
        );
        let available = crate::i18n::get_command_translation(
            "system.commands.language.available",
            &[&available_langs],
        );

        format!("{}\n{}", current, available)
    }

    pub async fn change_language(&mut self, lang: &str) -> Result<String> {
        match set_language(lang) {
            Ok(()) => {
                if let Err(e) = self.save_to_config(lang).await {
                    log::error!("Failed to save language config: {}", e);
                }

                Ok(self.create_save_message(
                    lang,
                    &crate::i18n::get_command_translation(
                        "system.commands.language.changed",
                        &[&lang.to_uppercase()],
                    ),
                ))
            }
            Err(e) => Ok(crate::i18n::get_command_translation(
                "system.commands.language.invalid",
                &[&e.to_string()],
            )),
        }
    }

    pub fn switch_language_only(&self, lang: &str) -> Result<()> {
        set_language(lang)
    }

    pub async fn process_save_message(message: &str) -> Option<String> {
        if !message.starts_with("__SAVE_LANGUAGE__") {
            return None;
        }

        let parts: Vec<&str> = message.split("__MESSAGE__").collect();
        if parts.len() != 2 {
            return None;
        }

        let lang_part = parts[0].replace("__SAVE_LANGUAGE__", "");
        let display_message = parts[1];

        let service = LanguageService::new();
        if let Err(e) = service.save_to_config(&lang_part).await {
            log::error!("Failed to save language config: {}", e);
        }

        Some(display_message.to_string())
    }

    pub fn get_available(&self) -> Vec<String> {
        get_available_languages()
    }

    pub fn get_current(&self) -> String {
        get_current_language()
    }

    fn create_save_message(&self, lang: &str, display_text: &str) -> String {
        format!("__SAVE_LANGUAGE__{}__MESSAGE__{}", lang, display_text)
    }

    async fn save_to_config(&self, lang: &str) -> Result<()> {
        for path in &self.config_paths {
            if path.exists() {
                let content = tokio::fs::read_to_string(path)
                    .await
                    .map_err(AppError::Io)?;
                let updated_content = self.update_language_in_toml(&content, lang)?;
                tokio::fs::write(path, updated_content)
                    .await
                    .map_err(AppError::Io)?;
                return Ok(());
            }
        }
        Ok(())
    }

    fn update_language_in_toml(&self, content: &str, lang: &str) -> Result<String> {
        let updated_content = if content.contains("[language]") {
            content
                .lines()
                .map(|line| {
                    if line.trim_start().starts_with("current =") {
                        format!("current = \"{}\"", lang)
                    } else {
                        line.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("\n")
        } else {
            format!("{}\n\n[language]\ncurrent = \"{}\"", content.trim(), lang)
        };

        Ok(updated_content)
    }

    pub async fn load_from_config(&self) -> Option<String> {
        for path in &self.config_paths {
            if path.exists() {
                if let Ok(content) = tokio::fs::read_to_string(path).await {
                    if let Some(lang) = self.extract_language_from_toml(&content) {
                        return Some(lang);
                    }
                }
            }
        }
        None
    }

    fn extract_language_from_toml(&self, content: &str) -> Option<String> {
        let mut in_language_section = false;

        for line in content.lines() {
            let trimmed = line.trim();

            if trimmed == "[language]" {
                in_language_section = true;
                continue;
            }

            if trimmed.starts_with('[') && trimmed.ends_with(']') && trimmed != "[language]" {
                in_language_section = false;
                continue;
            }

            if in_language_section && trimmed.starts_with("current =") {
                if let Some(value_part) = trimmed.split('=').nth(1) {
                    let cleaned = value_part.trim().trim_matches('"').trim_matches('\'');
                    return Some(cleaned.to_string());
                }
            }
        }
        None
    }

    pub async fn load_and_apply_from_config(
        &self,
        config: &crate::core::config::Config,
    ) -> Result<()> {
        let lang = &config.language;

        if let Err(e) = crate::i18n::set_language(lang) {
            log::warn!(
                "{}",
                crate::i18n::get_translation(
                    "system.config.language_set_failed",
                    &[&e.to_string()]
                )
            );

            let _ = crate::i18n::set_language(crate::i18n::DEFAULT_LANGUAGE);
        }

        Ok(())
    }
}

impl Default for LanguageService {
    fn default() -> Self {
        Self::new()
    }
}

// ## END ##

// ## FILE: src/commands/mod.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/mod.rs - CLEAN VERSION OHNE UNN√ñTIGE PLUGINS
// =====================================================

pub mod cleanup;
pub mod clear;
pub mod command;
pub mod create;
pub mod exit;
pub mod handler;
pub mod help;
pub mod history;
pub mod lang;
pub mod list;
pub mod log_level;
pub mod memory;
pub mod recovery;
pub mod registry;
pub mod restart;
pub mod start;
pub mod stop;
pub mod theme;
pub mod version;

pub use cleanup::CleanupCommand;
pub use command::Command;
pub use create::CreateCommand;
pub use handler::CommandHandler;
pub use help::HelpCommand;
pub use list::ListCommand;
pub use recovery::RecoveryCommand;
pub use registry::CommandRegistry;
pub use start::StartCommand;
pub use stop::StopCommand;

// ## END ##

// ## FILE: src/commands/cleanup/command.rs
// ## BEGIN ##
// src/commands/cleanup/command.rs - FIXED f√ºr konsistenten i18n-Stil
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerStatus};

#[derive(Debug, Default)]
pub struct CleanupCommand;

impl CleanupCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for CleanupCommand {
    fn name(&self) -> &'static str {
        "cleanup"
    }

    fn description(&self) -> &'static str {
        "Clean up servers, logs, and www files - supports confirmation and force flags"
    }

    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("cleanup")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        let ctx = crate::server::shared::get_shared_context();

        match args.first() {
            // FIXED: Konsistente Verwendung von get_command_translation ohne .text Suffix
            Some(&"stopped") => {
                let msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.confirm_stopped",
                    &[],
                );
                Ok(format!(
                    "__CONFIRM:__CLEANUP__cleanup --force-stopped__{}",
                    msg
                ))
            }
            Some(&"failed") => {
                let msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.confirm_failed",
                    &[],
                );
                Ok(format!(
                    "__CONFIRM:__CLEANUP__cleanup --force-failed__{}",
                    msg
                ))
            }
            Some(&"logs") => {
                let msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.confirm_logs",
                    &[],
                );
                Ok(format!(
                    "__CONFIRM:__CLEANUP__cleanup --force-logs__{}",
                    msg
                ))
            }
            Some(&"all") => {
                let msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.confirm_all",
                    &[],
                );
                Ok(format!("__CONFIRM:__CLEANUP__cleanup --force-all__{}", msg))
            }
            Some(&"www") => {
                if let Some(&server_name) = args.get(1) {
                    let msg = crate::i18n::get_command_translation(
                        "system.commands.cleanup.confirm_www_server",
                        &[server_name],
                    );
                    Ok(format!(
                        "__CONFIRM:__CLEANUP__cleanup --force-www {}__{}",
                        server_name, msg
                    ))
                } else {
                    let msg = crate::i18n::get_command_translation(
                        "system.commands.cleanup.confirm_www_all",
                        &[],
                    );
                    Ok(format!("__CONFIRM:__CLEANUP__cleanup --force-www__{}", msg))
                }
            }
            None => {
                // Default: stopped cleanup with confirmation
                let msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.confirm_stopped",
                    &[],
                );
                Ok(format!(
                    "__CONFIRM:__CLEANUP__cleanup --force-stopped__{}",
                    msg
                ))
            }

            // Force-Commands (direct execution without confirmation)
            Some(&"--force-stopped") => Ok(self.cleanup_stopped_servers(ctx)),
            Some(&"--force-failed") => Ok(self.cleanup_failed_servers(ctx)),
            Some(&"--force-logs") => {
                tokio::spawn(async move {
                    match Self::cleanup_all_server_logs().await {
                        Ok(msg) => log::info!("Log cleanup result: {}", msg),
                        Err(e) => log::error!("Log cleanup failed: {}", e),
                    }
                });
                Ok(crate::i18n::get_command_translation(
                    "system.commands.cleanup.logs_started",
                    &[],
                ))
            }
            Some(&"--force-www") => {
                if let Some(&server_name) = args.get(1) {
                    let name = server_name.to_string();
                    tokio::spawn(async move {
                        match Self::cleanup_www_by_name(&name).await {
                            Ok(msg) => log::info!("WWW cleanup result: {}", msg),
                            Err(e) => log::error!("WWW cleanup failed: {}", e),
                        }
                    });
                    Ok(crate::i18n::get_command_translation(
                        "system.commands.cleanup.www_server_started",
                        &[server_name],
                    ))
                } else {
                    tokio::spawn(async move {
                        match Self::cleanup_www_directory().await {
                            Ok(msg) => log::info!("WWW cleanup result: {}", msg),
                            Err(e) => log::error!("WWW cleanup failed: {}", e),
                        }
                    });
                    Ok(crate::i18n::get_command_translation(
                        "system.commands.cleanup.www_all_started",
                        &[],
                    ))
                }
            }
            Some(&"--force-all") => {
                // Complete cleanup now includes WWW cleanup
                let stopped = self.cleanup_stopped_servers(ctx);
                let failed = self.cleanup_failed_servers(ctx);

                // Start async cleanup tasks for www and logs
                tokio::spawn(async move {
                    // WWW cleanup is now included in "all"
                    let www_cleanup = async {
                        match Self::cleanup_www_directory().await {
                            Ok(msg) => log::info!("WWW cleanup result: {}", msg),
                            Err(e) => log::error!("WWW cleanup failed: {}", e),
                        }
                    };

                    let log_cleanup = async {
                        match Self::cleanup_all_server_logs().await {
                            Ok(msg) => log::info!("Log cleanup result: {}", msg),
                            Err(e) => log::error!("Log cleanup failed: {}", e),
                        }
                    };

                    // Both tasks run concurrently
                    tokio::join!(www_cleanup, log_cleanup);
                });

                let async_cleanup_msg = crate::i18n::get_command_translation(
                    "system.commands.cleanup.async_started",
                    &[],
                );
                Ok(format!("{}\n{}\n{}", stopped, failed, async_cleanup_msg))
            }

            _ => Err(AppError::Validation(crate::i18n::get_command_translation(
                "system.commands.cleanup.usage",
                &[],
            ))),
        }
    }

    fn priority(&self) -> u8 {
        50
    }
}

impl CleanupCommand {
    // FIXED: Alle cleanup-Methoden nutzen jetzt konsistent get_command_translation
    fn cleanup_stopped_servers(&self, ctx: &ServerContext) -> String {
        let registry = crate::server::shared::get_persistent_registry();

        tokio::spawn(async move {
            if let Ok(_servers) = registry.load_servers().await {
                if let Ok((_updated_servers, removed_count)) = registry
                    .cleanup_servers(crate::server::persistence::CleanupType::Stopped)
                    .await
                {
                    if removed_count > 0 {
                        log::info!(
                            "Removed {} stopped servers from persistent registry",
                            removed_count
                        );
                    }
                }
            }
        });

        let mut servers = ctx.servers.write().unwrap();
        let initial_count = servers.len();
        servers.retain(|_, server| server.status != ServerStatus::Stopped);
        let removed_count = initial_count - servers.len();

        if removed_count > 0 {
            crate::i18n::get_command_translation(
                "system.commands.cleanup.stopped_success",
                &[&removed_count.to_string()],
            )
        } else {
            crate::i18n::get_command_translation("system.commands.cleanup.no_stopped", &[])
        }
    }

    fn cleanup_failed_servers(&self, ctx: &ServerContext) -> String {
        let registry = crate::server::shared::get_persistent_registry();

        tokio::spawn(async move {
            if let Ok(_servers) = registry.load_servers().await {
                if let Ok((_updated_servers, removed_count)) = registry
                    .cleanup_servers(crate::server::persistence::CleanupType::Failed)
                    .await
                {
                    if removed_count > 0 {
                        log::info!(
                            "Removed {} failed servers from persistent registry",
                            removed_count
                        );
                    }
                }
            }
        });

        let mut servers = ctx.servers.write().unwrap();
        let initial_count = servers.len();
        servers.retain(|_, server| server.status != ServerStatus::Failed);
        let removed_count = initial_count - servers.len();

        if removed_count > 0 {
            crate::i18n::get_command_translation(
                "system.commands.cleanup.failed_success",
                &[&removed_count.to_string()],
            )
        } else {
            crate::i18n::get_command_translation("system.commands.cleanup.no_failed", &[])
        }
    }

    // Alle async cleanup methods mit konsistenten i18n keys
    pub async fn cleanup_all_server_logs() -> Result<String> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let servers_dir = base_dir.join(".rss").join("servers");

        if !servers_dir.exists() {
            return Ok(crate::i18n::get_command_translation(
                "system.commands.cleanup.no_logs_dir",
                &[],
            ));
        }

        let mut deleted_files = 0;
        let mut total_size = 0u64;

        let mut entries = tokio::fs::read_dir(&servers_dir)
            .await
            .map_err(AppError::Io)?;

        while let Some(entry) = entries.next_entry().await.map_err(AppError::Io)? {
            let path = entry.path();

            if path.is_file() {
                if let Some(extension) = path.extension() {
                    if extension == "log" || extension == "gz" {
                        if let Ok(metadata) = tokio::fs::metadata(&path).await {
                            total_size += metadata.len();
                        }

                        tokio::fs::remove_file(&path).await.map_err(AppError::Io)?;
                        deleted_files += 1;

                        log::info!("Deleted log file: {}", path.display());
                    }
                }
            }
        }

        let size_mb = total_size / (1024 * 1024);

        Ok(crate::i18n::get_command_translation(
            "system.commands.cleanup.logs_success",
            &[&deleted_files.to_string(), &size_mb.to_string()],
        ))
    }

    pub async fn cleanup_www_directory() -> Result<String> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let www_dir = base_dir.join("www");

        if !www_dir.exists() {
            return Ok(crate::i18n::get_command_translation(
                "system.commands.cleanup.no_www_dir",
                &[],
            ));
        }

        let mut deleted_dirs = 0;
        let mut deleted_files = 0;
        let mut total_size = 0u64;

        let mut entries = tokio::fs::read_dir(&www_dir).await.map_err(AppError::Io)?;

        while let Some(entry) = entries.next_entry().await.map_err(AppError::Io)? {
            let path = entry.path();
            let metadata = tokio::fs::metadata(&path).await.map_err(AppError::Io)?;

            // Skip system files (starting with .)
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                if name.starts_with('.') {
                    continue;
                }
            }

            if metadata.is_dir() {
                total_size += Self::calculate_directory_size(&path).await.unwrap_or(0);
                tokio::fs::remove_dir_all(&path)
                    .await
                    .map_err(AppError::Io)?;
                deleted_dirs += 1;
                log::info!("Deleted directory: {}", path.display());
            } else if metadata.is_file() {
                total_size += metadata.len();
                tokio::fs::remove_file(&path).await.map_err(AppError::Io)?;
                deleted_files += 1;
                log::info!("Deleted file: {}", path.display());
            }
        }

        let size_mb = total_size / (1024 * 1024);

        Ok(crate::i18n::get_command_translation(
            "system.commands.cleanup.www_all_success",
            &[
                &deleted_dirs.to_string(),
                &deleted_files.to_string(),
                &size_mb.to_string(),
            ],
        ))
    }

    pub async fn cleanup_www_by_name(server_name: &str) -> Result<String> {
        let exe_path = std::env::current_exe().map_err(AppError::Io)?;
        let base_dir = exe_path.parent().ok_or_else(|| {
            AppError::Validation("Cannot determine executable directory".to_string())
        })?;

        let www_dir = base_dir.join("www");

        if !www_dir.exists() {
            return Ok(crate::i18n::get_command_translation(
                "system.commands.cleanup.no_www_for_server",
                &[server_name],
            ));
        }

        let mut deleted_dirs = 0;
        let mut total_size = 0u64;

        let mut entries = tokio::fs::read_dir(&www_dir).await.map_err(AppError::Io)?;

        while let Some(entry) = entries.next_entry().await.map_err(AppError::Io)? {
            let path = entry.path();
            let metadata = tokio::fs::metadata(&path).await.map_err(AppError::Io)?;

            if metadata.is_dir() {
                if let Some(dir_name) = path.file_name().and_then(|n| n.to_str()) {
                    if Self::matches_server_name(dir_name, server_name) {
                        total_size += Self::calculate_directory_size(&path).await.unwrap_or(0);
                        tokio::fs::remove_dir_all(&path)
                            .await
                            .map_err(AppError::Io)?;
                        deleted_dirs += 1;
                        log::info!("Deleted server directory: {}", path.display());
                    }
                }
            }
        }

        let size_mb = total_size / (1024 * 1024);

        if deleted_dirs > 0 {
            Ok(crate::i18n::get_command_translation(
                "system.commands.cleanup.www_server_success",
                &[server_name, &deleted_dirs.to_string(), &size_mb.to_string()],
            ))
        } else {
            Ok(crate::i18n::get_command_translation(
                "system.commands.cleanup.no_www_for_server",
                &[server_name],
            ))
        }
    }

    async fn calculate_directory_size(dir: &std::path::Path) -> Result<u64> {
        let mut total_size = 0u64;
        let mut stack = vec![dir.to_path_buf()];

        while let Some(current_dir) = stack.pop() {
            let mut entries = tokio::fs::read_dir(&current_dir)
                .await
                .map_err(AppError::Io)?;

            while let Some(entry) = entries.next_entry().await.map_err(AppError::Io)? {
                let metadata = entry.metadata().await.map_err(AppError::Io)?;

                if metadata.is_file() {
                    total_size += metadata.len();
                } else if metadata.is_dir() {
                    stack.push(entry.path());
                }
            }
        }

        Ok(total_size)
    }

    fn matches_server_name(dir_name: &str, server_name: &str) -> bool {
        if dir_name == server_name {
            return true;
        }

        if dir_name.starts_with(&format!("{}-[", server_name)) {
            return true;
        }

        if dir_name.contains(server_name) {
            if dir_name.contains('[') && dir_name.ends_with(']') {
                if let Some(bracket_start) = dir_name.rfind('[') {
                    if let Some(port_str) = dir_name.get(bracket_start + 1..dir_name.len() - 1) {
                        return port_str.parse::<u16>().is_ok();
                    }
                }
            }
        }

        false
    }
}

// ## END ##

// ## FILE: src/commands/cleanup/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::CleanupCommand;

// ## END ##

// ## FILE: src/commands/version/command.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/version/version.rs - TRAIT IMPL
// =====================================================

use crate::commands::command::Command;
use crate::core::constants::VERSION;
use crate::core::prelude::*;
use crate::i18n::get_command_translation;

#[derive(Debug)]
pub struct VersionCommand;

impl Command for VersionCommand {
    fn name(&self) -> &'static str {
        "version"
    }

    fn description(&self) -> &'static str {
        "Show application version"
    }

    fn matches(&self, command: &str) -> bool {
        crate::matches_exact!(command, "version" | "ver")
    }

    fn execute_sync(&self, _args: &[&str]) -> Result<String> {
        Ok(get_command_translation(
            "system.commands.version",
            &[VERSION],
        ))
    }

    fn priority(&self) -> u8 {
        40 // Standard Priorit√§t
    }
}

// ## END ##

// ## FILE: src/commands/version/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::VersionCommand;

// ## END ##

// ## FILE: src/commands/theme/command.rs
// ## BEGIN ##
// =====================================================
// FILE: src/commands/theme/command.rs - I18N VERSION
// =====================================================

use super::ThemeSystem;
use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug)]
pub struct ThemeCommand {
    theme_system: std::sync::Mutex<Option<ThemeSystem>>,
}

impl ThemeCommand {
    pub fn new() -> Self {
        Self {
            theme_system: std::sync::Mutex::new(None),
        }
    }

    fn get_or_init_theme_system(&self) -> Result<std::sync::MutexGuard<'_, Option<ThemeSystem>>> {
        let mut guard = self.theme_system.lock().unwrap_or_else(|poisoned| {
            log::warn!("Recovered from poisoned mutex");
            poisoned.into_inner()
        });
        if guard.is_none() {
            *guard = Some(ThemeSystem::load()?);
        }
        Ok(guard)
    }
}

impl Command for ThemeCommand {
    fn name(&self) -> &'static str {
        "theme"
    }

    fn description(&self) -> &'static str {
        "Change application theme (live update without restart, loaded from TOML)"
    }

    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("theme")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        log::info!("üé® ThemeCommand::execute_sync called with args: {:?}", args);

        // Theme-System laden mit i18n Error-Handling
        let mut guard = match self.get_or_init_theme_system() {
            Ok(guard) => {
                log::info!("‚úÖ ThemeSystem loaded successfully");
                guard
            }
            Err(e) => {
                log::error!("‚ùå ThemeSystem load failed: {}", e);
                return Ok(format!(
                    "{} {}\n\nüí° {}",
                    get_command_translation("system.commands.theme.load_failed", &[&e.to_string()]),
                    get_command_translation("system.commands.theme.no_themes_hint", &[]),
                    get_command_translation("system.commands.theme.add_sections_hint", &[])
                ));
            }
        };

        let theme_system = guard.as_mut().unwrap();

        match args.first() {
            None => {
                log::info!("üé® Calling theme_system.show_status()");
                let result = theme_system.show_status_i18n();
                log::info!("üé® show_status result: '{}'", result);
                Ok(result)
            }
            Some(&"--help" | &"-h") => {
                log::info!("üé® Calling create_help_text()");
                let result = Self::create_help_text_i18n(theme_system);
                log::info!(
                    "üé® create_help_text result length: {} chars",
                    result.chars().count()
                );
                Ok(result)
            }
            Some(&"debug") => match args.get(1) {
                Some(&theme_name) => Ok(theme_system.debug_theme_details_i18n(theme_name)),
                None => Ok(get_command_translation(
                    "system.commands.theme.debug_missing_name",
                    &[],
                )),
            },
            Some(&"preview") => match args.get(1) {
                Some(&theme_name) => theme_system.preview_theme_i18n(theme_name),
                None => Ok(get_command_translation(
                    "system.commands.theme.preview_missing_name",
                    &[],
                )),
            },
            Some(&theme_name) => {
                log::info!("üé® Calling change_theme({})", theme_name);
                theme_system.change_theme_i18n(theme_name)
            }
        }
    }

    fn priority(&self) -> u8 {
        65
    }
}

impl ThemeCommand {
    fn create_help_text_i18n(theme_system: &ThemeSystem) -> String {
        let available_themes = theme_system.get_available_names();

        if available_themes.is_empty() {
            return format!(
                "{}\n\n{}",
                get_command_translation("system.commands.theme.no_themes_available", &[]),
                get_command_translation("system.commands.theme.how_to_add_themes", &[])
            );
        }

        let themes_list = available_themes.join(", ");

        format!(
            "{}\n{}\n{}\n{}\n{}\n\n{}\n{}\n{}\n{}\n\n{}",
            get_command_translation("system.commands.theme.help.header", &[]),
            get_command_translation("system.commands.theme.help.show_themes", &[]),
            get_command_translation("system.commands.theme.help.select_theme", &[&themes_list]),
            get_command_translation("system.commands.theme.help.preview_theme", &[]),
            get_command_translation("system.commands.theme.help.show_help", &[]),
            get_command_translation("system.commands.theme.help.live_loaded", &[]),
            get_command_translation("system.commands.theme.help.cursor_config", &[]),
            get_command_translation("system.commands.theme.help.add_sections", &[]),
            get_command_translation("system.commands.theme.help.live_changes", &[]),
            get_command_translation("system.commands.theme.help.cursor_options", &[])
        )
    }
}

impl Default for ThemeCommand {
    fn default() -> Self {
        Self::new()
    }
}

// =====================================================
// ERWEITERTE THEMESYSTEM METHODEN MIT I18N
// =====================================================

impl ThemeSystem {
    pub fn show_status_i18n(&self) -> String {
        if self.themes.is_empty() {
            return get_command_translation("system.commands.theme.no_themes_found", &[]);
        }

        let themes_list = self.themes.keys().cloned().collect::<Vec<_>>().join(", ");
        get_command_translation(
            "system.commands.theme.current_status",
            &[&self.current_name.to_uppercase(), &themes_list],
        )
    }

    pub fn change_theme_i18n(&mut self, theme_name: &str) -> Result<String> {
        let theme_name_lower = theme_name.to_lowercase();

        if !self.themes.contains_key(&theme_name_lower) {
            return Ok(if self.themes.is_empty() {
                get_command_translation("system.commands.theme.no_themes_found", &[])
            } else {
                let available = self.themes.keys().cloned().collect::<Vec<_>>().join(", ");
                get_command_translation(
                    "system.commands.theme.not_found",
                    &[theme_name, &available],
                )
            });
        }

        self.current_name = theme_name_lower.clone();

        // Log cursor details
        if let Some(theme_def) = self.themes.get(&theme_name_lower) {
            log::info!(
                "üé® Theme '{}': input_cursor='{}' ({}), output_cursor='{}' ({}), prefix='{}'",
                theme_name_lower.to_uppercase(),
                theme_def.input_cursor,
                theme_def.input_cursor_color,
                theme_def.output_cursor,
                theme_def.output_cursor_color,
                theme_def.input_cursor_prefix
            );
        }

        // Async save
        let name_clone = theme_name_lower.clone();
        let paths_clone = self.config_paths.clone();
        tokio::spawn(async move {
            if let Err(e) = Self::save_current_theme_to_config(&paths_clone, &name_clone).await {
                log::error!("Failed to save theme: {}", e);
            }
        });

        Ok(format!(
            "__LIVE_THEME_UPDATE__{}__MESSAGE__{}",
            theme_name_lower,
            get_command_translation(
                "system.commands.theme.changed_success",
                &[&theme_name_lower.to_uppercase()]
            )
        ))
    }

    pub fn preview_theme_i18n(&self, theme_name: &str) -> Result<String> {
        let theme_name_lower = theme_name.to_lowercase();

        if let Some(theme_def) = self.themes.get(&theme_name_lower) {
            Ok(get_command_translation(
                "system.commands.theme.preview_details",
                &[
                    &theme_name_lower.to_uppercase(),
                    &theme_def.input_text,
                    &theme_def.input_bg,
                    &theme_def.output_text,
                    &theme_def.output_bg,
                    &theme_def.input_cursor_prefix,
                    &theme_def.input_cursor_color,
                    &theme_def.input_cursor,
                    &theme_def.output_cursor,
                    &theme_def.output_cursor_color,
                    &theme_name_lower,
                ],
            ))
        } else {
            let available = self.themes.keys().cloned().collect::<Vec<_>>().join(", ");
            Ok(get_command_translation(
                "system.commands.theme.not_found",
                &[theme_name, &available],
            ))
        }
    }

    pub fn debug_theme_details_i18n(&self, theme_name: &str) -> String {
        if let Some(theme_def) = self.themes.get(&theme_name.to_lowercase()) {
            get_command_translation(
                "system.commands.theme.debug_details",
                &[
                    &theme_name.to_uppercase(),
                    &theme_def.input_text,
                    &theme_def.input_bg,
                    &theme_def.output_text,
                    &theme_def.output_bg,
                    &theme_def.input_cursor_prefix,
                    &theme_def.input_cursor_color,
                    &theme_def.input_cursor,
                    &theme_def.output_cursor,
                    &theme_def.output_cursor_color,
                ],
            )
        } else {
            get_command_translation("system.commands.theme.debug_not_found", &[theme_name])
        }
    }
}

// ## END ##

// ## FILE: src/commands/theme/mod.rs
// ## BEGIN ##
use crate::core::prelude::*;
use std::collections::HashMap;

pub mod command;
pub use command::ThemeCommand;

#[derive(Debug, Clone)]
pub struct ThemeDefinition {
    pub input_text: String,
    pub input_bg: String,
    pub output_text: String,
    pub output_bg: String,
    pub input_cursor_prefix: String,
    pub input_cursor_color: String,
    pub input_cursor: String,
    pub output_cursor: String,
    pub output_cursor_color: String,
}

#[derive(Debug)]
pub struct ThemeSystem {
    themes: HashMap<String, ThemeDefinition>,
    current_name: String,
    config_paths: Vec<std::path::PathBuf>,
}

impl ThemeSystem {
    pub fn load() -> Result<Self> {
        let config_paths = crate::setup::setup_toml::get_config_paths();
        let themes = Self::load_themes_from_paths(&config_paths)?;
        let current_name = Self::load_current_theme_name(&config_paths).unwrap_or_else(|| {
            themes
                .keys()
                .next()
                .cloned()
                .unwrap_or_else(|| "default".to_string())
        });

        log::info!(
            "‚úÖ {} Themes loaded: {}",
            themes.len(),
            themes.keys().cloned().collect::<Vec<_>>().join(", ")
        );

        Ok(Self {
            themes,
            current_name,
            config_paths,
        })
    }

    pub fn show_status(&self) -> String {
        if self.themes.is_empty() {
            return "‚ùå No themes available! Add [theme.xyz] sections to rush.toml.".to_string();
        }
        format!(
            "Current theme: {} (from TOML)\nAvailable: {}",
            self.current_name.to_uppercase(),
            self.themes.keys().cloned().collect::<Vec<_>>().join(", ")
        )
    }

    pub fn change_theme(&mut self, theme_name: &str) -> Result<String> {
        let theme_name_lower = theme_name.to_lowercase();

        if !self.themes.contains_key(&theme_name_lower) {
            return Ok(if self.themes.is_empty() {
                "‚ùå No themes available! Add [theme.xyz] sections to rush.toml.".to_string()
            } else {
                format!(
                    "‚ùå Theme '{}' not found. Available: {}",
                    theme_name,
                    self.themes.keys().cloned().collect::<Vec<_>>().join(", ")
                )
            });
        }

        self.current_name = theme_name_lower.clone();

        // Log cursor details
        if let Some(theme_def) = self.themes.get(&theme_name_lower) {
            log::info!(
                "üé® Theme '{}': input_cursor='{}' ({}), output_cursor='{}' ({}), prefix='{}'",
                theme_name_lower.to_uppercase(),
                theme_def.input_cursor,
                theme_def.input_cursor_color,
                theme_def.output_cursor,
                theme_def.output_cursor_color,
                theme_def.input_cursor_prefix
            );
        }

        // Async save
        let name_clone = theme_name_lower.clone();
        let paths_clone = self.config_paths.clone();
        tokio::spawn(async move {
            if let Err(e) = Self::save_current_theme_to_config(&paths_clone, &name_clone).await {
                log::error!("Failed to save theme: {}", e);
            }
        });

        Ok(format!(
            "__LIVE_THEME_UPDATE__{}__MESSAGE__üé® Theme changed to: {} ‚ú®",
            theme_name_lower,
            theme_name_lower.to_uppercase()
        ))
    }

    pub fn preview_theme(&self, theme_name: &str) -> Result<String> {
        let theme_name_lower = theme_name.to_lowercase();

        if let Some(theme_def) = self.themes.get(&theme_name_lower) {
            Ok(format!("üé® Theme '{}' Preview:\nInput: {} on {}\nOutput: {} on {}\nCursor Prefix: '{}' in {}\nInput Cursor: {}\nOutput Cursor: {} in {}\n\nüìÅ Source: [theme.{}] in rush.toml",
                theme_name_lower.to_uppercase(), theme_def.input_text, theme_def.input_bg,
                theme_def.output_text, theme_def.output_bg, theme_def.input_cursor_prefix,
                theme_def.input_cursor_color, theme_def.input_cursor, theme_def.output_cursor,
                theme_def.output_cursor_color, theme_name_lower))
        } else {
            Ok(format!(
                "‚ùå Theme '{}' not found. Available: {}",
                theme_name,
                self.themes.keys().cloned().collect::<Vec<_>>().join(", ")
            ))
        }
    }

    pub fn debug_theme_details(&self, theme_name: &str) -> String {
        if let Some(theme_def) = self.themes.get(&theme_name.to_lowercase()) {
            format!("üîç Theme '{}':\ninput_text: '{}'\ninput_bg: '{}'\noutput_text: '{}'\noutput_bg: '{}'\ninput_cursor_prefix: '{}'\ninput_cursor_color: '{}'\ninput_cursor: '{}'\noutput_cursor: '{}'\noutput_cursor_color: '{}'",
                theme_name.to_uppercase(), theme_def.input_text, theme_def.input_bg,
                theme_def.output_text, theme_def.output_bg, theme_def.input_cursor_prefix,
                theme_def.input_cursor_color, theme_def.input_cursor, theme_def.output_cursor,
                theme_def.output_cursor_color)
        } else {
            format!("‚ùå Theme '{}' not found!", theme_name)
        }
    }

    // Getters
    pub fn theme_exists(&self, theme_name: &str) -> bool {
        self.themes.contains_key(&theme_name.to_lowercase())
    }
    pub fn get_theme(&self, theme_name: &str) -> Option<&ThemeDefinition> {
        self.themes.get(&theme_name.to_lowercase())
    }
    pub fn get_available_names(&self) -> Vec<String> {
        let mut names: Vec<_> = self.themes.keys().cloned().collect();
        names.sort();
        names
    }
    pub fn get_current_name(&self) -> &str {
        &self.current_name
    }

    fn load_themes_from_paths(
        config_paths: &[std::path::PathBuf],
    ) -> Result<HashMap<String, ThemeDefinition>> {
        for path in config_paths {
            if path.exists() {
                if let Ok(content) = std::fs::read_to_string(path) {
                    if let Ok(themes) = Self::parse_themes_from_toml(&content) {
                        return Ok(themes);
                    }
                }
            }
        }
        Ok(HashMap::new())
    }

    fn parse_themes_from_toml(content: &str) -> Result<HashMap<String, ThemeDefinition>> {
        let mut themes = HashMap::new();
        let mut current_theme: Option<String> = None;
        let mut current_data = HashMap::new();

        for line in content.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.starts_with('#') {
                continue;
            }

            if let Some(theme_name) = trimmed
                .strip_prefix("[theme.")
                .and_then(|s| s.strip_suffix(']'))
            {
                Self::finalize_theme(&mut themes, current_theme.take(), &mut current_data);
                current_theme = Some(theme_name.to_lowercase());
            } else if trimmed.starts_with('[') && !trimmed.starts_with("[theme.") {
                Self::finalize_theme(&mut themes, current_theme.take(), &mut current_data);
            } else if current_theme.is_some() && trimmed.contains('=') {
                if let Some((key, value)) = trimmed.split_once('=') {
                    let clean_value = value.trim().trim_matches('"').trim_matches('\'');
                    if !clean_value.is_empty() {
                        current_data.insert(key.trim().to_string(), clean_value.to_string());
                    }
                }
            }
        }
        Self::finalize_theme(&mut themes, current_theme, &mut current_data);
        Ok(themes)
    }

    fn finalize_theme(
        themes: &mut HashMap<String, ThemeDefinition>,
        theme_name: Option<String>,
        data: &mut HashMap<String, String>,
    ) {
        if let Some(name) = theme_name {
            if let Some(theme_def) = Self::build_theme_from_data(data) {
                themes.insert(name, theme_def);
            }
            data.clear();
        }
    }

    fn build_theme_from_data(data: &HashMap<String, String>) -> Option<ThemeDefinition> {
        Some(ThemeDefinition {
            input_text: data.get("input_text")?.clone(),
            input_bg: data.get("input_bg")?.clone(),
            output_text: data.get("output_text")?.clone(),
            output_bg: data.get("output_bg")?.clone(),
            input_cursor_prefix: data
                .get("input_cursor_prefix")
                .or(data.get("prompt_text"))
                .unwrap_or(&"/// ".to_string())
                .clone(),
            input_cursor_color: data
                .get("input_cursor_color")
                .or(data.get("prompt_color"))
                .unwrap_or(&"LightBlue".to_string())
                .clone(),
            input_cursor: data
                .get("input_cursor")
                .or(data.get("prompt_cursor"))
                .unwrap_or(&"PIPE".to_string())
                .clone(),
            output_cursor: data
                .get("output_cursor")
                .unwrap_or(&"PIPE".to_string())
                .clone(),
            output_cursor_color: data
                .get("output_cursor_color")
                .or(data.get("output_color"))
                .unwrap_or(&"White".to_string())
                .clone(),
        })
    }

    fn load_current_theme_name(config_paths: &[std::path::PathBuf]) -> Option<String> {
        for path in config_paths {
            if path.exists() {
                if let Ok(content) = std::fs::read_to_string(path) {
                    if let Some(theme) = Self::extract_current_theme_from_toml(&content) {
                        return Some(theme);
                    }
                }
            }
        }
        None
    }

    fn extract_current_theme_from_toml(content: &str) -> Option<String> {
        let mut in_general = false;
        for line in content.lines() {
            let trimmed = line.trim();
            if trimmed == "[general]" {
                in_general = true;
            } else if trimmed.starts_with('[') {
                in_general = false;
            } else if in_general && trimmed.starts_with("current_theme") {
                return trimmed
                    .split('=')
                    .nth(1)?
                    .trim()
                    .trim_matches('"')
                    .trim_matches('\'')
                    .to_string()
                    .into();
            }
        }
        None
    }

    async fn save_current_theme_to_config(
        config_paths: &[std::path::PathBuf],
        theme_name: &str,
    ) -> Result<()> {
        for path in config_paths {
            if path.exists() {
                let content = tokio::fs::read_to_string(path)
                    .await
                    .map_err(AppError::Io)?;
                let updated = Self::update_current_theme_in_toml(&content, theme_name)?;
                tokio::fs::write(path, updated)
                    .await
                    .map_err(AppError::Io)?;
                return Ok(());
            }
        }
        Err(AppError::Validation("No config file found".to_string()))
    }

    fn update_current_theme_in_toml(content: &str, theme_name: &str) -> Result<String> {
        let mut lines: Vec<String> = content.lines().map(|l| l.to_string()).collect();
        let mut in_general = false;
        let mut updated = false;

        for line in lines.iter_mut() {
            let trimmed = line.trim();
            if trimmed == "[general]" {
                in_general = true;
            } else if trimmed.starts_with('[') {
                in_general = false;
            } else if in_general && trimmed.starts_with("current_theme") {
                *line = format!("current_theme = \"{}\"", theme_name);
                updated = true;
            }
        }

        if !updated {
            if let Some(general_idx) = lines.iter().position(|line| line.trim() == "[general]") {
                let insert_idx = lines
                    .iter()
                    .enumerate()
                    .skip(general_idx + 1)
                    .find(|(_, line)| line.trim().starts_with('['))
                    .map(|(idx, _)| idx)
                    .unwrap_or(lines.len());
                lines.insert(insert_idx, format!("current_theme = \"{}\"", theme_name));
            }
        }
        Ok(lines.join("\n"))
    }
}

// ## END ##

// ## FILE: src/commands/list/command.rs
// ## BEGIN ##
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerStatus};

#[derive(Debug, Default)]
pub struct ListCommand;

impl ListCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for ListCommand {
    fn name(&self) -> &'static str {
        "list"
    }
    fn description(&self) -> &'static str {
        "List all web servers (persistent)"
    }
    fn matches(&self, command: &str) -> bool {
        let cmd = command.trim().to_lowercase();
        cmd == "list" || cmd == "list servers" || cmd == "list server"
    }

    fn execute_sync(&self, _args: &[&str]) -> Result<String> {
        let ctx = crate::server::shared::get_shared_context();
        Ok(self.list_servers(ctx))
    }

    fn priority(&self) -> u8 {
        60
    }
}

impl ListCommand {
    fn list_servers(&self, ctx: &ServerContext) -> String {
        let registry = crate::server::shared::get_persistent_registry();
        let servers = ctx.servers.read().unwrap();

        if servers.is_empty() {
            return format!(
                "Keine Server erstellt. Verwende 'create'\nRegistry: {}",
                registry.get_file_path().display() // FIX: get_file_path() verwenden
            );
        }

        let mut result = String::from("Server Liste (Persistent):\n");
        let mut server_list: Vec<_> = servers.values().collect();
        server_list.sort_by(|a, b| a.created_timestamp.cmp(&b.created_timestamp));

        for (i, server) in server_list.iter().enumerate() {
            let status_icon = match server.status {
                ServerStatus::Running => "Running",
                ServerStatus::Stopped => "Stopped",
                ServerStatus::Failed => "Failed",
            };

            result.push_str(&format!(
                "  {}. {} - {} (Port: {}) [{}]\n",
                i + 1,
                server.name,
                &server.id[0..8],
                server.port,
                status_icon
            ));
        }

        result.push_str(&format!(
            "\nRegistry: {}",
            registry.get_file_path().display() // FIX: get_file_path() verwenden
        ));

        result
    }
}

// ## END ##

// ## FILE: src/commands/list/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::ListCommand;

// ## END ##

// ## FILE: src/commands/history/events.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/history/events.rs
// =====================================================

#[derive(Debug, Clone, PartialEq)]
pub enum HistoryEvent {
    Clear,
    Add(String),
    NavigatePrevious,
    NavigateNext,
    ResetPosition,
}

pub struct HistoryEventHandler;

impl HistoryEventHandler {
    pub fn handle_command_result(result: &str) -> Option<HistoryEvent> {
        match result {
            "__CLEAR_HISTORY__" => Some(HistoryEvent::Clear),
            _ => None,
        }
    }

    pub fn create_clear_response() -> String {
        crate::i18n::get_translation("system.input.history_cleared", &[])
    }
}

// ## END ##

// ## FILE: src/commands/history/config.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/history/config.rs
// =====================================================

use crate::core::prelude::*;

#[derive(Debug, Clone)]
pub struct HistoryConfig {
    pub max_entries: usize,
    pub save_duplicates: bool,
    pub save_empty: bool,
}

impl HistoryConfig {
    pub fn from_main_config(config: &Config) -> Self {
        Self {
            max_entries: config.max_history,
            save_duplicates: false,
            save_empty: false,
        }
    }
}

impl Default for HistoryConfig {
    fn default() -> Self {
        Self {
            max_entries: 30,
            save_duplicates: false,
            save_empty: false,
        }
    }
}

// ## END ##

// ## FILE: src/commands/history/command.rs
// ## BEGIN ##
use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug)]
pub struct HistoryCommand;

impl Command for HistoryCommand {
    fn name(&self) -> &'static str {
        "history"
    }

    fn description(&self) -> &'static str {
        "Manage command history"
    }

    fn matches(&self, command: &str) -> bool {
        command.trim().starts_with("history")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        match args.first() {
            // ‚úÖ NEU: Best√§tigungssystem f√ºr -c/--clear
            Some(&"-c" | &"--clear") => {
                let msg = get_command_translation("system.commands.history.confirm_clear", &[]);
                Ok(format!("__CONFIRM:__CLEAR_HISTORY__{}", msg))
            }

            // ‚úÖ NEU: --force f√ºr direktes L√∂schen ohne Best√§tigung
            Some(&"--force-clear" | &"-fc") => Ok("__CLEAR_HISTORY__".to_string()),

            Some(&"-h" | &"--help") => {
                Ok(get_command_translation("system.commands.history.help", &[]))
            }

            _ => Ok(get_command_translation(
                "system.commands.history.usage",
                &[],
            )),
        }
    }

    fn priority(&self) -> u8 {
        60
    }
}

// ## END ##

// ## FILE: src/commands/history/manager.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/history/manager.rs - FINAL VERSION (ohne Debug)
// =====================================================

use std::path::PathBuf;

#[derive(Debug)]
pub struct HistoryManager {
    entries: Vec<String>,
    position: Option<usize>,
    max_size: usize,
    file_path: PathBuf,
}

impl HistoryManager {
    pub fn new(max_size: usize) -> Self {
        let file_path = Self::get_history_path();

        let mut manager = Self {
            entries: Vec::with_capacity(max_size),
            position: None,
            max_size,
            file_path,
        };

        // Lade sofort beim Erstellen
        manager.load_from_file();
        manager
    }

    fn get_history_path() -> PathBuf {
        if let Ok(exe_path) = std::env::current_exe() {
            if let Some(base_dir) = exe_path.parent() {
                let history_path = base_dir.join(".rss").join("rush.history");

                // Erstelle Verzeichnis falls nicht vorhanden
                if let Some(parent) = history_path.parent() {
                    let _ = std::fs::create_dir_all(parent);
                }

                return history_path;
            }
        }
        PathBuf::from("rush.history") // Fallback
    }

    fn load_from_file(&mut self) {
        if !self.file_path.exists() {
            return;
        }

        if let Ok(content) = std::fs::read_to_string(&self.file_path) {
            for line in content.lines() {
                let trimmed = line.trim();
                if !trimmed.is_empty() && !self.entries.contains(&trimmed.to_string()) {
                    self.entries.push(trimmed.to_string());
                }
            }

            // Limitiere auf max_size
            if self.entries.len() > self.max_size {
                self.entries.drain(0..self.entries.len() - self.max_size);
            }

            log::info!("üìÅ Loaded {} history entries", self.entries.len());
        }
    }

    fn save_to_file(&self) {
        let content = self.entries.join("\n");
        if let Err(e) = std::fs::write(&self.file_path, content) {
            log::error!("Failed to save history: {}", e);
        }
    }

    pub fn add_entry(&mut self, entry: String) {
        if entry.trim().is_empty() {
            return;
        }

        // Entferne Duplikate
        self.entries.retain(|e| e != &entry);

        // F√ºge am Ende hinzu
        if self.entries.len() >= self.max_size {
            self.entries.remove(0);
        }

        self.entries.push(entry);
        self.position = None;

        // Speichere sofort
        self.save_to_file();
    }

    pub fn navigate_previous(&mut self) -> Option<String> {
        if let Some(pos) = self.position {
            if pos > 0 {
                self.position = Some(pos - 1);
                return self.entries.get(pos - 1).cloned();
            }
        } else if !self.entries.is_empty() {
            self.position = Some(self.entries.len() - 1);
            return self.entries.last().cloned();
        }
        None
    }

    pub fn navigate_next(&mut self) -> Option<String> {
        if let Some(pos) = self.position {
            if pos < self.entries.len() - 1 {
                self.position = Some(pos + 1);
                return self.entries.get(pos + 1).cloned();
            } else {
                self.position = None;
                return Some(String::new()); // Empty = clear input
            }
        }
        None
    }

    pub fn clear(&mut self) {
        self.entries.clear();
        self.position = None;

        // L√∂sche Datei
        let _ = std::fs::remove_file(&self.file_path);
        log::info!("üìÅ History cleared");
    }

    pub fn reset_position(&mut self) {
        self.position = None;
    }

    pub fn get_all_entries(&self) -> Vec<String> {
        self.entries.clone()
    }

    pub fn import_entries(&mut self, entries: Vec<String>) {
        for entry in entries {
            if !entry.trim().is_empty() && !self.entries.contains(&entry) {
                self.entries.push(entry);
            }
        }

        if self.entries.len() > self.max_size {
            self.entries.drain(0..self.entries.len() - self.max_size);
        }

        self.save_to_file();
    }

    pub fn entry_count(&self) -> usize {
        self.entries.len()
    }
}

// ## END ##

// ## FILE: src/commands/history/mod.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/history/mod.rs - KORRIGIERT
// =====================================================

pub mod command;
pub mod config;
pub mod events;
pub mod keyboard;
pub mod manager;

// Clean Re-exports
pub use command::HistoryCommand;
pub use config::HistoryConfig;
pub use events::{HistoryEvent, HistoryEventHandler};
pub use keyboard::{HistoryAction, HistoryKeyboardHandler};
pub use manager::HistoryManager;

// ## END ##

// ## FILE: src/commands/history/keyboard.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/history/keyboard.rs - FINAL VERSION (ohne Debug)
// =====================================================

use crate::core::prelude::*;

#[derive(Debug, Clone, PartialEq)]
pub enum HistoryAction {
    NavigatePrevious,
    NavigateNext,
}

pub struct HistoryKeyboardHandler;

impl HistoryKeyboardHandler {
    pub fn get_history_action(key: &KeyEvent) -> Option<HistoryAction> {
        match (key.code, key.modifiers) {
            (KeyCode::Up, crossterm::event::KeyModifiers::NONE) => {
                Some(HistoryAction::NavigatePrevious)
            }
            (KeyCode::Down, crossterm::event::KeyModifiers::NONE) => {
                Some(HistoryAction::NavigateNext)
            }
            _ => None,
        }
    }
}

// ## END ##

// ## FILE: src/commands/exit/command.rs
// ## BEGIN ##
// =====================================================
// FILE: commands/exit/exit.rs - TRAIT IMPL
// =====================================================

use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::i18n::get_command_translation;

#[derive(Debug)]
pub struct ExitCommand;

impl Command for ExitCommand {
    fn name(&self) -> &'static str {
        "exit"
    }

    fn description(&self) -> &'static str {
        "Exit the application"
    }

    fn matches(&self, command: &str) -> bool {
        crate::matches_exact!(command, "exit" | "q")
    }

    fn execute_sync(&self, _args: &[&str]) -> Result<String> {
        let msg = get_command_translation("system.input.confirm_exit", &[]);
        Ok(format!("__CONFIRM:__EXIT__{}", msg))
    }

    fn priority(&self) -> u8 {
        100 // H√∂chste Priorit√§t f√ºr Exit
    }
}

// ## END ##

// ## FILE: src/commands/exit/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::ExitCommand;

// ## END ##

// ## FILE: src/commands/create/command.rs
// ## BEGIN ##
// Enhanced src/commands/create/command.rs - BULK CREATION SUPPORT
use crate::commands::command::Command;
use crate::core::prelude::*;
use crate::server::types::{ServerContext, ServerInfo, ServerStatus};
use crate::server::utils::validation::validate_server_name;
use uuid::Uuid;

#[derive(Debug, Default)]
pub struct CreateCommand;

impl CreateCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for CreateCommand {
    fn name(&self) -> &'static str {
        "create"
    }
    fn description(&self) -> &'static str {
        "Create web server(s) - supports bulk creation"
    }
    fn matches(&self, command: &str) -> bool {
        command.trim().to_lowercase().starts_with("create")
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        let config = get_config()?;
        let ctx = crate::server::shared::get_shared_context();

        // Parse arguments for different creation modes
        match self.parse_creation_args(args) {
            CreationMode::Single { name, port } => {
                self.create_single_server(&config, ctx, name, port)
            }
            CreationMode::BulkAuto { count } => {
                self.create_bulk_servers(&config, ctx, count, None, None)
            }
            CreationMode::BulkWithBase {
                base_name,
                base_port,
                count,
            } => self.create_bulk_servers(&config, ctx, count, Some(base_name), Some(base_port)),
            CreationMode::Invalid(error) => Err(AppError::Validation(error)),
        }
    }

    fn priority(&self) -> u8 {
        65
    }
}

#[derive(Debug)]
enum CreationMode {
    Single {
        name: Option<String>,
        port: Option<u16>,
    },
    BulkAuto {
        count: u32,
    },
    BulkWithBase {
        base_name: String,
        base_port: u16,
        count: u32,
    },
    Invalid(String),
}

impl CreateCommand {
    // Argument parsing logic
    fn parse_creation_args(&self, args: &[&str]) -> CreationMode {
        match args.len() {
            0 => CreationMode::Single {
                name: None,
                port: None,
            },

            1 => {
                // Erst auf Port pr√ºfen (4-5 Stellen), dann auf Count (1-2 Stellen)
                if let Ok(port) = args[0].parse::<u16>() {
                    if port >= 1000 {
                        // "create 8080" -> Single server with port
                        CreationMode::Single {
                            name: None,
                            port: Some(port),
                        }
                    } else if port > 0 && port <= 50 {
                        // "create 5" -> Bulk creation with count
                        CreationMode::BulkAuto { count: port as u32 }
                    } else {
                        CreationMode::Invalid("Invalid port or count".to_string())
                    }
                } else {
                    // "create myserver" -> Single server with name
                    CreationMode::Single {
                        name: Some(args[0].to_string()),
                        port: None,
                    }
                }
            }

            2 => {
                // "create myserver 8080" -> Single with name and port
                if let Ok(port) = args[1].parse::<u16>() {
                    CreationMode::Single {
                        name: Some(args[0].to_string()),
                        port: Some(port),
                    }
                } else {
                    CreationMode::Invalid("Invalid port number".to_string())
                }
            }

            3 => {
                // "create myserver 8080 5" -> Bulk with base name, port, and count
                if let (Ok(port), Ok(count)) = (args[1].parse::<u16>(), args[2].parse::<u32>()) {
                    if count == 0 {
                        return CreationMode::Invalid("Count must be > 0".to_string());
                    }
                    if count > 50 {
                        return CreationMode::Invalid(
                            "Maximum 50 servers per bulk operation".to_string(),
                        );
                    }
                    CreationMode::BulkWithBase {
                        base_name: args[0].to_string(),
                        base_port: port,
                        count,
                    }
                } else {
                    CreationMode::Invalid("Invalid port or count".to_string())
                }
            }

            _ => CreationMode::Invalid(
                "Too many arguments. Usage: create [name] [port] [count]".to_string(),
            ),
        }
    }

    // Single server creation (existing logic)
    fn create_single_server(
        &self,
        config: &Config,
        ctx: &ServerContext,
        custom_name: Option<String>,
        custom_port: Option<u16>,
    ) -> Result<String> {
        let result = self.create_server_internal(config, ctx, custom_name, custom_port)?;
        Ok(format!("Server created: {}", result.summary))
    }

    // Bulk server creation
    fn create_bulk_servers(
        &self,
        config: &Config,
        ctx: &ServerContext,
        count: u32,
        base_name: Option<String>,
        base_port: Option<u16>,
    ) -> Result<String> {
        let initial_server_count = ctx.servers.read().unwrap().len();

        // Check if bulk creation would exceed limits
        if initial_server_count + (count as usize) > config.server.max_concurrent {
            return Err(AppError::Validation(format!(
                "Bulk creation would exceed server limit: {} + {} > {} (max_concurrent)",
                initial_server_count, count, config.server.max_concurrent
            )));
        }

        let mut created_servers = Vec::new();
        let mut failed_servers = Vec::new();

        for i in 0..count {
            let (name, port) =
                if let (Some(ref base_name), Some(base_port)) = (&base_name, base_port) {
                    // Use base name with suffix and increment port
                    let name = format!("{}-{:03}", base_name, i + 1);
                    let port = base_port + (i as u16);
                    (Some(name), Some(port))
                } else {
                    // Use automatic naming and port assignment (both None for auto)
                    (None, None)
                };

            match self.create_server_internal(config, ctx, name, port) {
                Ok(result) => {
                    created_servers.push(result);
                }
                Err(e) => {
                    failed_servers.push(format!("Server {}: {}", i + 1, e));

                    // Stop on critical errors, continue on port conflicts
                    if !e.to_string().contains("bereits") && !e.to_string().contains("occupied") {
                        break;
                    }
                }
            }
        }

        // Format results
        let mut result = format!(
            "Bulk creation completed: {} of {} servers created",
            created_servers.len(),
            count
        );

        if !created_servers.is_empty() {
            result.push_str("\n\nCreated servers:");
            for server in &created_servers {
                result.push_str(&format!("\n  {} - {}", server.name, server.summary));
            }
        }

        if !failed_servers.is_empty() {
            result.push_str("\n\nFailed:");
            for failure in &failed_servers {
                result.push_str(&format!("\n  {}", failure));
            }
        }

        let final_count = ctx.servers.read().unwrap().len();
        result.push_str(&format!(
            "\n\nTotal servers: {}/{}",
            final_count, config.server.max_concurrent
        ));

        Ok(result)
    }

    // Internal server creation logic (extracted from original)
    fn create_server_internal(
        &self,
        config: &Config,
        ctx: &ServerContext,
        custom_name: Option<String>,
        custom_port: Option<u16>,
    ) -> Result<ServerCreationResult> {
        let id = Uuid::new_v4().to_string();
        let has_custom_name = custom_name.is_some();

        let name = if let Some(custom_name) = custom_name {
            validate_server_name(&custom_name)?;
            let servers = ctx.servers.read().unwrap();
            if servers.values().any(|s| s.name == custom_name) {
                return Err(AppError::Validation(format!(
                    "Server-Name '{}' bereits vergeben!",
                    custom_name
                )));
            }
            custom_name
        } else {
            let server_number = self.find_next_server_number(ctx);
            format!("rss-{:03}", server_number)
        };

        let port = if let Some(custom_port) = custom_port {
            let min_port = config.server.port_range_start.max(1024);
            if custom_port < min_port {
                return Err(AppError::Validation(format!(
                    "Port must be >= {} (configured minimum: {})",
                    min_port, config.server.port_range_start
                )));
            }

            if custom_port > config.server.port_range_end {
                return Err(AppError::Validation(format!(
                    "Port {} exceeds configured maximum: {}",
                    custom_port, config.server.port_range_end
                )));
            }

            let servers = ctx.servers.read().unwrap();
            if servers.values().any(|s| s.port == custom_port) {
                return Err(AppError::Validation(format!(
                    "Port {} bereits verwendet!",
                    custom_port
                )));
            }
            if !crate::server::utils::port::is_port_available(custom_port) {
                return Err(AppError::Validation(format!(
                    "Port {} bereits belegt!",
                    custom_port
                )));
            }

            custom_port
        } else {
            self.find_next_available_port(config)?
        };

        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let server_info = ServerInfo {
            id: id.clone(),
            name: name.clone(),
            port,
            status: ServerStatus::Stopped,
            created_at: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            created_timestamp: timestamp,
        };

        // Create server directory and files
        if let Err(e) = crate::server::handlers::web::create_server_directory_and_files(&name, port)
        {
            return Err(AppError::Validation(format!(
                "Failed to create server directory: {}",
                e
            )));
        }

        // Add to runtime context
        ctx.servers
            .write()
            .unwrap()
            .insert(id.clone(), server_info.clone());

        // Persist to file (async)
        let registry = crate::server::shared::get_persistent_registry();
        let server_info_clone = server_info.clone();
        tokio::spawn(async move {
            if let Ok(_persistent_servers) = registry.load_servers().await {
                if let Err(e) = registry.add_server(server_info_clone).await {
                    log::error!("Failed to persist server: {}", e);
                }
            }
        });

        let summary = if has_custom_name {
            format!(
                "'{}' (ID: {}) on port {} [PERSISTENT]",
                name,
                &id[0..8],
                port
            )
        } else {
            format!(
                "'{}' (ID: {}) on port {} [PERSISTENT]",
                name,
                &id[0..8],
                port
            )
        };

        Ok(ServerCreationResult { name, summary })
    }

    // Existing helper methods (unchanged)
    fn find_next_available_port(&self, config: &Config) -> Result<u16> {
        let ctx = crate::server::shared::get_shared_context();
        let used_ports: std::collections::HashSet<u16> = {
            let servers = ctx
                .servers
                .read()
                .map_err(|_| AppError::Validation("Server-Context lock poisoned".to_string()))?;
            servers.values().map(|s| s.port).collect()
        };

        let start_port = config.server.port_range_start;
        let end_port = config.server.port_range_end;

        if start_port >= end_port {
            return Err(AppError::Validation(format!(
                "Invalid port range: {} >= {}. Check config.",
                start_port, end_port
            )));
        }

        let max_attempts = ((end_port - start_port + 1) as usize).min(1000);

        for i in 0..max_attempts {
            let candidate_port = start_port + (i as u16);

            if candidate_port > end_port {
                break;
            }

            if !used_ports.contains(&candidate_port)
                && crate::server::utils::port::is_port_available(candidate_port)
            {
                return Ok(candidate_port);
            }
        }

        Err(AppError::Validation(format!(
            "No available ports in range {}-{} after {} attempts",
            start_port, end_port, max_attempts
        )))
    }

    fn find_next_server_number(&self, ctx: &ServerContext) -> u32 {
        let servers = ctx.servers.read().unwrap();
        let mut existing_numbers = Vec::new();

        for server in servers.values() {
            if let Some(number_str) = server.name.strip_prefix("rss-") {
                if let Ok(number) = number_str.parse::<u32>() {
                    existing_numbers.push(number);
                }
            }
        }

        existing_numbers.sort();
        let mut next_number = 1;
        for &existing in &existing_numbers {
            if existing == next_number {
                next_number += 1;
            } else {
                break;
            }
        }
        next_number
    }
}

#[derive(Debug)]
struct ServerCreationResult {
    name: String,
    summary: String,
}

// ## END ##

// ## FILE: src/commands/create/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::CreateCommand;

// ## END ##

// ## FILE: src/commands/log_level/command.rs
// ## BEGIN ##
use super::manager::LogLevelManager;
use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug)]
pub struct LogLevelCommand;

impl Command for LogLevelCommand {
    fn name(&self) -> &'static str {
        "log-level"
    }

    fn description(&self) -> &'static str {
        "Change application log level"
    }

    fn matches(&self, command: &str) -> bool {
        let cmd = command.trim().to_lowercase();
        cmd.starts_with("log-level")
            || cmd.starts_with("loglevel")
            || (cmd.starts_with("config") && cmd.contains("--log-level"))
    }

    // ‚úÖ FIXED EXECUTE_SYNC - Proper error handling
    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        match args.first() {
            None => Ok(LogLevelManager::show_status()),
            Some(&"--help" | &"-h" | &"help") => Ok(LogLevelManager::show_help_i18n()),
            Some(&level) => LogLevelManager::set_level_persistent(level), // Direkt weiterleiten
        }
    }

    fn priority(&self) -> u8 {
        75
    }
}

// ## END ##

// ## FILE: src/commands/log_level/manager.rs
// ## BEGIN ##
use crate::core::prelude::*;
use log::LevelFilter;
use std::sync::Mutex;

pub struct LogLevelManager;

static CURRENT_LOG_LEVEL: Mutex<LevelFilter> = Mutex::new(LevelFilter::Info);

impl LogLevelManager {
    // ‚úÖ STATUS DISPLAY mit i18n
    pub fn show_status() -> String {
        let current = Self::get_current_level();
        let current_name = Self::level_to_name(current);
        let current_number = Self::level_to_number(current);

        format!(
            "{}\n{}",
            get_command_translation(
                "system.commands.log_level.current_status",
                &[&current_name, &current_number]
            ),
            Self::show_help_i18n()
        )
    }

    // ‚úÖ HELP TEXT mit i18n
    pub fn show_help_i18n() -> String {
        get_command_translation("system.commands.log_level.help_text", &[])
    }

    // ‚úÖ Legacy method (for compatibility)
    pub fn show_help() -> String {
        Self::show_help_i18n()
    }

    // ‚úÖ SET LEVEL mit i18n - FIXED RETURN TYPE
    // src/commands/log_level/manager.rs
    pub fn set_level_persistent(level_input: &str) -> Result<String> {
        use log::LevelFilter;

        let level_filter = match level_input {
            "1" => LevelFilter::Error,
            "2" => LevelFilter::Warn,
            "3" => LevelFilter::Info,
            "4" => LevelFilter::Debug,
            "5" => LevelFilter::Trace,
            "error" | "ERROR" => LevelFilter::Error,
            "warn" | "WARN" | "warning" => LevelFilter::Warn,
            "info" | "INFO" => LevelFilter::Info,
            "debug" | "DEBUG" => LevelFilter::Debug,
            "trace" | "TRACE" => LevelFilter::Trace,
            _ => {
                return Err(AppError::Validation(get_command_translation(
                    "system.commands.log_level.invalid_level",
                    &[level_input],
                )));
            }
        };

        Self::init_with_level(level_filter);
        Ok(get_command_translation(
            "system.commands.log_level.changed",
            &[level_input],
        ))
    }

    // ‚úÖ Unchanged core functionality
    pub fn set_level_runtime(level_filter: LevelFilter) {
        if let Ok(mut current) = CURRENT_LOG_LEVEL.lock() {
            *current = level_filter;
        }
        log::set_max_level(level_filter);
    }

    pub async fn load_from_config() -> LevelFilter {
        match crate::core::config::Config::load_with_messages(false).await {
            Ok(config) => match Self::string_to_level_filter(&config.log_level) {
                Ok(level) => level,
                Err(_) => {
                    log::warn!(
                        "{}",
                        get_translation(
                            "config.validation.invalid_log_level",
                            &[&config.log_level]
                        )
                    );
                    LevelFilter::Info
                }
            },
            Err(_) => LevelFilter::Info,
        }
    }

    // ‚úÖ Unchanged helper methods
    pub fn get_current_level() -> LevelFilter {
        if let Ok(current) = CURRENT_LOG_LEVEL.lock() {
            *current
        } else {
            log::max_level()
        }
    }

    pub fn init_with_level(level: LevelFilter) {
        if let Ok(mut current) = CURRENT_LOG_LEVEL.lock() {
            *current = level;
        }
        log::set_max_level(level);
    }

    // ‚úÖ FIXED STRING TO LEVEL FILTER - Uses proper Result<T>
    fn string_to_level_filter(s: &str) -> std::result::Result<LevelFilter, ()> {
        match s.to_lowercase().as_str() {
            "error" | "1" => Ok(LevelFilter::Error),
            "warn" | "warning" | "2" => Ok(LevelFilter::Warn),
            "info" | "3" => Ok(LevelFilter::Info),
            "debug" | "4" => Ok(LevelFilter::Debug),
            "trace" | "5" => Ok(LevelFilter::Trace),
            "off" | "0" => Ok(LevelFilter::Off),
            _ => Err(()),
        }
    }

    fn level_to_name(level: LevelFilter) -> String {
        match level {
            LevelFilter::Error => "ERROR".to_string(),
            LevelFilter::Warn => "WARN".to_string(),
            LevelFilter::Info => "INFO".to_string(),
            LevelFilter::Debug => "DEBUG".to_string(),
            LevelFilter::Trace => "TRACE".to_string(),
            LevelFilter::Off => "OFF".to_string(),
        }
    }

    fn level_to_number(level: LevelFilter) -> String {
        match level {
            LevelFilter::Error => "1".to_string(),
            LevelFilter::Warn => "2".to_string(),
            LevelFilter::Info => "3".to_string(),
            LevelFilter::Debug => "4".to_string(),
            LevelFilter::Trace => "5".to_string(),
            LevelFilter::Off => "0".to_string(),
        }
    }
}

// ## END ##

// ## FILE: src/commands/log_level/mod.rs
// ## BEGIN ##
pub mod command;
pub mod manager;

pub use command::LogLevelCommand;
pub use manager::LogLevelManager;

// ## END ##

// ## FILE: src/commands/help/command.rs
// ## BEGIN ##
use crate::commands::command::Command;
use crate::core::prelude::*;

#[derive(Debug, Default)]
pub struct HelpCommand;

impl HelpCommand {
    pub fn new() -> Self {
        Self
    }
}

impl Command for HelpCommand {
    fn name(&self) -> &'static str {
        "help"
    }

    fn description(&self) -> &'static str {
        "Show all available commands"
    }

    fn matches(&self, command: &str) -> bool {
        let cmd = command.trim().to_lowercase();
        cmd == "help" || cmd == "?" || cmd == "commands" || cmd == "list-commands"
    }

    fn execute_sync(&self, args: &[&str]) -> Result<String> {
        let handler = crate::commands::CommandHandler::new();

        match args.first() {
            Some(&"--simple" | &"-s") => Ok(self.create_simple_list(&handler)),
            Some(&"--detailed" | &"-d") => Ok(self.create_detailed_list(&handler)),
            None => Ok(self.create_formatted_list(&handler)),
            Some(&command_name) => Ok(self.show_command_help(command_name, &handler)),
        }
    }

    fn priority(&self) -> u8 {
        95
    }
}

impl HelpCommand {
    /// ROBUSTE ZENTRALE DESCRIPTION √úBERSETZUNG
    fn get_localized_description(&self, command_name: &str, original_description: &str) -> String {
        // Normalisiere Command-Namen f√ºr i18n keys
        let normalized_name = command_name.replace("-", "_");
        let description_key = format!("system.commands.{}.description", normalized_name);

        // Pr√ºfe ob √úbersetzung existiert
        if crate::i18n::has_translation(&description_key) {
            get_command_translation(&description_key, &[])
        } else {
            // Sichere Fallback-Strategie
            log::debug!(
                "No translation found for key '{}', using original description",
                description_key
            );
            original_description.to_string()
        }
    }

    /// Formatierte Standard-Liste mit robusten √úbersetzungen
    fn create_formatted_list(&self, handler: &crate::commands::CommandHandler) -> String {
        let commands = handler.list_commands();

        if commands.is_empty() {
            return get_command_translation("system.commands.help.no_commands", &[]);
        }

        let mut result = String::new();
        result.push_str(&get_command_translation("system.commands.help.header", &[]));
        result.push_str("\n\n");

        // Robuste Kategorisierung mit √úbersetzung
        let mut categorized = std::collections::BTreeMap::new();

        for (name, original_description) in commands {
            let category_key = self.determine_category(name);
            let localized_description = self.get_localized_description(name, original_description);

            categorized
                .entry(category_key)
                .or_insert_with(Vec::new)
                .push((name, localized_description));
        }

        // Ausgabe mit robusten √úbersetzungen
        for (category_key, commands) in categorized {
            let category_translation_key =
                format!("system.commands.help.category.{}", category_key);

            // Robuste Kategorie-√úbersetzung mit Fallback
            let category_name = if crate::i18n::has_translation(&category_translation_key) {
                get_command_translation(&category_translation_key, &[])
            } else {
                log::debug!(
                    "No translation for category '{}', using fallback",
                    category_key
                );
                self.get_fallback_category_name(category_key)
            };

            result.push_str(&format!("{}:\n", category_name));

            for (name, description) in commands {
                result.push_str(&format!("  {:12} - {}\n", name, description));
            }
            result.push('\n');
        }

        result.push_str(&get_command_translation("system.commands.help.footer", &[]));
        result
    }

    /// Robuste Kategorie-Bestimmung
    fn determine_category(&self, command_name: &str) -> &'static str {
        match command_name {
            name if name.starts_with("start")
                || name.starts_with("stop")
                || name.starts_with("restart") =>
            {
                "server_control"
            }
            name if name.starts_with("create") || name.starts_with("list") => "server_management",
            name if name.starts_with("cleanup") || name.starts_with("recover") => "maintenance",
            name if name.starts_with("theme")
                || name.starts_with("lang")
                || name.starts_with("log-level") =>
            {
                "configuration"
            }
            name if name.starts_with("help")
                || name.starts_with("version")
                || name.starts_with("history") =>
            {
                "information"
            }
            name if name.starts_with("exit") || name.starts_with("clear") => "system",
            _ => "other",
        }
    }

    /// Fallback-Kategorie-Namen (falls i18n fehlt)
    fn get_fallback_category_name(&self, category_key: &str) -> String {
        match category_key {
            "server_control" => "Server Control".to_string(),
            "server_management" => "Server Management".to_string(),
            "maintenance" => "Maintenance".to_string(),
            "configuration" => "Configuration".to_string(),
            "information" => "Information".to_string(),
            "system" => "System".to_string(),
            "other" => "Other".to_string(),
            _ => category_key.to_string(),
        }
    }

    /// Einfache Liste mit robusten √úbersetzungen
    fn create_simple_list(&self, handler: &crate::commands::CommandHandler) -> String {
        let commands = handler.list_commands();
        let names: Vec<&str> = commands.iter().map(|(name, _)| *name).collect();
        let names_str = names.join(", ");

        get_command_translation("system.commands.help.simple_list", &[&names_str])
    }

    /// Detaillierte Liste mit robusten √úbersetzungen
    fn create_detailed_list(&self, handler: &crate::commands::CommandHandler) -> String {
        let commands = handler.list_commands();
        let mut result = String::new();

        result.push_str(&get_command_translation(
            "system.commands.help.detailed_header",
            &[],
        ));
        result.push('\n');
        result.push_str(&get_command_translation(
            "system.commands.help.detailed_separator",
            &[],
        ));
        result.push_str("\n\n");

        for (name, original_description) in commands {
            let localized_description = self.get_localized_description(name, original_description);

            let command_label = get_command_translation("system.commands.help.command_label", &[]);
            let description_label =
                get_command_translation("system.commands.help.description_label", &[]);
            let usage_label = get_command_translation("system.commands.help.usage_label", &[]);
            let separator = get_command_translation("system.commands.help.command_separator", &[]);

            result.push_str(&format!("{} {}\n", command_label, name.to_uppercase()));
            result.push_str(&format!(
                "{} {}\n",
                description_label, localized_description
            ));
            result.push_str(&format!("{} {} [options]\n", usage_label, name));
            result.push_str(&format!("{}\n", separator));
        }

        result
    }

    /// Spezifische Command-Hilfe mit robusten √úbersetzungen
    fn show_command_help(
        &self,
        command_name: &str,
        handler: &crate::commands::CommandHandler,
    ) -> String {
        let commands = handler.list_commands();

        for (name, original_description) in commands {
            if name.eq_ignore_ascii_case(command_name) {
                let localized_description =
                    self.get_localized_description(name, original_description);

                return get_command_translation(
                    "system.commands.help.specific_help_template",
                    &[name, &localized_description, name, name],
                );
            }
        }

        get_command_translation("system.commands.help.command_not_found", &[command_name])
    }
}

// ## END ##

// ## FILE: src/commands/help/mod.rs
// ## BEGIN ##
pub mod command;
pub use command::HelpCommand;

// ## END ##

// ## FILE: src/i18n/mod.rs
// ## BEGIN ##
use crate::core::prelude::*;
use crate::ui::color::AppColor;
use rust_embed::RustEmbed;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

pub const DEFAULT_LANGUAGE: &str = "en";

#[derive(Debug)]
pub enum TranslationError {
    InvalidLanguage(String),
    LoadError(String),
}

impl std::fmt::Display for TranslationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidLanguage(lang) => write!(f, "Invalid language: {}", lang),
            Self::LoadError(msg) => write!(f, "Load error: {}", msg),
        }
    }
}

#[derive(RustEmbed)]
#[folder = "src/i18n/langs/"]
pub struct Langs;

#[derive(Debug, Clone)]
struct Entry {
    text: String,
    display: String,
    category: String,
}

impl Entry {
    fn format(&self, params: &[&str]) -> String {
        params
            .iter()
            .enumerate()
            .fold(self.text.clone(), |mut text, (i, param)| {
                text = text.replace(&format!("{{{}}}", i), param);
                if text.contains("{}") {
                    text = text.replacen("{}", param, 1);
                }
                text
            })
    }
}

struct I18nService {
    language: String,
    entries: HashMap<String, Entry>,
    fallback: HashMap<String, Entry>,
    cache: HashMap<String, String>,
}

impl I18nService {
    fn new() -> Self {
        Self {
            language: DEFAULT_LANGUAGE.into(),
            entries: HashMap::new(),
            fallback: HashMap::new(),
            cache: HashMap::new(),
        }
    }

    fn load_language(&mut self, lang: &str) -> Result<()> {
        // Validate
        if !Self::available_languages()
            .iter()
            .any(|l| l.eq_ignore_ascii_case(lang))
        {
            return Err(AppError::Translation(TranslationError::InvalidLanguage(
                lang.into(),
            )));
        }

        // Load entries
        self.entries = Self::load_entries(lang)?;

        // Load fallback (andere Sprachen)
        self.fallback.clear();
        for available_lang in Self::available_languages() {
            if available_lang.to_lowercase() != lang.to_lowercase() {
                if let Ok(other_entries) = Self::load_entries(&available_lang.to_lowercase()) {
                    for (key, entry) in other_entries {
                        self.fallback.entry(key).or_insert(entry);
                    }
                }
            }
        }

        self.cache.clear();
        self.language = lang.into();
        Ok(())
    }

    fn load_entries(lang: &str) -> Result<HashMap<String, Entry>> {
        let lang_lower = lang.to_lowercase();
        let mut merged_raw: HashMap<String, String> = HashMap::new();

        // Dynamisch alle Kategorien f√ºr diese Sprache finden
        let category_files: Vec<String> = Langs::iter()
            .filter_map(|file| {
                let filename = file.as_ref();
                let prefix = format!("{}/", lang_lower);

                if filename.starts_with(&prefix) && filename.ends_with(".json") {
                    Some(filename.to_string())
                } else {
                    None
                }
            })
            .collect();

        // Lade alle gefundenen Kategorie-Dateien
        let mut found_modular = false;
        for filename in category_files {
            if let Some(content) = Langs::get(&filename) {
                if let Ok(content_str) = std::str::from_utf8(content.data.as_ref()) {
                    if let Ok(raw) = serde_json::from_str::<HashMap<String, String>>(content_str) {
                        merged_raw.extend(raw);
                        found_modular = true;
                    }
                }
            }
        }

        // Fallback: Alte Einzeldatei
        if !found_modular {
            let filename = format!("{}.json", lang_lower);
            let content = Langs::get(&filename).ok_or_else(|| {
                AppError::Translation(TranslationError::LoadError(format!(
                    "File not found: {}",
                    filename
                )))
            })?;

            let content_str = std::str::from_utf8(content.data.as_ref())
                .map_err(|e| AppError::Translation(TranslationError::LoadError(e.to_string())))?;

            merged_raw = serde_json::from_str(content_str)
                .map_err(|e| AppError::Translation(TranslationError::LoadError(e.to_string())))?;
        }

        // DEINE ORIGINALLOGIK - UNVER√ÑNDERT!
        Ok(merged_raw
            .iter()
            .filter_map(|(key, value)| {
                key.strip_suffix(".text").map(|base_key| {
                    let display = merged_raw
                        .get(&format!("{}.display_text", base_key))
                        .unwrap_or(&base_key.to_uppercase())
                        .clone();
                    let category = merged_raw
                        .get(&format!("{}.category", base_key))
                        .unwrap_or(&"info".to_string())
                        .clone();

                    (
                        base_key.into(),
                        Entry {
                            text: value.clone(),
                            display,
                            category,
                        },
                    )
                })
            })
            .collect())
    }

    fn get_translation(&mut self, key: &str, params: &[&str]) -> String {
        // Cache check
        let cache_key = if params.is_empty() {
            key.into()
        } else {
            format!("{}:{}", key, params.join(":"))
        };

        if let Some(cached) = self.cache.get(&cache_key) {
            return cached.clone();
        }

        // Get entry
        let text = match self.entries.get(key).or_else(|| self.fallback.get(key)) {
            Some(entry) => entry.format(params),
            None => format!("Missing: {}", key),
        };

        // Cache with size limit
        if self.cache.len() >= 1000 {
            self.cache.clear();
        }
        self.cache.insert(cache_key, text.clone());
        text
    }

    fn get_command_translation(&mut self, key: &str, params: &[&str]) -> String {
        match self.entries.get(key).or_else(|| self.fallback.get(key)) {
            Some(entry) => format!("[{}] {}", entry.display, entry.format(params)),
            None => format!("[WARNING] Missing: {}", key),
        }
    }

    fn get_display_color(&self, display_text: &str) -> AppColor {
        // Suche Entry mit matching display_text
        for entry in self.entries.values() {
            if entry.display.to_uppercase() == display_text.to_uppercase() {
                return AppColor::from_category(&entry.category);
            }
        }

        // Fallback...
        AppColor::from_any("info")
    }

    // ‚úÖ KORRIGIERTE FUNKTION: Erkennt beide Strukturen
    fn available_languages() -> Vec<String> {
        let mut languages = std::collections::HashSet::new();

        for file in Langs::iter() {
            let filename = file.as_ref();

            if filename.ends_with(".json") {
                if let Some(lang) = filename.strip_suffix(".json") {
                    // Alte Struktur: de.json -> de
                    if !lang.contains('/') {
                        languages.insert(lang.to_uppercase());
                    }
                }

                if let Some(slash_pos) = filename.find('/') {
                    // Neue Struktur: de/common.json -> de
                    let lang = &filename[..slash_pos];
                    languages.insert(lang.to_uppercase());
                }
            }
        }

        languages.into_iter().collect()
    }
}

// ‚úÖ SINGLETON (unver√§ndert)
static SERVICE: std::sync::LazyLock<Arc<RwLock<I18nService>>> =
    std::sync::LazyLock::new(|| Arc::new(RwLock::new(I18nService::new())));

// ‚úÖ PUBLIC API - VEREINFACHT!
pub async fn init() -> Result<()> {
    set_language(DEFAULT_LANGUAGE)
}

pub fn set_language(lang: &str) -> Result<()> {
    SERVICE.write().unwrap().load_language(lang)
}

pub fn get_translation(key: &str, params: &[&str]) -> String {
    SERVICE.write().unwrap().get_translation(key, params)
}

pub fn get_command_translation(key: &str, params: &[&str]) -> String {
    SERVICE
        .write()
        .unwrap()
        .get_command_translation(key, params)
}

pub fn get_color_for_display_text(display_text: &str) -> AppColor {
    SERVICE.read().unwrap().get_display_color(display_text)
}

pub fn get_color_category_for_display(display: &str) -> String {
    match display.to_lowercase().as_str() {
        "theme" => "theme".to_string(),
        "lang" | "sprache" => "lang".to_string(),
        _ => "info".to_string(),
    }
}

pub fn get_current_language() -> String {
    SERVICE.read().unwrap().language.to_uppercase()
}

pub fn get_available_languages() -> Vec<String> {
    I18nService::available_languages()
}

pub fn has_translation(key: &str) -> bool {
    let service = SERVICE.read().unwrap();
    service.entries.contains_key(key) || service.fallback.contains_key(key)
}

pub fn clear_translation_cache() {
    SERVICE.write().unwrap().cache.clear();
}

#[macro_export]
macro_rules! t {
    ($key:expr) => { $crate::i18n::get_translation($key, &[]) };
    ($key:expr, $($arg:expr),+) => { $crate::i18n::get_translation($key, &[$($arg),+]) };
}

#[macro_export]
macro_rules! tc {
    ($key:expr) => { $crate::i18n::get_command_translation($key, &[]) };
    ($key:expr, $($arg:expr),+) => { $crate::i18n::get_command_translation($key, &[$($arg),+]) };
}

// ## END ##

// ## FILE: src/embedded/mod.rs
// ## BEGIN ##
use crate::memory::{register_embedded, ResourceKind};
use include_dir::{include_dir, Dir, File};

pub static SRC_DIR: Dir = include_dir!("$CARGO_MANIFEST_DIR/src");

pub fn register_all_src() {
    register_dir_recursive(&SRC_DIR, "src");
}

pub fn register_all_src_filtered() {
    register_dir_recursive_filtered(
        &SRC_DIR,
        "src",
        &["html", "css", "js", "svg", "txt", "json", "otf", "ttf"],
    );
}

/// Rekursiv, Pfad relativ zum `SRC_DIR` sauber zusammenbauen.
pub fn register_dir_recursive(dir: &'static Dir, base_id: &str) {
    recurse(dir, base_id, "");
}

pub fn register_dir_recursive_filtered(dir: &'static Dir, base_id: &str, exts: &[&str]) {
    recurse_filtered(dir, base_id, "", exts);
}

fn recurse(dir: &'static Dir, base_id: &str, prefix: &str) {
    for f in dir.files() {
        let rel = join_rel(prefix, f.path());
        register_file(&rel, f, base_id);
    }
    for d in dir.dirs() {
        let new_prefix = join_rel(prefix, d.path());
        // `d.path()` kann ‚Äûserver/handlers‚Äú enthalten ‚Äì wir h√§ngen nur das letzte Segment an
        let new_prefix = trim_to_last_segment(&new_prefix);
        recurse(d, base_id, &new_prefix);
    }
}

fn recurse_filtered(dir: &'static Dir, base_id: &str, prefix: &str, exts: &[&str]) {
    for f in dir.files() {
        let rel = join_rel(prefix, f.path());
        if has_ext(&rel, exts) {
            register_file(&rel, f, base_id);
        }
    }
    for d in dir.dirs() {
        let new_prefix = join_rel(prefix, d.path());
        let new_prefix = trim_to_last_segment(&new_prefix);
        recurse_filtered(d, base_id, &new_prefix, exts);
    }
}

fn register_file(rel: &str, file: &File, base_id: &str) {
    let rel = rel.trim_start_matches("src/"); // optional: f√ºhrendes src/ entfernen
    let id = format!("{base_id}:{rel}@v1");
    let bytes = file.contents().len() as u64;
    register_embedded(&id.replace('\\', "/"), ResourceKind::EmbeddedAsset, bytes);
}

fn join_rel(prefix: &str, path: &std::path::Path) -> String {
    if prefix.is_empty() {
        path.to_string_lossy().into_owned()
    } else {
        format!("{prefix}/{}", path.display())
    }
}

/// aus "server/handlers" -> "handlers" (nur letztes Segment),
/// damit sich der Pfad beim Abstieg nicht doppelt aufbl√§ht.
fn trim_to_last_segment(p: &str) -> String {
    std::path::Path::new(p)
        .file_name()
        .map(|s| s.to_string_lossy().into_owned())
        .unwrap_or_else(|| p.to_string())
}

fn has_ext(rel: &str, allow: &[&str]) -> bool {
    let rel = rel.to_ascii_lowercase();
    allow.iter().any(|e| rel.ends_with(&format!(".{e}")))
}

// ## END ##

// ## FILE: src/i18n/langs/de/config.json
// ## BEGIN ##
{
  "config.config_backup_created.text": "Config-Backup erstellt: {0}",
  "config.config_backup_created.display_text": "DEBUG",
  "config.config_backup_created.category": "debug",

  "config.config_successfully_written_to.text": "Konfiguration erfolgreich geschrieben nach: {0}",
  "config.config_successfully_written_to.display_text": "DEBUG",
  "config.config_successfully_written_to.category": "debug",

  "config.corrected.poll_rate.text": "poll_rate: {0}ms ‚Üí {1}ms (korrigiert)",
  "config.corrected.poll_rate.display_text": "WARN",
  "config.corrected.poll_rate.category": "warning",

  "config.corrected.typewriter.text": "typewriter_delay: {0}ms ‚Üí {1}ms (korrigiert)",
  "config.corrected.typewriter.display_text": "WARN",
  "config.corrected.typewriter.category": "warning",

  "config.corrected_values.text": "üîß Ung√ºltige Config-Werte korrigiert und gespeichert:",
  "config.corrected_values.display_text": "WARN",
  "config.corrected_values.category": "warning",

  "config.could_not_create_backup.text": "Konnte Backup nicht erstellen: {0}",
  "config.could_not_create_backup.display_text": "WARN",
  "config.could_not_create_backup.category": "warning",

  "config.creating_config_directory.text": "Erstelle Konfigurationsverzeichnis: {0}",
  "config.creating_config_directory.display_text": "DEBUG",
  "config.creating_config_directory.category": "debug",

  "config.current_theme.text": "Aktuelles Theme: {0}",
  "config.current_theme.display_text": "DEBUG",
  "config.current_theme.category": "debug",

  "config.failed_to_create_config_directory.text": "Fehler beim Erstellen des Konfigurationsverzeichnisses: {0}",
  "config.failed_to_create_config_directory.display_text": "FEHLER",
  "config.failed_to_create_config_directory.category": "error",

  "config.failed_to_rename_temp_file.text": "Fehler beim Umbenennen der tempor√§ren Datei: {0}",
  "config.failed_to_rename_temp_file.display_text": "FEHLER",
  "config.failed_to_rename_temp_file.category": "error",

  "config.failed_to_write_temp_config_file.text": "Fehler beim Schreiben der tempor√§ren Config-Datei: {0}",
  "config.failed_to_write_temp_config_file.display_text": "FEHLER",
  "config.failed_to_write_temp_config_file.category": "error",

  "config.poll_rate.too_fast.text": "poll_rate {0}ms zu schnell, verwende Minimum: {1}ms",
  "config.poll_rate.too_fast.display_text": "WARN",
  "config.poll_rate.too_fast.category": "warning",

  "config.poll_rate.too_slow.text": "poll_rate {0}ms zu langsam, verwende Maximum: {1}ms",
  "config.poll_rate.too_slow.display_text": "WARN",
  "config.poll_rate.too_slow.category": "warning",

  "config.poll_rate.zero.text": "poll_rate = 0 nicht erlaubt, verwende Minimum: {0}ms",
  "config.poll_rate.zero.display_text": "WARN",
  "config.poll_rate.zero.category": "warning",

  "config.save_failed.text": "Konnte korrigierte Config nicht speichern: {0}",
  "config.save_failed.display_text": "FEHLER",
  "config.save_failed.category": "error",

  "config.save_success.text": "‚úÖ Korrigierte Werte in Config-Datei gespeichert",
  "config.save_success.display_text": "INFO",
  "config.save_success.category": "info",

  "config.saved_current_theme_to_config.text": "Aktuelles Theme in Config gespeichert: {0}",
  "config.saved_current_theme_to_config.display_text": "INFO",
  "config.saved_current_theme_to_config.category": "info",

  "config.saving_config_to.text": "Speichere Konfiguration nach: {0}",
  "config.saving_config_to.display_text": "DEBUG",
  "config.saving_config_to.category": "debug",

  "config.switch_theme_to.text": "Wechsle zu Theme: {0}",
  "config.switch_theme_to.display_text": "DEBUG",
  "config.switch_theme_to.category": "debug",

  "config.toml_serialization_failed.text": "TOML-Serialisierung fehlgeschlagen: {0}",
  "config.toml_serialization_failed.display_text": "FEHLER",
  "config.toml_serialization_failed.category": "error",

  "config.typewriter.off.text": "typewriter_delay = 0 ‚Üí Typewriter-Effekt deaktiviert",
  "config.typewriter.off.display_text": "INFO",
  "config.typewriter.off.category": "info",

  "config.typewriter.too_slow.text": "typewriter_delay {0}ms zu langsam, verwende Maximum: {1}ms",
  "config.typewriter.too_slow.display_text": "WARN",
  "config.typewriter.too_slow.category": "warning",

  "config.validation.invalid_color.text": "Ung√ºltige Farbe: {0}",
  "config.validation.invalid_color.display_text": "CONFIG",
  "config.validation.invalid_color.category": "error",

  "config.validation.invalid_log_level.text": "Ung√ºltige Log-Stufe in Konfiguration: '{0}', verwende INFO",
  "config.validation.invalid_log_level.display_text": "CONFIG",
  "config.validation.invalid_log_level.category": "warning",

  "config.validation.theme_load_failed.text": "Theme konnte nicht geladen werden: {0}",
  "config.validation.theme_load_failed.display_text": "CONFIG",
  "config.validation.theme_load_failed.category": "error",

  "config.validation.theme_not_found.text": "Theme '{0}' nicht gefunden",
  "config.validation.theme_not_found.display_text": "CONFIG",
  "config.validation.theme_not_found.category": "error",

  "config.validation.toml_error.text": "TOML-Fehler: {0}",
  "config.validation.toml_error.display_text": "CONFIG",
  "config.validation.toml_error.category": "error",

  "language.service.config_load_error.text": "Konfiguration-Ladefehler: {0}",
  "language.service.config_load_error.display_text": "LANG",
  "language.service.config_load_error.category": "error",

  "language.service.config_save_error.text": "Konfiguration-Speicherfehler: {0}",
  "language.service.config_save_error.display_text": "LANG",
  "language.service.config_save_error.category": "error",

  "language.service.save_failed.text": "Sprach-Konfiguration konnte nicht gespeichert werden: {0}",
  "language.service.save_failed.display_text": "LANG",
  "language.service.save_failed.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/de/common.json
// ## BEGIN ##
{
  "debug.text": "Debug",
  "debug.display_text": "DEBUG",
  "debug.category": "debug",

  "error.text": "Fehler",
  "error.display_text": "FEHLER",
  "error.category": "error",

  "info.text": "Information",
  "info.display_text": "INFO",
  "info.category": "info",

  "trace.text": "Trace",
  "trace.display_text": "TRACE",
  "trace.category": "trace",

  "warn.text": "Warnung",
  "warn.display_text": "WARN",
  "warn.category": "warning"
}

// ## END ##

// ## FILE: src/i18n/langs/de/cmd_help.json
// ## BEGIN ##
{
  "system.commands.help.header.text": "Verf√ºgbare Commands",
  "system.commands.help.header.display_text": "HELP",
  "system.commands.help.header.category": "info",

  "system.commands.help.footer.text": "Verwende 'help <command>' f√ºr detaillierte Hilfe zu einem Command.",
  "system.commands.help.footer.display_text": "HELP",
  "system.commands.help.footer.category": "info",

  "system.commands.help.no_commands.text": "Keine Commands verf√ºgbar.",
  "system.commands.help.no_commands.display_text": "HELP",
  "system.commands.help.no_commands.category": "warning",

  "system.commands.help.category.server_control.text": "Server-Steuerung",
  "system.commands.help.category.server_control.display_text": "HELP",
  "system.commands.help.category.server_control.category": "info",

  "system.commands.help.category.server_management.text": "Server-Verwaltung",
  "system.commands.help.category.server_management.display_text": "HELP",
  "system.commands.help.category.server_management.category": "info",

  "system.commands.help.category.maintenance.text": "Wartung",
  "system.commands.help.category.maintenance.display_text": "HELP",
  "system.commands.help.category.maintenance.category": "info",

  "system.commands.help.category.configuration.text": "Konfiguration",
  "system.commands.help.category.configuration.display_text": "HELP",
  "system.commands.help.category.configuration.category": "info",

  "system.commands.help.category.information.text": "Information",
  "system.commands.help.category.information.display_text": "HELP",
  "system.commands.help.category.information.category": "info",

  "system.commands.help.category.system.text": "System",
  "system.commands.help.category.system.display_text": "HELP",
  "system.commands.help.category.system.category": "info",

  "system.commands.help.category.other.text": "Sonstige",
  "system.commands.help.category.other.display_text": "HELP",
  "system.commands.help.category.other.category": "info",

  "system.commands.help.simple_list.text": "Verf√ºgbare Commands: {0}",
  "system.commands.help.simple_list.display_text": "HELP",
  "system.commands.help.simple_list.category": "info",

  "system.commands.help.detailed_header.text": "Alle verf√ºgbaren Commands (Detailliert):",
  "system.commands.help.detailed_header.display_text": "HELP",
  "system.commands.help.detailed_header.category": "info",

  "system.commands.help.detailed_separator.text": "=====================================",
  "system.commands.help.detailed_separator.display_text": "HELP",
  "system.commands.help.detailed_separator.category": "info",

  "system.commands.help.command_label.text": "Command:",
  "system.commands.help.command_label.display_text": "HELP",
  "system.commands.help.command_label.category": "info",

  "system.commands.help.description_label.text": "Beschreibung:",
  "system.commands.help.description_label.display_text": "HELP",
  "system.commands.help.description_label.category": "info",

  "system.commands.help.usage_label.text": "Verwendung:",
  "system.commands.help.usage_label.display_text": "HELP",
  "system.commands.help.usage_label.category": "info",

  "system.commands.help.command_separator.text": "-------------------------------------",
  "system.commands.help.command_separator.display_text": "HELP",
  "system.commands.help.command_separator.category": "info",

  "system.commands.help.specific_help_template.text": "Hilfe f√ºr Command '{0}':\n\nBeschreibung: {1}\n\nVerwendung: {2} [optionen]\n\nF√ºr weitere Details versuche: {3} --help",
  "system.commands.help.specific_help_template.display_text": "HELP",
  "system.commands.help.specific_help_template.category": "info",

  "system.commands.help.command_not_found.text": "Command '{0}' nicht gefunden. Verwende 'help' um alle verf√ºgbaren Commands zu sehen.",
  "system.commands.help.command_not_found.display_text": "HELP",
  "system.commands.help.command_not_found.category": "warning",

  "_comment": "=== COMMAND DESCRIPTIONS ===",

  "system.commands.log_level.description.text": "Log-Stufe der Anwendung √§ndern",
  "system.commands.log_level.description.display_text": "HELP",
  "system.commands.log_level.description.category": "info",

  "system.commands.language.description.text": "Anwendungssprache √§ndern",
  "system.commands.language.description.display_text": "HELP",
  "system.commands.language.description.category": "info",

  "system.commands.theme.description.text": "Anwendungsdesign √§ndern (Live-Update ohne Neustart, aus TOML geladen)",
  "system.commands.theme.description.display_text": "HELP",
  "system.commands.theme.description.category": "info",

  "system.commands.help.description.text": "Alle verf√ºgbaren Commands anzeigen",
  "system.commands.help.description.display_text": "HELP",
  "system.commands.help.description.category": "info",

  "system.commands.version.description.text": "Anwendungsversion anzeigen",
  "system.commands.version.description.display_text": "HELP",
  "system.commands.version.description.category": "info",

  "system.commands.history.description.text": "Befehlshistorie verwalten",
  "system.commands.history.description.display_text": "HELP",
  "system.commands.history.description.category": "info",

  "system.commands.recover.description.text": "Server-Status-Inkonsistenzen beheben und reparieren",
  "system.commands.recover.description.display_text": "HELP",
  "system.commands.recover.description.category": "info",

  "system.commands.cleanup.description.text": "Server, Logs und WWW-Dateien bereinigen - unterst√ºtzt Best√§tigung und Force-Flags",
  "system.commands.cleanup.description.display_text": "HELP",
  "system.commands.cleanup.description.category": "info",

  "system.commands.restart.description.text": "Anwendung neu starten",
  "system.commands.restart.description.display_text": "HELP",
  "system.commands.restart.description.category": "info",

  "system.commands.start.description.text": "Server starten - unterst√ºtzt Bereiche und Massenoperationen",
  "system.commands.start.description.display_text": "HELP",
  "system.commands.start.description.category": "info",

  "system.commands.stop.description.text": "Server stoppen - unterst√ºtzt Bereiche und Massenoperationen",
  "system.commands.stop.description.display_text": "HELP",
  "system.commands.stop.description.category": "info",

  "system.commands.create.description.text": "Web-Server erstellen - unterst√ºtzt Massenerstellung",
  "system.commands.create.description.display_text": "HELP",
  "system.commands.create.description.category": "info",

  "system.commands.list.description.text": "Alle Web-Server auflisten (persistent)",
  "system.commands.list.description.display_text": "HELP",
  "system.commands.list.description.category": "info",

  "system.commands.clear.description.text": "Bildschirm leeren",
  "system.commands.clear.description.display_text": "HELP",
  "system.commands.clear.description.category": "info",

  "system.commands.exit.description.text": "Anwendung beenden",
  "system.commands.exit.description.display_text": "HELP",
  "system.commands.exit.description.category": "info"
}

// ## END ##

// ## FILE: src/i18n/langs/de/history.json
// ## BEGIN ##
{
  "history.manager.cleared.text": "üìÇ Historie gel√∂scht",
  "history.manager.cleared.display_text": "HISTORY",
  "history.manager.cleared.category": "info",

  "history.manager.loaded_entries.text": "üìÇ {0} Historie-Eintr√§ge geladen",
  "history.manager.loaded_entries.display_text": "HISTORY",
  "history.manager.loaded_entries.category": "debug",

  "history.manager.save_failed.text": "Speichern der Historie fehlgeschlagen: {0}",
  "history.manager.save_failed.display_text": "HISTORY",
  "history.manager.save_failed.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/de/commands.json
// ## BEGIN ##
{
  "system.commands.cleanup.confirm_stopped.text": "Gestoppte Server l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_stopped.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_stopped.category": "warning",

  "system.commands.cleanup.confirm_failed.text": "Fehlgeschlagene Server l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_failed.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_failed.category": "warning",

  "system.commands.cleanup.confirm_logs.text": "Alle Server-Logs l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_logs.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_logs.category": "warning",

  "system.commands.cleanup.confirm_all.text": "Komplette Bereinigung (Server, Logs, WWW-Ordner)? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_all.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_all.category": "warning",

  "system.commands.cleanup.confirm_www_server.text": "WWW-Ordner f√ºr Server '{0}' l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_www_server.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_www_server.category": "warning",

  "system.commands.cleanup.confirm_www_all.text": "Kompletten WWW-Ordner l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden. (j/n)",
  "system.commands.cleanup.confirm_www_all.display_text": "BEST√ÑTIGEN",
  "system.commands.cleanup.confirm_www_all.category": "warning",

  "system.commands.cleanup.stopped_success.text": "{0} gestoppte Server entfernt (persistent gespeichert)",
  "system.commands.cleanup.stopped_success.display_text": "CLEANUP",
  "system.commands.cleanup.stopped_success.category": "info",

  "system.commands.cleanup.no_stopped.text": "Keine gestoppten Server zum Entfernen gefunden",
  "system.commands.cleanup.no_stopped.display_text": "CLEANUP",
  "system.commands.cleanup.no_stopped.category": "info",

  "system.commands.cleanup.failed_success.text": "{0} fehlgeschlagene Server entfernt (persistent gespeichert)",
  "system.commands.cleanup.failed_success.display_text": "CLEANUP",
  "system.commands.cleanup.failed_success.category": "info",

  "system.commands.cleanup.no_failed.text": "Keine fehlgeschlagenen Server zum Entfernen gefunden",
  "system.commands.cleanup.no_failed.display_text": "CLEANUP",
  "system.commands.cleanup.no_failed.category": "info",

  "system.commands.cleanup.logs_started.text": "Server-Log-Bereinigung gestartet...",
  "system.commands.cleanup.logs_started.display_text": "CLEANUP",
  "system.commands.cleanup.logs_started.category": "info",

  "system.commands.cleanup.logs_success.text": "Server-Logs bereinigt: {0} Dateien gel√∂scht, {1}MB freigegeben",
  "system.commands.cleanup.logs_success.display_text": "CLEANUP",
  "system.commands.cleanup.logs_success.category": "info",

  "system.commands.cleanup.no_logs_dir.text": "Kein servers/ Verzeichnis gefunden",
  "system.commands.cleanup.no_logs_dir.display_text": "CLEANUP",
  "system.commands.cleanup.no_logs_dir.category": "info",

  "system.commands.cleanup.www_server_started.text": "WWW-Bereinigung f√ºr '{0}' gestartet...",
  "system.commands.cleanup.www_server_started.display_text": "CLEANUP",
  "system.commands.cleanup.www_server_started.category": "info",

  "system.commands.cleanup.www_all_started.text": "Komplette WWW-Bereinigung gestartet...",
  "system.commands.cleanup.www_all_started.display_text": "CLEANUP",
  "system.commands.cleanup.www_all_started.category": "info",

  "system.commands.cleanup.www_server_success.text": "WWW f√ºr Server '{0}' bereinigt: {1} Verzeichnisse gel√∂scht, {2}MB freigegeben",
  "system.commands.cleanup.www_server_success.display_text": "CLEANUP",
  "system.commands.cleanup.www_server_success.category": "info",

  "system.commands.cleanup.www_all_success.text": "WWW-Verzeichnis komplett bereinigt: {0} Verzeichnisse, {1} Dateien gel√∂scht, {2}MB freigegeben",
  "system.commands.cleanup.www_all_success.display_text": "CLEANUP",
  "system.commands.cleanup.www_all_success.category": "info",

  "system.commands.cleanup.no_www_dir.text": "Kein www/ Verzeichnis gefunden",
  "system.commands.cleanup.no_www_dir.display_text": "CLEANUP",
  "system.commands.cleanup.no_www_dir.category": "info",

  "system.commands.cleanup.no_www_for_server.text": "Keine WWW-Verzeichnisse f√ºr Server '{0}' gefunden",
  "system.commands.cleanup.no_www_for_server.display_text": "CLEANUP",
  "system.commands.cleanup.no_www_for_server.category": "info",

  "system.commands.cleanup.async_started.text": "Server-Logs und WWW-Dateien werden bereinigt...",
  "system.commands.cleanup.async_started.display_text": "CLEANUP",
  "system.commands.cleanup.async_started.category": "info",

  "system.commands.cleanup.usage.text": "Verwendung: cleanup [stopped|failed|logs|www|all] [server_name] oder cleanup --force-[type]",
  "system.commands.cleanup.usage.display_text": "CLEANUP",
  "system.commands.cleanup.usage.category": "info",

  "system.commands.history.confirm_clear.text": "M√∂chten Sie wirklich die gesamte Befehlshistorie l√∂schen? (j/n)",
  "system.commands.history.confirm_clear.display_text": "BEST√ÑTIGEN",
  "system.commands.history.confirm_clear.category": "warning",

  "system.commands.history.help.text": "üìÇ Historie-Befehle:\n  history        Zeige diese Hilfe\n  history -c     L√∂sche Historie\n  ‚Üë ‚Üì           Navigiere durch Historie\n\n  Datei: ~/.rss/rush.history",
  "system.commands.history.help.display_text": "HISTORIE",
  "system.commands.history.help.category": "info",

  "system.commands.history.usage.text": "üìÇ Verwende ‚Üë‚Üì Pfeiltasten zur Navigation, 'history -c' zum L√∂schen",
  "system.commands.history.usage.display_text": "HISTORIE",
  "system.commands.history.usage.category": "info",

  "system.commands.language.available.text": "Verf√ºgbare Sprachen: {0}",
  "system.commands.language.available.display_text": "SPRACHE",
  "system.commands.language.available.category": "lang",

  "system.commands.language.changed.text": "‚úÖ Sprache gewechselt zu: {0}",
  "system.commands.language.changed.display_text": "SPRACHE",
  "system.commands.language.changed.category": "lang",

  "system.commands.language.current.text": "Aktuelle Sprache: {0}",
  "system.commands.language.current.display_text": "SPRACHE",
  "system.commands.language.current.category": "lang",

  "system.commands.language.invalid.text": "‚ö´ Ung√ºltige Sprache: {0}",
  "system.commands.language.invalid.display_text": "FEHLER",
  "system.commands.language.invalid.category": "error",

  "system.commands.log_level.changed_persistent.text": "‚úÖ Log-Stufe ge√§ndert zu: {0} ({1}) - Persistent gespeichert",
  "system.commands.log_level.changed_persistent.display_text": "INFO",
  "system.commands.log_level.changed_persistent.category": "info",

  "system.commands.log_level.changed_success.text": "‚úÖ Log-Stufe ge√§ndert zu: {0} ({1}) - Persistent gespeichert",
  "system.commands.log_level.changed_success.display_text": "LOG_LEVEL",
  "system.commands.log_level.changed_success.category": "info",

  "system.commands.log_level.current.text": "Aktuelle Log-Stufe: {0} ({1})",
  "system.commands.log_level.current.display_text": "INFO",
  "system.commands.log_level.current.category": "info",

  "system.commands.log_level.current_status.text": "Aktuelle Log-Stufe: {0} ({1})",
  "system.commands.log_level.current_status.display_text": "LOG_LEVEL",
  "system.commands.log_level.current_status.category": "info",

  "system.commands.log_level.help.text": "Verf√ºgbare Log-Stufen:\n  1 = ERROR   (Nur kritische Fehler)\n  2 = WARN    (Warnungen und Fehler)\n  3 = INFO    (Allgemeine Informationen) [STANDARD]\n  4 = DEBUG   (Debug-Informationen)\n  5 = TRACE   (Sehr detaillierte Verfolgung)\n\nVerwendung:\n  log-level           Zeige aktuelle Stufe\n  log-level 3         Setze auf INFO-Stufe\n  log-level DEBUG     Setze auf DEBUG-Stufe\n  log-level -h        Zeige diese Hilfe",
  "system.commands.log_level.help.display_text": "INFO",
  "system.commands.log_level.help.category": "info",

  "system.commands.log_level.help_text.text": "Verf√ºgbare Log-Stufen:\n  1 = ERROR   (Nur kritische Fehler)\n  2 = WARN    (Warnungen und Fehler)\n  3 = INFO    (Allgemeine Informationen) [STANDARD]\n  4 = DEBUG   (Debug-Informationen)\n  5 = TRACE   (Sehr detaillierte Verfolgung)\n\nVerwendung:\n  log-level           Zeige aktuelle Stufe\n  log-level 3         Setze auf INFO-Stufe\n  log-level DEBUG     Setze auf DEBUG-Stufe\n  log-level -h        Zeige diese Hilfe",
  "system.commands.log_level.help_text.display_text": "LOG_LEVEL",
  "system.commands.log_level.help_text.category": "info",

  "system.commands.log_level.invalid.text": "‚ö´ Ung√ºltige Log-Stufe: {0}. Verf√ºgbar: 1-5, error, warn, info, debug, trace",
  "system.commands.log_level.invalid.display_text": "FEHLER",
  "system.commands.log_level.invalid.category": "error",

  "system.commands.log_level.invalid_level.text": "‚ö´ Ung√ºltige Log-Stufe: {0}. Verf√ºgbar: 1-5, error, warn, info, debug, trace",
  "system.commands.log_level.invalid_level.display_text": "LOG_LEVEL",
  "system.commands.log_level.invalid_level.category": "error",

  "system.commands.performance.help.text": "Performance-Befehl Hilfe:\n  perf                   Zeige Performance-Status\n  performance           Gleich wie perf\n  stats                 Gleich wie perf\n  perf -h               Zeige diese Hilfe",
  "system.commands.performance.help.display_text": "INFO",
  "system.commands.performance.help.category": "info",

  "system.commands.performance.unknown.text": "Unbekannter Performance-Parameter. Verwende 'perf -h' f√ºr Hilfe.",
  "system.commands.performance.unknown.display_text": "FEHLER",
  "system.commands.performance.unknown.category": "error",

  "system.commands.restart.confirm.text": "M√∂chten Sie wirklich einen Neustart durchf√ºhren? (j/n)",
  "system.commands.restart.confirm.display_text": "BEST√ÑTIGEN",
  "system.commands.restart.confirm.category": "warning",

  "system.commands.restart.help.text": "Verf√ºgbare Neustart-Befehle:\n  restart           Neustart mit Best√§tigung\n  restart --force   Sofortiger Neustart",
  "system.commands.restart.help.display_text": "INFO",
  "system.commands.restart.help.category": "info",

  "system.commands.restart.success.text": "üîÑ Neustart erfolgreich abgeschlossen",
  "system.commands.restart.success.display_text": "INFO",
  "system.commands.restart.success.category": "info",

  "system.commands.restart.unknown.text": "Unbekannter Neustart-Parameter. Verwende 'restart -h' f√ºr Hilfe.",
  "system.commands.restart.unknown.display_text": "FEHLER",
  "system.commands.restart.unknown.category": "error",

  "system.commands.theme.add_sections_hint.text": "üí° F√ºge [theme.xyz] Sektionen zur rush.toml hinzu",
  "system.commands.theme.add_sections_hint.display_text": "THEME",
  "system.commands.theme.add_sections_hint.category": "info",

  "system.commands.theme.changed_success.text": "üé® Theme gewechselt zu: {0} ‚ú®",
  "system.commands.theme.changed_success.display_text": "THEME",
  "system.commands.theme.changed_success.category": "theme",

  "system.commands.theme.current_status.text": "Aktuelles Theme: {0} (aus TOML)\nVerf√ºgbar: {1}",
  "system.commands.theme.current_status.display_text": "THEME",
  "system.commands.theme.current_status.category": "info",

  "system.commands.theme.debug_details.text": "üìÇ Theme '{0}':\ninput_text: '{1}'\ninput_bg: '{2}'\noutput_text: '{3}'\noutput_bg: '{4}'\ninput_cursor_prefix: '{5}'\ninput_cursor_color: '{6}'\ninput_cursor: '{7}'\noutput_cursor: '{8}'\noutput_cursor_color: '{9}'",
  "system.commands.theme.debug_details.display_text": "THEME",
  "system.commands.theme.debug_details.category": "info",

  "system.commands.theme.debug_missing_name.text": "‚ö´ Theme-Name fehlt. Verwendung: theme debug <name>",
  "system.commands.theme.debug_missing_name.display_text": "THEME",
  "system.commands.theme.debug_missing_name.category": "error",

  "system.commands.theme.debug_not_found.text": "‚ö´ Theme '{0}' nicht gefunden!",
  "system.commands.theme.debug_not_found.display_text": "THEME",
  "system.commands.theme.debug_not_found.category": "error",

  "system.commands.theme.help.add_sections.text": "üìÇ F√ºge beliebige [theme.dein_name] Sektionen f√ºr neue Themes hinzu",
  "system.commands.theme.help.add_sections.display_text": "THEME",
  "system.commands.theme.help.add_sections.category": "info",

  "system.commands.theme.help.cursor_config.text": "üéØ NEU: Cursor-Konfiguration √ºber output_cursor + output_color!",
  "system.commands.theme.help.cursor_config.display_text": "THEME",
  "system.commands.theme.help.cursor_config.category": "info",

  "system.commands.theme.help.cursor_options.text": "üéõÔ∏è Cursor-Optionen:\n‚Ä¢ output_cursor: BLOCK, PIPE, UNDERSCORE\n‚Ä¢ output_color: Jede unterst√ºtzte Farbe (White, Green, etc.)",
  "system.commands.theme.help.cursor_options.display_text": "THEME",
  "system.commands.theme.help.cursor_options.category": "info",

  "system.commands.theme.help.header.text": "üé® TOML-Theme Befehle (Live Update - Geladen aus rush.toml!):",
  "system.commands.theme.help.header.display_text": "THEME",
  "system.commands.theme.help.header.category": "info",

  "system.commands.theme.help.live_changes.text": "üîÑ √Ñnderungen werden sofort angewendet (kein Neustart n√∂tig)",
  "system.commands.theme.help.live_changes.display_text": "THEME",
  "system.commands.theme.help.live_changes.category": "info",

  "system.commands.theme.help.live_loaded.text": "‚ú® Alle Themes werden LIVE aus [theme.*] Sektionen der rush.toml geladen!",
  "system.commands.theme.help.live_loaded.display_text": "THEME",
  "system.commands.theme.help.live_loaded.category": "info",

  "system.commands.theme.help.preview_theme.text": "theme preview <name> Vorschau der Theme-Farben + Cursor-Config ‚úÖ NEU!",
  "system.commands.theme.help.preview_theme.display_text": "THEME",
  "system.commands.theme.help.preview_theme.category": "info",

  "system.commands.theme.help.select_theme.text": "theme <name>         W√§hle Theme: {0}",
  "system.commands.theme.help.select_theme.display_text": "THEME",
  "system.commands.theme.help.select_theme.category": "info",

  "system.commands.theme.help.show_help.text": "theme -h             Zeige diese Hilfe",
  "system.commands.theme.help.show_help.display_text": "THEME",
  "system.commands.theme.help.show_help.category": "info",

  "system.commands.theme.help.show_themes.text": "theme                Zeige verf√ºgbare TOML-Themes",
  "system.commands.theme.help.show_themes.display_text": "THEME",
  "system.commands.theme.help.show_themes.category": "info",

  "system.commands.theme.how_to_add_themes.text": "üìÇ F√ºge [theme.mein_theme] Sektionen zur rush.toml hinzu:\n\n[theme.mein_theme]\ninput_text = \"White\"\ninput_bg = \"Black\"\ncursor = \"Green\"\noutput_text = \"Gray\"\noutput_bg = \"Black\"\nprompt_text = \">> \"\nprompt_color = \"Cyan\"\noutput_cursor = \"BLOCK\"\noutput_color = \"LightGreen\"",
  "system.commands.theme.how_to_add_themes.display_text": "THEME",
  "system.commands.theme.how_to_add_themes.category": "info",

  "system.commands.theme.load_failed.text": "‚ö´ Theme-System konnte nicht geladen werden: {0}",
  "system.commands.theme.load_failed.display_text": "THEME",
  "system.commands.theme.load_failed.category": "error",

  "system.commands.theme.no_themes_available.text": "‚ö´ Keine Themes verf√ºgbar!",
  "system.commands.theme.no_themes_available.display_text": "THEME",
  "system.commands.theme.no_themes_available.category": "error",

  "system.commands.theme.no_themes_found.text": "‚ö´ Keine Themes verf√ºgbar! F√ºge [theme.xyz] Sektionen zur rush.toml hinzu.",
  "system.commands.theme.no_themes_found.display_text": "THEME",
  "system.commands.theme.no_themes_found.category": "error",

  "system.commands.theme.no_themes_hint.text": "Keine Themes in der Konfiguration gefunden.",
  "system.commands.theme.no_themes_hint.display_text": "THEME",
  "system.commands.theme.no_themes_hint.category": "warning",

  "system.commands.theme.not_found.text": "‚ö´ Theme '{0}' nicht gefunden. Verf√ºgbar: {1}",
  "system.commands.theme.not_found.display_text": "THEME",
  "system.commands.theme.not_found.category": "error",

  "system.commands.theme.preview_details.text": "üé® Theme '{0}' Vorschau:\nEingabe: {1} auf {2}\nAusgabe: {3} auf {4}\nCursor-Pr√§fix: '{5}' in {6}\nEingabe-Cursor: {7}\nAusgabe-Cursor: {8} in {9}\n\nüìÇ Quelle: [theme.{10}] in rush.toml",
  "system.commands.theme.preview_details.display_text": "THEME",
  "system.commands.theme.preview_details.category": "info",

  "system.commands.theme.preview_missing_name.text": "‚ö´ Theme-Name fehlt. Verwendung: theme preview <name>",
  "system.commands.theme.preview_missing_name.display_text": "THEME",
  "system.commands.theme.preview_missing_name.category": "error",

  "system.commands.unknown.text": "Befehl unbekannt: {0}",
  "system.commands.unknown.display_text": "FEHLER",
  "system.commands.unknown.category": "error",

  "system.commands.version.text": "Rush Sync Server Version {0}",
  "system.commands.version.display_text": "VERSION",
  "system.commands.version.category": "version"
}

// ## END ##

// ## FILE: src/i18n/langs/de/ui.json
// ## BEGIN ##
{
  "screen.performance_command_detected.text": "üîß Performance-Befehl '{0}' erkannt",
  "screen.performance_command_detected.display_text": "DEBUG",
  "screen.performance_command_detected.category": "debug",

  "screen.performance_command_viewport_reset_applied.text": "‚úÖ Performance-Befehl: Viewport-Reset angewendet",
  "screen.performance_command_viewport_reset_applied.display_text": "DEBUG",
  "screen.performance_command_viewport_reset_applied.category": "debug",

  "screen.render.empty_buffer_error.text": "FEHLER: Leerer Puffer",
  "screen.render.empty_buffer_error.display_text": "RENDER",
  "screen.render.empty_buffer_error.category": "error",

  "screen.render.exceed_bounds_log.text": "Layout √ºberschreitet Terminal-Grenzen: {0}x{1}",
  "screen.render.exceed_bounds_log.display_text": "FEHLER",
  "screen.render.exceed_bounds_log.category": "error",

  "screen.render.invalid_layout.text": "‚ö†Ô∏è UNG√úLTIGES LAYOUT",
  "screen.render.invalid_layout.display_text": "RENDER",
  "screen.render.invalid_layout.category": "error",

  "screen.render.invalid_layout_log.text": "Ung√ºltiges Layout: Output={0}x{1}+{2}+{3}, Input={4}x{5}+{6}+{7}",
  "screen.render.invalid_layout_log.display_text": "FEHLER",
  "screen.render.invalid_layout_log.category": "error",

  "screen.render.terminal_too_small.text": "Terminal zu klein!\nMinimum: 10x5",
  "screen.render.terminal_too_small.display_text": "RENDER",
  "screen.render.terminal_too_small.category": "error",

  "screen.render.too_small.text": "Terminal zu klein!\nMinimum: 10x5",
  "screen.render.too_small.display_text": "FEHLER",
  "screen.render.too_small.category": "error",

  "screen.render.too_small_log.text": "Bildschirm zu klein f√ºr sicheres Rendering: {0}x{1}",
  "screen.render.too_small_log.display_text": "FEHLER",
  "screen.render.too_small_log.category": "error",

  "screen.render.viewport_error.text": "Viewport-Fehler!\nTerminal neu starten.",
  "screen.render.viewport_error.display_text": "RENDER",
  "screen.render.viewport_error.category": "error",

  "screen.render.viewport_not_usable_log.text": "Viewport nicht verwendbar",
  "screen.render.viewport_not_usable_log.display_text": "FEHLER",
  "screen.render.viewport_not_usable_log.category": "error",

  "screen.resize_completed.text": "‚úÖ Gr√∂√üen√§nderung abgeschlossen: {0}",
  "screen.resize_completed.display_text": "INFO",
  "screen.resize_completed.category": "info",

  "screen.resize_event.text": "üîÑ RESIZE EVENT: {0}x{1} ‚Üí {2}x{3}",
  "screen.resize_event.display_text": "INFO",
  "screen.resize_event.category": "info",

  "screen.restart.done.text": "‚úÖ Interner Neustart erfolgreich abgeschlossen",
  "screen.restart.done.display_text": "INFO",
  "screen.restart.done.category": "info",

  "screen.restart.failed.text": "Neustart fehlgeschlagen: {0}",
  "screen.restart.failed.display_text": "SYSTEM",
  "screen.restart.failed.category": "error",

  "screen.restart.start.text": "üîÑ Interner Neustart wird ausgef√ºhrt...",
  "screen.restart.start.display_text": "INFO",
  "screen.restart.start.category": "info",

  "screen.restart.success.text": "üîÑ Neustart erfolgreich abgeschlossen",
  "screen.restart.success.display_text": "SYSTEM",
  "screen.restart.success.category": "info",

  "screen.theme.applied.text": "Theme '{0}' angewendet: Prompt='{1}', Historie={2} Eintr√§ge",
  "screen.theme.applied.display_text": "INFO",
  "screen.theme.applied.category": "info",

  "screen.theme.failed.text": "Theme-Wechsel fehlgeschlagen: {0}",
  "screen.theme.failed.display_text": "FEHLER",
  "screen.theme.failed.category": "error",

  "screen.theme.invalid_format.text": "Ung√ºltiges Theme-Update-Format",
  "screen.theme.invalid_format.display_text": "FEHLER",
  "screen.theme.invalid_format.category": "error",

  "screen.theme.load_failed.text": "Theme-System konnte nicht geladen werden: {0}",
  "screen.theme.load_failed.display_text": "THEME",
  "screen.theme.load_failed.category": "error",

  "screen.theme.not_found.text": "Theme '{0}' nicht gefunden",
  "screen.theme.not_found.display_text": "THEME",
  "screen.theme.not_found.category": "error",

  "screen.theme.not_found_feedback.text": "‚ö´ Theme '{0}' nicht gefunden",
  "screen.theme.not_found_feedback.display_text": "FEHLER",
  "screen.theme.not_found_feedback.category": "error",

  "screen.theme.processing.text": "üé® Live-Theme-Update wird verarbeitet: {0}",
  "screen.theme.processing.display_text": "DEBUG",
  "screen.theme.processing.category": "debug",

  "screen.theme.switched_success.text": "‚úÖ Theme gewechselt zu: {0}",
  "screen.theme.switched_success.display_text": "THEME",
  "screen.theme.switched_success.category": "theme",

  "viewport.layout.broken.text": "üö® Layout schwer besch√§digt, Notfallmodus wird aktiviert",
  "viewport.layout.broken.display_text": "FEHLER",
  "viewport.layout.broken.category": "error",

  "viewport.layout.calculated.text": "Layout berechnet: Terminal={0}x{1}, Output={2}x{3}+{4}+{5}, Input={6}x{7}+{8}+{9}, Fenster={10}",
  "viewport.layout.calculated.display_text": "TRACE",
  "viewport.layout.calculated.category": "trace",

  "viewport.layout.failed.text": "Layout-Berechnung fehlgeschlagen: Input={0}, Output={1}, Verf√ºgbar={2}",
  "viewport.layout.failed.display_text": "FEHLER",
  "viewport.layout.failed.category": "error",

  "viewport.layout.invalid.text": "üö® Ung√ºltige Layoutbereiche erstellt, Notfall-Layout wird verwendet",
  "viewport.layout.invalid.display_text": "FEHLER",
  "viewport.layout.invalid.category": "error",

  "viewport.layout.mismatch.text": "Layout-Gr√∂√üen stimmen nicht √ºberein: Terminal={0}, Benutzt={1} (Output={2}, Input={3}, Margin={4})",
  "viewport.layout.mismatch.display_text": "WARN",
  "viewport.layout.mismatch.category": "warning",

  "viewport.layout.too_small.text": "Viewport-Layout zu klein: {0}x{1}",
  "viewport.layout.too_small.display_text": "FEHLER",
  "viewport.layout.too_small.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/de/manager.json
// ## BEGIN ##
{
  "manager.cached_entries.text": "Cache-Eintr√§ge",
  "manager.cached_entries.display_text": "INFO",
  "manager.cached_entries.category": "info",

  "manager.change_theme.text": "Theme wechseln",
  "manager.change_theme.display_text": "INFO",
  "manager.change_theme.category": "info",

  "manager.comprehensive_report_header.text": "üìä UMFASSENDER PERFORMANCE-BERICHT",
  "manager.comprehensive_report_header.display_text": "INFO",
  "manager.comprehensive_report_header.category": "info",

  "manager.current_language.text": "Aktuelle Sprache",
  "manager.current_language.display_text": "INFO",
  "manager.current_language.category": "info",

  "manager.disabled.text": "DEAKTIVIERT",
  "manager.disabled.display_text": "INFO",
  "manager.disabled.category": "info",

  "manager.enable_debug_logging.text": "Debug-Protokollierung aktivieren",
  "manager.enable_debug_logging.display_text": "INFO",
  "manager.enable_debug_logging.category": "info",

  "manager.history_buffer.text": "Historie-Puffer",
  "manager.history_buffer.display_text": "INFO",
  "manager.history_buffer.category": "info",

  "manager.i18n_cache.text": "i18n-Cache",
  "manager.i18n_cache.display_text": "INFO",
  "manager.i18n_cache.category": "info",

  "manager.i18n_performance.text": "i18n-Performance",
  "manager.i18n_performance.display_text": "INFO",
  "manager.i18n_performance.category": "info",

  "manager.memory_usage.text": "Speicherverbrauch",
  "manager.memory_usage.display_text": "INFO",
  "manager.memory_usage.category": "info",

  "manager.message_buffer.text": "Nachrichten-Puffer",
  "manager.message_buffer.display_text": "INFO",
  "manager.message_buffer.category": "info",

  "manager.no_config_found.text": "Keine Konfiguration gefunden",
  "manager.no_config_found.display_text": "INFO",
  "manager.no_config_found.category": "info",

  "manager.poll_rate.text": "Polling-Rate",
  "manager.poll_rate.display_text": "INFO",
  "manager.poll_rate.category": "info",

  "manager.recommendation.all_good.text": "‚úÖ Alle Einstellungen optimal konfiguriert",
  "manager.recommendation.all_good.display_text": "INFO",
  "manager.recommendation.all_good.category": "info",

  "manager.recommendation.poll_rate_too_fast.text": "‚ö° poll_rate < 16ms: Sehr hohe CPU-Last - empfohlen: 16-33ms",
  "manager.recommendation.poll_rate_too_fast.display_text": "WARN",
  "manager.recommendation.poll_rate_too_fast.category": "warning",

  "manager.recommendation.too_many_messages.text": "üíæ Zu viele Nachrichten im Puffer - empfohlen: max 500",
  "manager.recommendation.too_many_messages.display_text": "WARN",
  "manager.recommendation.too_many_messages.category": "warning",

  "manager.recommendation.typewriter_too_fast.text": "‚å®Ô∏è typewriter_delay < 10ms: Sehr schnell - empfohlen: 30-100ms",
  "manager.recommendation.typewriter_too_fast.display_text": "WARN",
  "manager.recommendation.typewriter_too_fast.category": "warning",

  "manager.recommendations.text": "Empfehlungen",
  "manager.recommendations.display_text": "INFO",
  "manager.recommendations.category": "info",

  "manager.related_commands.text": "Verwandte Befehle",
  "manager.related_commands.display_text": "INFO",
  "manager.related_commands.category": "info",

  "manager.show_i18n_report.text": "Zeige i18n-Bericht",
  "manager.show_i18n_report.display_text": "INFO",
  "manager.show_i18n_report.category": "info",

  "manager.system_performance.text": "System-Performance",
  "manager.system_performance.display_text": "INFO",
  "manager.system_performance.category": "info",

  "manager.total_estimated.text": "Gesch√§tzt insgesamt",
  "manager.total_estimated.display_text": "INFO",
  "manager.total_estimated.category": "info",

  "manager.total_keys.text": "Gesamt-Schl√ºssel",
  "manager.total_keys.display_text": "INFO",
  "manager.total_keys.category": "info",

  "manager.typewriter_speed.text": "Schreibeffekt-Geschwindigkeit",
  "manager.typewriter_speed.display_text": "INFO",
  "manager.typewriter_speed.category": "info",

  "utils.duration.hours_minutes.text": "{0}h {1}min",
  "utils.duration.hours_minutes.display_text": "INFO",
  "utils.duration.hours_minutes.category": "info",

  "utils.duration.milliseconds.text": "{0}ms",
  "utils.duration.milliseconds.display_text": "INFO",
  "utils.duration.milliseconds.category": "info",

  "utils.duration.minutes_seconds.text": "{0}min {1}s",
  "utils.duration.minutes_seconds.display_text": "INFO",
  "utils.duration.minutes_seconds.category": "info",

  "utils.duration.seconds.text": "{0}s",
  "utils.duration.seconds.display_text": "INFO",
  "utils.duration.seconds.category": "info",

  "utils.size.bytes.text": "Bytes",
  "utils.size.bytes.display_text": "INFO",
  "utils.size.bytes.category": "info",

  "utils.size.GB.text": "GB",
  "utils.size.GB.display_text": "INFO",
  "utils.size.GB.category": "info",

  "utils.size.KB.text": "KB",
  "utils.size.KB.display_text": "INFO",
  "utils.size.KB.category": "info",

  "utils.size.MB.text": "MB",
  "utils.size.MB.display_text": "INFO",
  "utils.size.MB.category": "info",

  "utils.size.TB.text": "TB",
  "utils.size.TB.display_text": "INFO",
  "utils.size.TB.category": "info"
}

// ## END ##

// ## FILE: src/i18n/langs/de/system.json
// ## BEGIN ##
{
  "system.cleanup.i18n_cleared.text": "i18n-Cache geleert",
  "system.cleanup.i18n_cleared.display_text": "DEBUG",
  "system.cleanup.i18n_cleared.category": "debug",

  "system.config.dir_created.text": "Konfigurationsverzeichnis erstellt: {0}",
  "system.config.dir_created.display_text": "DEBUG",
  "system.config.dir_created.category": "debug",

  "system.config.dir_error.text": "Konnte Programmverzeichnis nicht ermitteln",
  "system.config.dir_error.display_text": "FEHLER",
  "system.config.dir_error.category": "error",

  "system.config.file_created.text": "Konfigurationsdatei erstellt: {0}",
  "system.config.file_created.display_text": "INFO",
  "system.config.file_created.category": "info",

  "system.config.language_set_failed.text": "Sprache konnte nicht gesetzt werden: {0}",
  "system.config.language_set_failed.display_text": "WARN",
  "system.config.language_set_failed.category": "warning",

  "system.config.load_error.text": "Fehler beim Laden neuer Konfiguration: {0}",
  "system.config.load_error.display_text": "FEHLER",
  "system.config.load_error.category": "error",

  "system.config.new_default.text": "‚úÖ Neue Standard-Konfiguration erstellt: {0}",
  "system.config.new_default.display_text": "INFO",
  "system.config.new_default.category": "info",

  "system.config.no_existing.text": "Keine existierende Konfiguration, erstelle Standard",
  "system.config.no_existing.display_text": "INFO",
  "system.config.no_existing.category": "info",

  "system.config.setup_failed.text": "Standard-Konfiguration fehlgeschlagen: {0}",
  "system.config.setup_failed.display_text": "FEHLER",
  "system.config.setup_failed.category": "error",

  "system.error.io.text": "IO-Fehler: {0}",
  "system.error.io.display_text": "FEHLER",
  "system.error.io.category": "error",

  "system.error.io_error.text": "IO-Fehler: {0}",
  "system.error.io_error.display_text": "ERROR",
  "system.error.io_error.category": "error",

  "system.error.terminal.text": "Terminal-Fehler: {0}",
  "system.error.terminal.display_text": "FEHLER",
  "system.error.terminal.category": "error",

  "system.error.terminal_error.text": "Terminal-Fehler: {0}",
  "system.error.terminal_error.display_text": "ERROR",
  "system.error.terminal_error.category": "error",

  "system.error.translation_error.text": "√úbersetzungsfehler: {0}",
  "system.error.translation_error.display_text": "ERROR",
  "system.error.translation_error.category": "error",

  "system.error.validation.text": "Validierungsfehler: {0}",
  "system.error.validation.display_text": "FEHLER",
  "system.error.validation.category": "error",

  "system.error.validation_error.text": "Validierungsfehler: {0}",
  "system.error.validation_error.display_text": "ERROR",
  "system.error.validation_error.category": "error",

  "system.input.cancel.short.text": "n",
  "system.input.cancel.short.display_text": "INFO",
  "system.input.cancel.short.category": "info",

  "system.input.cancelled.text": "Vorgang abgebrochen",
  "system.input.cancelled.display_text": "INFO",
  "system.input.cancelled.category": "info",

  "system.input.clipboard.cleared.text": "Eingabe gel√∂scht",
  "system.input.clipboard.cleared.display_text": "INPUT",
  "system.input.clipboard.cleared.category": "info",

  "system.input.clipboard.copied.text": "üìã Kopiert: \"{0}\"",
  "system.input.clipboard.copied.display_text": "CLIPBOARD",
  "system.input.clipboard.copied.category": "info",

  "system.input.clipboard.copy_failed.text": "‚ö™ Kopieren fehlgeschlagen",
  "system.input.clipboard.copy_failed.display_text": "CLIPBOARD",
  "system.input.clipboard.copy_failed.category": "error",

  "system.input.clipboard.cut.text": "üìã Ausgeschnitten: \"{0}\"",
  "system.input.clipboard.cut.display_text": "CLIPBOARD",
  "system.input.clipboard.cut.category": "info",

  "system.input.clipboard.empty.text": "‚ö™ Zwischenablage leer",
  "system.input.clipboard.empty.display_text": "CLIPBOARD",
  "system.input.clipboard.empty.category": "warning",

  "system.input.clipboard.nothing_to_copy.text": "‚ö™ Nichts zum Kopieren",
  "system.input.clipboard.nothing_to_copy.display_text": "CLIPBOARD",
  "system.input.clipboard.nothing_to_copy.category": "warning",

  "system.input.clipboard.nothing_to_paste.text": "‚ö™ Nichts zum Einf√ºgen",
  "system.input.clipboard.nothing_to_paste.display_text": "CLIPBOARD",
  "system.input.clipboard.nothing_to_paste.category": "warning",

  "system.input.clipboard.pasted.text": "üìã Eingef√ºgt: {0} Zeichen",
  "system.input.clipboard.pasted.display_text": "CLIPBOARD",
  "system.input.clipboard.pasted.category": "info",

  "system.input.confirm.short.text": "j",
  "system.input.confirm.short.display_text": "INFO",
  "system.input.confirm.short.category": "info",

  "system.input.confirm_exit.text": "M√∂chten Sie das Programm wirklich beenden? (j/n)",
  "system.input.confirm_exit.display_text": "BEST√ÑTIGEN",
  "system.input.confirm_exit.category": "warning",

  "system.input.empty.text": "Eingabe darf nicht leer sein",
  "system.input.empty.display_text": "WARN",
  "system.input.empty.category": "warning",

  "system.input.history_cleared.text": "Historie wurde gel√∂scht",
  "system.input.history_cleared.display_text": "INFO",
  "system.input.history_cleared.category": "info",

  "system.input.too_long.text": "Eingabe zu lang (Maximum: {0} Zeichen)",
  "system.input.too_long.display_text": "WARN",
  "system.input.too_long.category": "warning",

  "system.startup.i18n_initialized.text": "i18n-System initialisiert f√ºr Sprache: {0}",
  "system.startup.i18n_initialized.display_text": "BEREIT",
  "system.startup.i18n_initialized.category": "info",

  "system.startup.logger_init_failed.text": "Logger-Initialisierung fehlgeschlagen: {0}",
  "system.startup.logger_init_failed.display_text": "FEHLER",
  "system.startup.logger_init_failed.category": "error",

  "system.startup.version.text": "Willkommen zu Rush Sync Version {0}",
  "system.startup.version.display_text": "BEREIT",
  "system.startup.version.category": "startup",

  "terminal.cleanup.done.text": "‚úÖ Terminal wurde korrekt zur√ºckgesetzt",
  "terminal.cleanup.done.display_text": "BEREIT",
  "terminal.cleanup.done.category": "info",

  "terminal.manager.emergency_cleanup.text": "üö® Notfall-Terminal-Bereinigung im Destruktor",
  "terminal.manager.emergency_cleanup.display_text": "TERMINAL",
  "terminal.manager.emergency_cleanup.category": "warning",

  "terminal.manager.raw_mode_lost.text": "‚ö† Raw-Modus verloren, wird wieder aktiviert...",
  "terminal.manager.raw_mode_lost.display_text": "TERMINAL",
  "terminal.manager.raw_mode_lost.category": "warning",

  "terminal.setup.done.text": "‚úÖ Terminal initialisiert",
  "terminal.setup.done.display_text": "BEREIT",
  "terminal.setup.done.category": "info"
}

// ## END ##

// ## FILE: src/i18n/langs/en/config.json
// ## BEGIN ##
{
  "config.config_backup_created.text": "Config backup created: {0}",
  "config.config_backup_created.display_text": "DEBUG",
  "config.config_backup_created.category": "debug",

  "config.config_successfully_written_to.text": "Configuration successfully written to: {0}",
  "config.config_successfully_written_to.display_text": "DEBUG",
  "config.config_successfully_written_to.category": "debug",

  "config.corrected.poll_rate.text": "poll_rate: {0}ms ‚Üí {1}ms (corrected)",
  "config.corrected.poll_rate.display_text": "WARN",
  "config.corrected.poll_rate.category": "warning",

  "config.corrected.typewriter.text": "typewriter_delay: {0}ms ‚Üí {1}ms (corrected)",
  "config.corrected.typewriter.display_text": "WARN",
  "config.corrected.typewriter.category": "warning",

  "config.corrected_values.text": "üîß Invalid config values corrected and saved:",
  "config.corrected_values.display_text": "WARN",
  "config.corrected_values.category": "warning",

  "config.could_not_create_backup.text": "Could not create backup: {0}",
  "config.could_not_create_backup.display_text": "WARN",
  "config.could_not_create_backup.category": "warning",

  "config.creating_config_directory.text": "Creating config directory: {0}",
  "config.creating_config_directory.display_text": "DEBUG",
  "config.creating_config_directory.category": "debug",

  "config.current_theme.text": "Current theme: {0}",
  "config.current_theme.display_text": "DEBUG",
  "config.current_theme.category": "debug",

  "config.failed_to_create_config_directory.text": "Failed to create config directory: {0}",
  "config.failed_to_create_config_directory.display_text": "ERROR",
  "config.failed_to_create_config_directory.category": "error",

  "config.failed_to_rename_temp_file.text": "Failed to rename temp file: {0}",
  "config.failed_to_rename_temp_file.display_text": "ERROR",
  "config.failed_to_rename_temp_file.category": "error",

  "config.failed_to_write_temp_config_file.text": "Failed to write temp config file: {0}",
  "config.failed_to_write_temp_config_file.display_text": "ERROR",
  "config.failed_to_write_temp_config_file.category": "error",

  "config.poll_rate.too_fast.text": "poll_rate {0}ms too fast, using minimum: {1}ms",
  "config.poll_rate.too_fast.display_text": "WARN",
  "config.poll_rate.too_fast.category": "warning",

  "config.poll_rate.too_slow.text": "poll_rate {0}ms too slow, using maximum: {1}ms",
  "config.poll_rate.too_slow.display_text": "WARN",
  "config.poll_rate.too_slow.category": "warning",

  "config.poll_rate.zero.text": "poll_rate = 0 not allowed, using minimum: {0}ms",
  "config.poll_rate.zero.display_text": "WARN",
  "config.poll_rate.zero.category": "warning",

  "config.save_failed.text": "Could not save corrected config: {0}",
  "config.save_failed.display_text": "ERROR",
  "config.save_failed.category": "error",

  "config.save_success.text": "‚úÖ Corrected values saved to config file",
  "config.save_success.display_text": "INFO",
  "config.save_success.category": "info",

  "config.saved_current_theme_to_config.text": "Current theme saved to config: {0}",
  "config.saved_current_theme_to_config.display_text": "INFO",
  "config.saved_current_theme_to_config.category": "info",

  "config.saving_config_to.text": "Saving configuration to: {0}",
  "config.saving_config_to.display_text": "DEBUG",
  "config.saving_config_to.category": "debug",

  "config.switch_theme_to.text": "Switching theme to: {0}",
  "config.switch_theme_to.display_text": "DEBUG",
  "config.switch_theme_to.category": "debug",

  "config.toml_serialization_failed.text": "TOML serialization failed: {0}",
  "config.toml_serialization_failed.display_text": "ERROR",
  "config.toml_serialization_failed.category": "error",

  "config.typewriter.off.text": "typewriter_delay = 0 ‚Üí Typewriter effect disabled",
  "config.typewriter.off.display_text": "INFO",
  "config.typewriter.off.category": "info",

  "config.typewriter.too_slow.text": "typewriter_delay {0}ms too slow, using maximum: {1}ms",
  "config.typewriter.too_slow.display_text": "WARN",
  "config.typewriter.too_slow.category": "warning",

  "config.validation.invalid_color.text": "Invalid color: {0}",
  "config.validation.invalid_color.display_text": "CONFIG",
  "config.validation.invalid_color.category": "error",

  "config.validation.invalid_log_level.text": "Invalid log level in config: '{0}', using INFO",
  "config.validation.invalid_log_level.display_text": "CONFIG",
  "config.validation.invalid_log_level.category": "warning",

  "config.validation.theme_load_failed.text": "Theme load failed: {0}",
  "config.validation.theme_load_failed.display_text": "CONFIG",
  "config.validation.theme_load_failed.category": "error",

  "config.validation.theme_not_found.text": "Theme '{0}' not found",
  "config.validation.theme_not_found.display_text": "CONFIG",
  "config.validation.theme_not_found.category": "error",

  "config.validation.toml_error.text": "TOML error: {0}",
  "config.validation.toml_error.display_text": "CONFIG",
  "config.validation.toml_error.category": "error",

  "language.service.config_load_error.text": "Config load error: {0}",
  "language.service.config_load_error.display_text": "LANG",
  "language.service.config_load_error.category": "error",

  "language.service.config_save_error.text": "Config save error: {0}",
  "language.service.config_save_error.display_text": "LANG",
  "language.service.config_save_error.category": "error",

  "language.service.save_failed.text": "Failed to save language config: {0}",
  "language.service.save_failed.display_text": "LANG",
  "language.service.save_failed.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/en/common.json
// ## BEGIN ##
{
  "debug.text": "Debug",
  "debug.display_text": "DEBUG",
  "debug.category": "debug",

  "error.text": "Error",
  "error.display_text": "ERROR",
  "error.category": "error",

  "info.text": "Information",
  "info.display_text": "INFO",
  "info.category": "info",

  "trace.text": "Trace",
  "trace.display_text": "TRACE",
  "trace.category": "trace",

  "warn.text": "Warning",
  "warn.display_text": "WARN",
  "warn.category": "warning"
}

// ## END ##

// ## FILE: src/i18n/langs/en/cmd_help.json
// ## BEGIN ##
{
  "system.commands.help.header.text": "Available Commands",
  "system.commands.help.header.display_text": "HELP",
  "system.commands.help.header.category": "info",

  "system.commands.help.footer.text": "Use 'help <command>' for detailed help on a command.",
  "system.commands.help.footer.display_text": "HELP",
  "system.commands.help.footer.category": "info",

  "system.commands.help.no_commands.text": "No commands available.",
  "system.commands.help.no_commands.display_text": "HELP",
  "system.commands.help.no_commands.category": "warning",

  "system.commands.help.category.server_control.text": "Server Control",
  "system.commands.help.category.server_control.display_text": "HELP",
  "system.commands.help.category.server_control.category": "info",

  "system.commands.help.category.server_management.text": "Server Management",
  "system.commands.help.category.server_management.display_text": "HELP",
  "system.commands.help.category.server_management.category": "info",

  "system.commands.help.category.maintenance.text": "Maintenance",
  "system.commands.help.category.maintenance.display_text": "HELP",
  "system.commands.help.category.maintenance.category": "info",

  "system.commands.help.category.configuration.text": "Configuration",
  "system.commands.help.category.configuration.display_text": "HELP",
  "system.commands.help.category.configuration.category": "info",

  "system.commands.help.category.information.text": "Information",
  "system.commands.help.category.information.display_text": "HELP",
  "system.commands.help.category.information.category": "info",

  "system.commands.help.category.system.text": "System",
  "system.commands.help.category.system.display_text": "HELP",
  "system.commands.help.category.system.category": "info",

  "system.commands.help.category.other.text": "Other",
  "system.commands.help.category.other.display_text": "HELP",
  "system.commands.help.category.other.category": "info",

  "system.commands.help.simple_list.text": "Available commands: {0}",
  "system.commands.help.simple_list.display_text": "HELP",
  "system.commands.help.simple_list.category": "info",

  "system.commands.help.detailed_header.text": "All Available Commands (Detailed):",
  "system.commands.help.detailed_header.display_text": "HELP",
  "system.commands.help.detailed_header.category": "info",

  "system.commands.help.detailed_separator.text": "=====================================",
  "system.commands.help.detailed_separator.display_text": "HELP",
  "system.commands.help.detailed_separator.category": "info",

  "system.commands.help.command_label.text": "Command:",
  "system.commands.help.command_label.display_text": "HELP",
  "system.commands.help.command_label.category": "info",

  "system.commands.help.description_label.text": "Description:",
  "system.commands.help.description_label.display_text": "HELP",
  "system.commands.help.description_label.category": "info",

  "system.commands.help.usage_label.text": "Usage:",
  "system.commands.help.usage_label.display_text": "HELP",
  "system.commands.help.usage_label.category": "info",

  "system.commands.help.command_separator.text": "-------------------------------------",
  "system.commands.help.command_separator.display_text": "HELP",
  "system.commands.help.command_separator.category": "info",

  "system.commands.help.specific_help_template.text": "Help for command '{0}':\n\nDescription: {1}\n\nUsage: {2} [options]\n\nFor more details, try: {3} --help",
  "system.commands.help.specific_help_template.display_text": "HELP",
  "system.commands.help.specific_help_template.category": "info",

  "system.commands.help.command_not_found.text": "Command '{0}' not found. Use 'help' to see all available commands.",
  "system.commands.help.command_not_found.display_text": "HELP",
  "system.commands.help.command_not_found.category": "warning",

  "_comment": "=== COMMAND DESCRIPTIONS ===",

  "system.commands.log_level.description.text": "Change application log level",
  "system.commands.log_level.description.display_text": "HELP",
  "system.commands.log_level.description.category": "info",

  "system.commands.language.description.text": "Change application language",
  "system.commands.language.description.display_text": "HELP",
  "system.commands.language.description.category": "info",

  "system.commands.theme.description.text": "Change application theme (live update without restart, loaded from TOML)",
  "system.commands.theme.description.display_text": "HELP",
  "system.commands.theme.description.category": "info",

  "system.commands.help.description.text": "Show all available commands",
  "system.commands.help.description.display_text": "HELP",
  "system.commands.help.description.category": "info",

  "system.commands.version.description.text": "Show application version",
  "system.commands.version.description.display_text": "HELP",
  "system.commands.version.description.category": "info",

  "system.commands.history.description.text": "Manage command history",
  "system.commands.history.description.display_text": "HELP",
  "system.commands.history.description.category": "info",

  "system.commands.recover.description.text": "Recover and fix server status inconsistencies",
  "system.commands.recover.description.display_text": "HELP",
  "system.commands.recover.description.category": "info",

  "system.commands.cleanup.description.text": "Clean up servers, logs, and www files - supports confirmation and force flags",
  "system.commands.cleanup.description.display_text": "HELP",
  "system.commands.cleanup.description.category": "info",

  "system.commands.restart.description.text": "Restart the application",
  "system.commands.restart.description.display_text": "HELP",
  "system.commands.restart.description.category": "info",

  "system.commands.start.description.text": "Start server(s) - supports ranges and bulk operations",
  "system.commands.start.description.display_text": "HELP",
  "system.commands.start.description.category": "info",

  "system.commands.stop.description.text": "Stop server(s) - supports ranges and bulk operations",
  "system.commands.stop.description.display_text": "HELP",
  "system.commands.stop.description.category": "info",

  "system.commands.create.description.text": "Create web server(s) - supports bulk creation",
  "system.commands.create.description.display_text": "HELP",
  "system.commands.create.description.category": "info",

  "system.commands.list.description.text": "List all web servers (persistent)",
  "system.commands.list.description.display_text": "HELP",
  "system.commands.list.description.category": "info",

  "system.commands.clear.description.text": "Clear the screen",
  "system.commands.clear.description.display_text": "HELP",
  "system.commands.clear.description.category": "info",

  "system.commands.exit.description.text": "Exit the application",
  "system.commands.exit.description.display_text": "HELP",
  "system.commands.exit.description.category": "info"
}

// ## END ##

// ## FILE: src/i18n/langs/en/history.json
// ## BEGIN ##
{
  "history.manager.cleared.text": "üìÇ History cleared",
  "history.manager.cleared.display_text": "HISTORY",
  "history.manager.cleared.category": "info",

  "history.manager.loaded_entries.text": "üìÇ Loaded {0} history entries",
  "history.manager.loaded_entries.display_text": "HISTORY",
  "history.manager.loaded_entries.category": "debug",

  "history.manager.save_failed.text": "Failed to save history: {0}",
  "history.manager.save_failed.display_text": "HISTORY",
  "history.manager.save_failed.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/en/commands.json
// ## BEGIN ##
{
  "system.commands.cleanup.confirm_stopped.text": "Delete stopped servers? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_stopped.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_stopped.category": "warning",

  "system.commands.cleanup.confirm_failed.text": "Delete failed servers? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_failed.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_failed.category": "warning",

  "system.commands.cleanup.confirm_logs.text": "Delete all server logs? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_logs.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_logs.category": "warning",

  "system.commands.cleanup.confirm_all.text": "Complete cleanup (servers, logs, WWW folders)? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_all.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_all.category": "warning",

  "system.commands.cleanup.confirm_www_server.text": "Delete WWW folder for server '{0}'? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_www_server.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_www_server.category": "warning",

  "system.commands.cleanup.confirm_www_all.text": "Delete complete WWW folder? This cannot be undone. (y/n)",
  "system.commands.cleanup.confirm_www_all.display_text": "CONFIRM",
  "system.commands.cleanup.confirm_www_all.category": "warning",

  "system.commands.cleanup.stopped_success.text": "{0} stopped servers removed (persistently saved)",
  "system.commands.cleanup.stopped_success.display_text": "CLEANUP",
  "system.commands.cleanup.stopped_success.category": "info",

  "system.commands.cleanup.no_stopped.text": "No stopped servers found to remove",
  "system.commands.cleanup.no_stopped.display_text": "CLEANUP",
  "system.commands.cleanup.no_stopped.category": "info",

  "system.commands.cleanup.failed_success.text": "{0} failed servers removed (persistently saved)",
  "system.commands.cleanup.failed_success.display_text": "CLEANUP",
  "system.commands.cleanup.failed_success.category": "info",

  "system.commands.cleanup.no_failed.text": "No failed servers found to remove",
  "system.commands.cleanup.no_failed.display_text": "CLEANUP",
  "system.commands.cleanup.no_failed.category": "info",

  "system.commands.cleanup.logs_started.text": "Server log cleanup started...",
  "system.commands.cleanup.logs_started.display_text": "CLEANUP",
  "system.commands.cleanup.logs_started.category": "info",

  "system.commands.cleanup.logs_success.text": "Server logs cleaned: {0} files deleted, {1}MB freed",
  "system.commands.cleanup.logs_success.display_text": "CLEANUP",
  "system.commands.cleanup.logs_success.category": "info",

  "system.commands.cleanup.no_logs_dir.text": "No servers/ directory found",
  "system.commands.cleanup.no_logs_dir.display_text": "CLEANUP",
  "system.commands.cleanup.no_logs_dir.category": "info",

  "system.commands.cleanup.www_server_started.text": "WWW cleanup for '{0}' started...",
  "system.commands.cleanup.www_server_started.display_text": "CLEANUP",
  "system.commands.cleanup.www_server_started.category": "info",

  "system.commands.cleanup.www_all_started.text": "Complete WWW cleanup started...",
  "system.commands.cleanup.www_all_started.display_text": "CLEANUP",
  "system.commands.cleanup.www_all_started.category": "info",

  "system.commands.cleanup.www_server_success.text": "WWW for server '{0}' cleaned: {1} directories deleted, {2}MB freed",
  "system.commands.cleanup.www_server_success.display_text": "CLEANUP",
  "system.commands.cleanup.www_server_success.category": "info",

  "system.commands.cleanup.www_all_success.text": "WWW directory completely cleaned: {0} directories, {1} files deleted, {2}MB freed",
  "system.commands.cleanup.www_all_success.display_text": "CLEANUP",
  "system.commands.cleanup.www_all_success.category": "info",

  "system.commands.cleanup.no_www_dir.text": "No www/ directory found",
  "system.commands.cleanup.no_www_dir.display_text": "CLEANUP",
  "system.commands.cleanup.no_www_dir.category": "info",

  "system.commands.cleanup.no_www_for_server.text": "No WWW directories found for server '{0}'",
  "system.commands.cleanup.no_www_for_server.display_text": "CLEANUP",
  "system.commands.cleanup.no_www_for_server.category": "info",

  "system.commands.cleanup.async_started.text": "Server logs and WWW files are being cleaned...",
  "system.commands.cleanup.async_started.display_text": "CLEANUP",
  "system.commands.cleanup.async_started.category": "info",

  "system.commands.cleanup.usage.text": "Usage: cleanup [stopped|failed|logs|www|all] [server_name] or cleanup --force-[type]",
  "system.commands.cleanup.usage.display_text": "CLEANUP",
  "system.commands.cleanup.usage.category": "info",

  "system.commands.history.confirm_clear.text": "Do you really want to clear the entire command history? (y/n)",
  "system.commands.history.confirm_clear.display_text": "CONFIRM",
  "system.commands.history.confirm_clear.category": "warning",

  "system.commands.history.help.text": "üìÇ History Commands:\n  history        Show this help\n  history -c     Clear history\n  ‚Üë ‚Üì           Navigate history\n\n  File: ~/.rss/rush.history",
  "system.commands.history.help.display_text": "HISTORY",
  "system.commands.history.help.category": "info",

  "system.commands.history.usage.text": "üìÇ Use ‚Üë‚Üì arrows to navigate, 'history -c' to clear",
  "system.commands.history.usage.display_text": "HISTORY",
  "system.commands.history.usage.category": "info",

  "system.commands.language.available.text": "Available languages: {0}",
  "system.commands.language.available.display_text": "LANG",
  "system.commands.language.available.category": "lang",

  "system.commands.language.changed.text": "‚úÖ Language switched to: {0}",
  "system.commands.language.changed.display_text": "LANG",
  "system.commands.language.changed.category": "lang",

  "system.commands.language.current.text": "Current language: {0}",
  "system.commands.language.current.display_text": "LANG",
  "system.commands.language.current.category": "lang",

  "system.commands.language.invalid.text": "‚ö´ Invalid language: {0}",
  "system.commands.language.invalid.display_text": "ERROR",
  "system.commands.language.invalid.category": "error",

  "system.commands.log_level.changed_persistent.text": "‚úÖ Log level changed to: {0} ({1}) - Saved persistently",
  "system.commands.log_level.changed_persistent.display_text": "INFO",
  "system.commands.log_level.changed_persistent.category": "info",

  "system.commands.log_level.changed_success.text": "‚úÖ Log level changed to: {0} ({1}) - Saved persistently",
  "system.commands.log_level.changed_success.display_text": "LOG_LEVEL",
  "system.commands.log_level.changed_success.category": "info",

  "system.commands.log_level.current.text": "Current log level: {0} ({1})",
  "system.commands.log_level.current.display_text": "INFO",
  "system.commands.log_level.current.category": "info",

  "system.commands.log_level.current_status.text": "Current log level: {0} ({1})",
  "system.commands.log_level.current_status.display_text": "LOG_LEVEL",
  "system.commands.log_level.current_status.category": "info",

  "system.commands.log_level.help.text": "Available log levels:\n  1 = ERROR   (Only critical errors)\n  2 = WARN    (Warnings and errors)\n  3 = INFO    (General information) [DEFAULT]\n  4 = DEBUG   (Debug information)\n  5 = TRACE   (Very detailed tracing)\n\nUsage:\n  log-level           Show current level\n  log-level 3         Set to INFO level\n  log-level DEBUG     Set to DEBUG level\n  log-level -h        Show this help",
  "system.commands.log_level.help.display_text": "INFO",
  "system.commands.log_level.help.category": "info",

  "system.commands.log_level.help_text.text": "Available log levels:\n  1 = ERROR   (Only critical errors)\n  2 = WARN    (Warnings and errors)\n  3 = INFO    (General information) [DEFAULT]\n  4 = DEBUG   (Debug information)\n  5 = TRACE   (Very detailed tracing)\n\nUsage:\n  log-level           Show current level\n  log-level 3         Set to INFO level\n  log-level DEBUG     Set to DEBUG level\n  log-level -h        Show this help",
  "system.commands.log_level.help_text.display_text": "LOG_LEVEL",
  "system.commands.log_level.help_text.category": "info",

  "system.commands.log_level.invalid.text": "‚ö´ Invalid log level: {0}. Available: 1-5, error, warn, info, debug, trace",
  "system.commands.log_level.invalid.display_text": "ERROR",
  "system.commands.log_level.invalid.category": "error",

  "system.commands.log_level.invalid_level.text": "‚ö´ Invalid log level: {0}. Available: 1-5, error, warn, info, debug, trace",
  "system.commands.log_level.invalid_level.display_text": "LOG_LEVEL",
  "system.commands.log_level.invalid_level.category": "error",

  "system.commands.performance.help.text": "Performance Command Help:\n  perf                   Show performance status\n  performance           Same as perf\n  stats                 Same as perf\n  perf -h               Show this help",
  "system.commands.performance.help.display_text": "INFO",
  "system.commands.performance.help.category": "info",

  "system.commands.performance.unknown.text": "Unknown performance parameter. Use 'perf -h' for help.",
  "system.commands.performance.unknown.display_text": "ERROR",
  "system.commands.performance.unknown.category": "error",

  "system.commands.restart.confirm.text": "Do you really want to perform a restart? (y/n)",
  "system.commands.restart.confirm.display_text": "CONFIRM",
  "system.commands.restart.confirm.category": "warning",

  "system.commands.restart.help.text": "Available restart commands:\n  restart           Restart with confirmation\n  restart --force   Immediate restart",
  "system.commands.restart.help.display_text": "INFO",
  "system.commands.restart.help.category": "info",

  "system.commands.restart.success.text": "üîÑ Restart completed successfully",
  "system.commands.restart.success.display_text": "INFO",
  "system.commands.restart.success.category": "info",

  "system.commands.restart.unknown.text": "Unknown restart parameter. Use 'restart -h' for help.",
  "system.commands.restart.unknown.display_text": "ERROR",
  "system.commands.restart.unknown.category": "error",

  "system.commands.theme.add_sections_hint.text": "üí° Add [theme.xyz] sections to rush.toml",
  "system.commands.theme.add_sections_hint.display_text": "THEME",
  "system.commands.theme.add_sections_hint.category": "info",

  "system.commands.theme.changed_success.text": "üé® Theme changed to: {0} ‚ú®",
  "system.commands.theme.changed_success.display_text": "THEME",
  "system.commands.theme.changed_success.category": "theme",

  "system.commands.theme.current_status.text": "Current theme: {0} (from TOML)\nAvailable: {1}",
  "system.commands.theme.current_status.display_text": "THEME",
  "system.commands.theme.current_status.category": "info",

  "system.commands.theme.debug_details.text": "üìÇ Theme '{0}':\ninput_text: '{1}'\ninput_bg: '{2}'\noutput_text: '{3}'\noutput_bg: '{4}'\ninput_cursor_prefix: '{5}'\ninput_cursor_color: '{6}'\ninput_cursor: '{7}'\noutput_cursor: '{8}'\noutput_cursor_color: '{9}'",
  "system.commands.theme.debug_details.display_text": "THEME",
  "system.commands.theme.debug_details.category": "info",

  "system.commands.theme.debug_missing_name.text": "‚ö´ Theme name missing. Usage: theme debug <name>",
  "system.commands.theme.debug_missing_name.display_text": "THEME",
  "system.commands.theme.debug_missing_name.category": "error",

  "system.commands.theme.debug_not_found.text": "‚ö´ Theme '{0}' not found!",
  "system.commands.theme.debug_not_found.display_text": "THEME",
  "system.commands.theme.debug_not_found.category": "error",

  "system.commands.theme.help.add_sections.text": "üìÇ Add any [theme.your_name] sections for new themes",
  "system.commands.theme.help.add_sections.display_text": "THEME",
  "system.commands.theme.help.add_sections.category": "info",

  "system.commands.theme.help.cursor_config.text": "üéØ NEW: Cursor configuration via output_cursor + output_color!",
  "system.commands.theme.help.cursor_config.display_text": "THEME",
  "system.commands.theme.help.cursor_config.category": "info",

  "system.commands.theme.help.cursor_options.text": "üéõÔ∏è Cursor Options:\n‚Ä¢ output_cursor: BLOCK, PIPE, UNDERSCORE\n‚Ä¢ output_color: Any supported color (White, Green, etc.)",
  "system.commands.theme.help.cursor_options.display_text": "THEME",
  "system.commands.theme.help.cursor_options.category": "info",

  "system.commands.theme.help.header.text": "üé® TOML-Theme Commands (Live Update - Loaded from rush.toml!):",
  "system.commands.theme.help.header.display_text": "THEME",
  "system.commands.theme.help.header.category": "info",

  "system.commands.theme.help.live_changes.text": "üîÑ Changes are applied immediately (no restart needed)",
  "system.commands.theme.help.live_changes.display_text": "THEME",
  "system.commands.theme.help.live_changes.category": "info",

  "system.commands.theme.help.live_loaded.text": "‚ú® All themes are loaded LIVE from [theme.*] sections in rush.toml!",
  "system.commands.theme.help.live_loaded.display_text": "THEME",
  "system.commands.theme.help.live_loaded.category": "info",

  "system.commands.theme.help.preview_theme.text": "theme preview <name> Preview theme colors + cursor config ‚úÖ NEW!",
  "system.commands.theme.help.preview_theme.display_text": "THEME",
  "system.commands.theme.help.preview_theme.category": "info",

  "system.commands.theme.help.select_theme.text": "theme <name>         Select theme: {0}",
  "system.commands.theme.help.select_theme.display_text": "THEME",
  "system.commands.theme.help.select_theme.category": "info",

  "system.commands.theme.help.show_help.text": "theme -h             Show this help",
  "system.commands.theme.help.show_help.display_text": "THEME",
  "system.commands.theme.help.show_help.category": "info",

  "system.commands.theme.help.show_themes.text": "theme                Show available TOML-themes",
  "system.commands.theme.help.show_themes.display_text": "THEME",
  "system.commands.theme.help.show_themes.category": "info",

  "system.commands.theme.how_to_add_themes.text": "üìÇ Add [theme.my_theme] sections to rush.toml:\n\n[theme.my_theme]\ninput_text = \"White\"\ninput_bg = \"Black\"\ncursor = \"Green\"\noutput_text = \"Gray\"\noutput_bg = \"Black\"\nprompt_text = \">> \"\nprompt_color = \"Cyan\"\noutput_cursor = \"BLOCK\"\noutput_color = \"LightGreen\"",
  "system.commands.theme.how_to_add_themes.display_text": "THEME",
  "system.commands.theme.how_to_add_themes.category": "info",

  "system.commands.theme.load_failed.text": "‚ö´ Theme system failed to load: {0}",
  "system.commands.theme.load_failed.display_text": "THEME",
  "system.commands.theme.load_failed.category": "error",

  "system.commands.theme.no_themes_available.text": "‚ö´ No themes available!",
  "system.commands.theme.no_themes_available.display_text": "THEME",
  "system.commands.theme.no_themes_available.category": "error",

  "system.commands.theme.no_themes_found.text": "‚ö´ No themes available! Add [theme.xyz] sections to rush.toml.",
  "system.commands.theme.no_themes_found.display_text": "THEME",
  "system.commands.theme.no_themes_found.category": "error",

  "system.commands.theme.no_themes_hint.text": "No themes found in configuration.",
  "system.commands.theme.no_themes_hint.display_text": "THEME",
  "system.commands.theme.no_themes_hint.category": "warning",

  "system.commands.theme.not_found.text": "‚ö´ Theme '{0}' not found. Available: {1}",
  "system.commands.theme.not_found.display_text": "THEME",
  "system.commands.theme.not_found.category": "error",

  "system.commands.theme.preview_details.text": "üé® Theme '{0}' Preview:\nInput: {1} on {2}\nOutput: {3} on {4}\nCursor Prefix: '{5}' in {6}\nInput Cursor: {7}\nOutput Cursor: {8} in {9}\n\nüìÇ Source: [theme.{10}] in rush.toml",
  "system.commands.theme.preview_details.display_text": "THEME",
  "system.commands.theme.preview_details.category": "theme",

  "system.commands.theme.preview_missing_name.text": "‚ö´ Theme name missing. Usage: theme preview <name>",
  "system.commands.theme.preview_missing_name.display_text": "THEME",
  "system.commands.theme.preview_missing_name.category": "error",

  "system.commands.unknown.text": "Unknown command: {0}",
  "system.commands.unknown.display_text": "ERROR",
  "system.commands.unknown.category": "error",

  "system.commands.version.text": "Rush Sync Server Version {0}",
  "system.commands.version.display_text": "VERSION",
  "system.commands.version.category": "version"
}

// ## END ##

// ## FILE: src/i18n/langs/en/ui.json
// ## BEGIN ##
{
  "screen.performance_command_detected.text": "üîß Performance command '{0}' detected",
  "screen.performance_command_detected.display_text": "DEBUG",
  "screen.performance_command_detected.category": "debug",

  "screen.performance_command_viewport_reset_applied.text": "‚úÖ Performance command: viewport reset applied",
  "screen.performance_command_viewport_reset_applied.display_text": "DEBUG",
  "screen.performance_command_viewport_reset_applied.category": "debug",

  "screen.render.empty_buffer_error.text": "ERROR: Empty buffer",
  "screen.render.empty_buffer_error.display_text": "RENDER",
  "screen.render.empty_buffer_error.category": "error",

  "screen.render.exceed_bounds_log.text": "Layout exceeds terminal bounds: {0}x{1}",
  "screen.render.exceed_bounds_log.display_text": "ERROR",
  "screen.render.exceed_bounds_log.category": "error",

  "screen.render.invalid_layout.text": "‚ö†Ô∏è INVALID LAYOUT",
  "screen.render.invalid_layout.display_text": "RENDER",
  "screen.render.invalid_layout.category": "error",

  "screen.render.invalid_layout_log.text": "Invalid layout: Output={0}x{1}+{2}+{3}, Input={4}x{5}+{6}+{7}",
  "screen.render.invalid_layout_log.display_text": "ERROR",
  "screen.render.invalid_layout_log.category": "error",

  "screen.render.terminal_too_small.text": "Terminal too small!\nMinimum: 10x5",
  "screen.render.terminal_too_small.display_text": "RENDER",
  "screen.render.terminal_too_small.category": "error",

  "screen.render.too_small.text": "Terminal too small!\nMinimum: 10x5",
  "screen.render.too_small.display_text": "ERROR",
  "screen.render.too_small.category": "error",

  "screen.render.too_small_log.text": "Screen too small for safe rendering: {0}x{1}",
  "screen.render.too_small_log.display_text": "ERROR",
  "screen.render.too_small_log.category": "error",

  "screen.render.viewport_error.text": "Viewport error!\nRestart terminal.",
  "screen.render.viewport_error.display_text": "ERROR",
  "screen.render.viewport_error.category": "error",

  "screen.render.viewport_not_usable_log.text": "Viewport not usable",
  "screen.render.viewport_not_usable_log.display_text": "ERROR",
  "screen.render.viewport_not_usable_log.category": "error",

  "screen.resize_completed.text": "‚úÖ Resize completed: {0}",
  "screen.resize_completed.display_text": "INFO",
  "screen.resize_completed.category": "info",

  "screen.resize_event.text": "üîÑ RESIZE EVENT: {0}x{1} ‚Üí {2}x{3}",
  "screen.resize_event.display_text": "INFO",
  "screen.resize_event.category": "info",

  "screen.restart.done.text": "‚úÖ Internal restart completed successfully",
  "screen.restart.done.display_text": "INFO",
  "screen.restart.done.category": "info",

  "screen.restart.failed.text": "Restart failed: {0}",
  "screen.restart.failed.display_text": "SYSTEM",
  "screen.restart.failed.category": "error",

  "screen.restart.start.text": "üîÑ Performing internal restart...",
  "screen.restart.start.display_text": "INFO",
  "screen.restart.start.category": "info",

  "screen.restart.success.text": "üîÑ Restart completed successfully",
  "screen.restart.success.display_text": "SYSTEM",
  "screen.restart.success.category": "info",

  "screen.theme.applied.text": "Theme '{0}' applied: Prompt='{1}', History={2} entries",
  "screen.theme.applied.display_text": "INFO",
  "screen.theme.applied.category": "info",

  "screen.theme.invalid_format.text": "Invalid theme update format",
  "screen.theme.invalid_format.display_text": "ERROR",
  "screen.theme.invalid_format.category": "error",

  "screen.theme.load_failed.text": "Theme system load failed: {0}",
  "screen.theme.load_failed.display_text": "THEME",
  "screen.theme.load_failed.category": "error",

  "screen.theme.not_found.text": "Theme '{0}' not found",
  "screen.theme.not_found.display_text": "THEME",
  "screen.theme.not_found.category": "error",

  "screen.theme.not_found_feedback.text": "‚ö´ Theme '{0}' not found",
  "screen.theme.not_found_feedback.display_text": "ERROR",
  "screen.theme.not_found_feedback.category": "error",

  "screen.theme.processing.text": "üé® Live theme update is being processed: {0}",
  "screen.theme.processing.display_text": "DEBUG",
  "screen.theme.processing.category": "debug",

  "screen.theme.switched_success.text": "‚úÖ Theme switched to: {0}",
  "screen.theme.switched_success.display_text": "THEME",
  "screen.theme.switched_success.category": "info",

  "system.cleanup.i18n_cleared.text": "i18n cache cleared",
  "system.cleanup.i18n_cleared.display_text": "DEBUG",
  "system.cleanup.i18n_cleared.category": "debug",

  "viewport.layout.broken.text": "üö® Layout badly damaged, emergency mode activated",
  "viewport.layout.broken.display_text": "ERROR",
  "viewport.layout.broken.category": "error",

  "viewport.layout.calculated.text": "Layout calculated: Terminal={0}x{1}, Output={2}x{3}+{4}+{5}, Input={6}x{7}+{8}+{9}, Window={10}",
  "viewport.layout.calculated.display_text": "TRACE",
  "viewport.layout.calculated.category": "trace",

  "viewport.layout.failed.text": "Layout calculation failed: Input={0}, Output={1}, Available={2}",
  "viewport.layout.failed.display_text": "ERROR",
  "viewport.layout.failed.category": "error",

  "viewport.layout.invalid.text": "üö® Invalid layout areas created, using emergency layout",
  "viewport.layout.invalid.display_text": "ERROR",
  "viewport.layout.invalid.category": "error",

  "viewport.layout.mismatch.text": "Layout sizes don't match: Terminal={0}, Used={1} (Output={2}, Input={3}, Margin={4})",
  "viewport.layout.mismatch.display_text": "WARN",
  "viewport.layout.mismatch.category": "warning",

  "viewport.layout.too_small.text": "Viewport layout too small: {0}x{1}",
  "viewport.layout.too_small.display_text": "ERROR",
  "viewport.layout.too_small.category": "error"
}

// ## END ##

// ## FILE: src/i18n/langs/en/manager.json
// ## BEGIN ##
{
  "manager.cached_entries.text": "Cached Entries",
  "manager.cached_entries.display_text": "INFO",
  "manager.cached_entries.category": "info",

  "manager.change_theme.text": "Change theme",
  "manager.change_theme.display_text": "INFO",
  "manager.change_theme.category": "info",

  "manager.comprehensive_report_header.text": "üìä COMPREHENSIVE PERFORMANCE REPORT",
  "manager.comprehensive_report_header.display_text": "INFO",
  "manager.comprehensive_report_header.category": "info",

  "manager.current_language.text": "Current Language",
  "manager.current_language.display_text": "INFO",
  "manager.current_language.category": "info",

  "manager.disabled.text": "DISABLED",
  "manager.disabled.display_text": "INFO",
  "manager.disabled.category": "info",

  "manager.enable_debug_logging.text": "Enable debug logging",
  "manager.enable_debug_logging.display_text": "INFO",
  "manager.enable_debug_logging.category": "info",

  "manager.history_buffer.text": "History Buffer",
  "manager.history_buffer.display_text": "INFO",
  "manager.history_buffer.category": "info",

  "manager.i18n_cache.text": "i18n Cache",
  "manager.i18n_cache.display_text": "INFO",
  "manager.i18n_cache.category": "info",

  "manager.i18n_performance.text": "i18n Performance",
  "manager.i18n_performance.display_text": "INFO",
  "manager.i18n_performance.category": "info",

  "manager.memory_usage.text": "Memory Usage",
  "manager.memory_usage.display_text": "INFO",
  "manager.memory_usage.category": "info",

  "manager.message_buffer.text": "Message Buffer",
  "manager.message_buffer.display_text": "INFO",
  "manager.message_buffer.category": "info",

  "manager.no_config_found.text": "No configuration found",
  "manager.no_config_found.display_text": "INFO",
  "manager.no_config_found.category": "info",

  "manager.poll_rate.text": "Poll Rate",
  "manager.poll_rate.display_text": "INFO",
  "manager.poll_rate.category": "info",

  "manager.recommendation.all_good.text": "‚úÖ All settings optimally configured",
  "manager.recommendation.all_good.display_text": "INFO",
  "manager.recommendation.all_good.category": "info",

  "manager.recommendation.poll_rate_too_fast.text": "‚ö° poll_rate < 16ms: Very high CPU load - recommended: 16-33ms",
  "manager.recommendation.poll_rate_too_fast.display_text": "WARN",
  "manager.recommendation.poll_rate_too_fast.category": "warning",

  "manager.recommendation.too_many_messages.text": "üíæ Too many messages in buffer - recommended: max 500",
  "manager.recommendation.too_many_messages.display_text": "WARN",
  "manager.recommendation.too_many_messages.category": "warning",

  "manager.recommendation.typewriter_too_fast.text": "‚å®Ô∏è typewriter_delay < 10ms: Very fast - recommended: 30-100ms",
  "manager.recommendation.typewriter_too_fast.display_text": "WARN",
  "manager.recommendation.typewriter_too_fast.category": "warning",

  "manager.recommendations.text": "Recommendations",
  "manager.recommendations.display_text": "INFO",
  "manager.recommendations.category": "info",

  "manager.related_commands.text": "Related Commands",
  "manager.related_commands.display_text": "INFO",
  "manager.related_commands.category": "info",

  "manager.show_i18n_report.text": "Show i18n report",
  "manager.show_i18n_report.display_text": "INFO",
  "manager.show_i18n_report.category": "info",

  "manager.system_performance.text": "System Performance",
  "manager.system_performance.display_text": "INFO",
  "manager.system_performance.category": "info",

  "manager.total_estimated.text": "Total Estimated",
  "manager.total_estimated.display_text": "INFO",
  "manager.total_estimated.category": "info",

  "manager.total_keys.text": "Total Keys",
  "manager.total_keys.display_text": "INFO",
  "manager.total_keys.category": "info",

  "manager.typewriter_speed.text": "Typewriter Speed",
  "manager.typewriter_speed.display_text": "INFO",
  "manager.typewriter_speed.category": "info",

  "utils.duration.hours_minutes.text": "{0}h {1}min",
  "utils.duration.hours_minutes.display_text": "INFO",
  "utils.duration.hours_minutes.category": "info",

  "utils.duration.milliseconds.text": "{0}ms",
  "utils.duration.milliseconds.display_text": "INFO",
  "utils.duration.milliseconds.category": "info",

  "utils.duration.minutes_seconds.text": "{0}min {1}s",
  "utils.duration.minutes_seconds.display_text": "INFO",
  "utils.duration.minutes_seconds.category": "info",

  "utils.duration.seconds.text": "{0}s",
  "utils.duration.seconds.display_text": "INFO",
  "utils.duration.seconds.category": "info",

  "utils.size.bytes.text": "bytes",
  "utils.size.bytes.display_text": "INFO",
  "utils.size.bytes.category": "info",

  "utils.size.GB.text": "GB",
  "utils.size.GB.display_text": "INFO",
  "utils.size.GB.category": "info",

  "utils.size.KB.text": "KB",
  "utils.size.KB.display_text": "INFO",
  "utils.size.KB.category": "info",

  "utils.size.MB.text": "MB",
  "utils.size.MB.display_text": "INFO",
  "utils.size.MB.category": "info",

  "utils.size.TB.text": "TB",
  "utils.size.TB.display_text": "INFO",
  "utils.size.TB.category": "info"
}

// ## END ##

// ## FILE: src/i18n/langs/en/system.json
// ## BEGIN ##
{
  "system.config.dir_created.text": "Configuration directory created: {0}",
  "system.config.dir_created.display_text": "DEBUG",
  "system.config.dir_created.category": "debug",

  "system.config.dir_error.text": "Could not determine program directory",
  "system.config.dir_error.display_text": "ERROR",
  "system.config.dir_error.category": "error",

  "system.config.file_created.text": "Configuration file created: {0}",
  "system.config.file_created.display_text": "INFO",
  "system.config.file_created.category": "info",

  "system.config.language_set_failed.text": "Failed to set language: {0}",
  "system.config.language_set_failed.display_text": "WARN",
  "system.config.language_set_failed.category": "warning",

  "system.config.load_error.text": "Error loading new configuration: {0}",
  "system.config.load_error.display_text": "ERROR",
  "system.config.load_error.category": "error",

  "system.config.new_default.text": "‚úÖ New default configuration created: {0}",
  "system.config.new_default.display_text": "INFO",
  "system.config.new_default.category": "info",

  "system.config.no_existing.text": "No existing configuration found, creating default",
  "system.config.no_existing.display_text": "INFO",
  "system.config.no_existing.category": "info",

  "system.config.setup_failed.text": "Default configuration setup failed: {0}",
  "system.config.setup_failed.display_text": "ERROR",
  "system.config.setup_failed.category": "error",

  "system.error.io.text": "IO error: {0}",
  "system.error.io.display_text": "ERROR",
  "system.error.io.category": "error",

  "system.error.io_error.text": "IO error: {0}",
  "system.error.io_error.display_text": "ERROR",
  "system.error.io_error.category": "error",

  "system.error.terminal.text": "Terminal error: {0}",
  "system.error.terminal.display_text": "ERROR",
  "system.error.terminal.category": "error",

  "system.error.terminal_error.text": "Terminal error: {0}",
  "system.error.terminal_error.display_text": "ERROR",
  "system.error.terminal_error.category": "error",

  "system.error.translation_error.text": "Translation error: {0}",
  "system.error.translation_error.display_text": "ERROR",
  "system.error.translation_error.category": "error",

  "system.error.validation.text": "Validation error: {0}",
  "system.error.validation.display_text": "ERROR",
  "system.error.validation.category": "error",

  "system.error.validation_error.text": "Validation error: {0}",
  "system.error.validation_error.display_text": "ERROR",
  "system.error.validation_error.category": "error",

  "system.input.cancel.short.text": "n",
  "system.input.cancel.short.display_text": "INFO",
  "system.input.cancel.short.category": "info",

  "system.input.cancelled.text": "Operation cancelled",
  "system.input.cancelled.display_text": "INFO",
  "system.input.cancelled.category": "info",

  "system.input.clipboard.cleared.text": "Input cleared",
  "system.input.clipboard.cleared.display_text": "INPUT",
  "system.input.clipboard.cleared.category": "info",

  "system.input.clipboard.copied.text": "üìã Copied: \"{0}\"",
  "system.input.clipboard.copied.display_text": "CLIPBOARD",
  "system.input.clipboard.copied.category": "info",

  "system.input.clipboard.copy_failed.text": "‚ö™ Copy failed",
  "system.input.clipboard.copy_failed.display_text": "CLIPBOARD",
  "system.input.clipboard.copy_failed.category": "error",

  "system.input.clipboard.cut.text": "üìã Cut: \"{0}\"",
  "system.input.clipboard.cut.display_text": "CLIPBOARD",
  "system.input.clipboard.cut.category": "info",

  "system.input.clipboard.empty.text": "‚ö™ Clipboard empty",
  "system.input.clipboard.empty.display_text": "CLIPBOARD",
  "system.input.clipboard.empty.category": "warning",

  "system.input.clipboard.nothing_to_copy.text": "‚ö™ Nothing to copy",
  "system.input.clipboard.nothing_to_copy.display_text": "CLIPBOARD",
  "system.input.clipboard.nothing_to_copy.category": "warning",

  "system.input.clipboard.nothing_to_paste.text": "‚ö™ Nothing to paste",
  "system.input.clipboard.nothing_to_paste.display_text": "CLIPBOARD",
  "system.input.clipboard.nothing_to_paste.category": "warning",

  "system.input.clipboard.pasted.text": "üìã Pasted {0} chars",
  "system.input.clipboard.pasted.display_text": "CLIPBOARD",
  "system.input.clipboard.pasted.category": "info",

  "system.input.confirm.short.text": "y",
  "system.input.confirm.short.display_text": "INFO",
  "system.input.confirm.short.category": "info",

  "system.input.confirm_exit.text": "Do you really want to exit the program? (y/n)",
  "system.input.confirm_exit.display_text": "CONFIRM",
  "system.input.confirm_exit.category": "warning",

  "system.input.empty.text": "Input cannot be empty",
  "system.input.empty.display_text": "WARN",
  "system.input.empty.category": "warning",

  "system.input.history_cleared.text": "History has been cleared",
  "system.input.history_cleared.display_text": "INFO",
  "system.input.history_cleared.category": "info",

  "system.input.too_long.text": "Input too long (maximum: {0} characters)",
  "system.input.too_long.display_text": "WARN",
  "system.input.too_long.category": "warning",

  "system.startup.i18n_initialized.text": "i18n system initialized for language: {0}",
  "system.startup.i18n_initialized.display_text": "READY",
  "system.startup.i18n_initialized.category": "info",

  "system.startup.logger_init_failed.text": "Logger initialization failed: {0}",
  "system.startup.logger_init_failed.display_text": "ERROR",
  "system.startup.logger_init_failed.category": "error",

  "system.startup.version.text": "Welcome to Rush Sync Version {0}",
  "system.startup.version.display_text": "READY",
  "system.startup.version.category": "startup",

  "terminal.cleanup.done.text": "‚úÖ Terminal reset correctly",
  "terminal.cleanup.done.display_text": "READY",
  "terminal.cleanup.done.category": "info",

  "terminal.manager.emergency_cleanup.text": "üö® Emergency terminal cleanup in destructor",
  "terminal.manager.emergency_cleanup.display_text": "TERMINAL",
  "terminal.manager.emergency_cleanup.category": "warning",

  "terminal.manager.raw_mode_lost.text": "‚ö† Raw mode was lost, re-enabling...",
  "terminal.manager.raw_mode_lost.display_text": "TERMINAL",
  "terminal.manager.raw_mode_lost.category": "warning",

  "terminal.setup.done.text": "‚úÖ Terminal initialized",
  "terminal.setup.done.display_text": "READY",
  "terminal.setup.done.category": "info"
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/dashboard.html
// ## BEGIN ##
<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rush Sync Server - {{SERVER_NAME}}</title>
    <link rel="stylesheet" href="/.rss/style.css" />
    <link rel="icon" href="/.rss/favicon.svg" type="image/svg+xml" />
  </head>
  <body>
    <div class="dashboard">
      <!-- Header mit kompakten Quick Actions -->
      <header class="dashboard-header">
        <div class="server-info">
          <h1>Rush Sync Server</h1>
          <span class="server-name">{{SERVER_NAME}}</span>
          <div class="status-badge">
            <span class="status-dot" data-status="checking"></span>
            <span class="status-text">Checking...</span>
          </div>
          <!-- Hot Reload Status -->
          <div class="hotreload-badge">
            <span class="hotreload-icon">‚àû</span>
            <span id="hotreload-status" class="hotreload-status checking">Connecting...</span>
          </div>
        </div>

        <!-- Kompakte Quick Actions im Header -->
        <div class="header-actions">
          <button class="header-btn primary" data-action="view-http" title="Open HTTP">HTTP</button>
          <button class="header-btn" data-action="view-proxy" title="Open via Proxy HTTPS">
            HTTPS
          </button>
          <button class="header-btn" data-action="test-apis" title="Test APIs">TEST</button>
          <button class="header-btn" data-action="refresh-stats" title="Refresh Stats">
            REFRESH
          </button>
        </div>

        <div class="quick-stats">
          <div class="stat">
            <span class="stat-label">Port</span>
            <span class="stat-value">{{PORT}}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Proxy HTTP</span>
            <span class="stat-value">{{PROXY_PORT}}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Proxy HTTPS</span>
            <span class="stat-value">{{PROXY_HTTPS_PORT}}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Uptime</span>
            <span class="stat-value" id="uptime">Starting...</span>
          </div>
          <div class="stat">
            <span class="stat-label">Requests</span>
            <span class="stat-value" id="request-count">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Errors</span>
            <span class="stat-value" id="error-count">0</span>
          </div>
        </div>
      </header>

      <!-- Main Content -->
      <main class="dashboard-content">
        <!-- Tab Navigation -->
        <nav class="tab-nav">
          <button class="tab-btn active" data-tab="overview">Overview</button>
          <button class="tab-btn" data-tab="endpoints">API</button>
          <button class="tab-btn" data-tab="logs">Live Logs</button>
          <button class="tab-btn" data-tab="metrics">Metrics</button>
          <button class="tab-btn" data-tab="certificates">TLS</button>
          <button class="tab-btn" data-tab="hotreload">Hot Reload</button>
        </nav>

        <!-- Tab Content -->
        <div class="tab-content">
          <!-- Overview Tab -->
          <div class="tab-panel active" id="tab-overview">
            <div class="overview-grid">
              <!-- Server Config -->
              <div class="card compact">
                <h3>Configuration</h3>
                <div class="config-items">
                  <div class="config-item">
                    <span>Directory</span>
                    <code>www/{{SERVER_NAME}}-[{{PORT}}]/</code>
                  </div>
                  <div class="config-item">
                    <span>Version</span>
                    <span>{{VERSION}}</span>
                  </div>
                  <div class="config-item">
                    <span>HTTP URL</span>
                    <a href="http://127.0.0.1:{{PORT}}" target="_blank">127.0.0.1:{{PORT}}</a>
                  </div>
                  <div class="config-item">
                    <span>Proxy HTTP URL</span>
                    <a href="http://{{SERVER_NAME}}.localhost:{{PROXY_PORT}}" target="_blank"
                      >{{SERVER_NAME}}.localhost:{{PROXY_PORT}}</a
                    >
                  </div>
                  <div class="config-item">
                    <span>Proxy HTTPS URL</span>
                    <a href="https://{{SERVER_NAME}}.localhost:{{PROXY_HTTPS_PORT}}" target="_blank"
                      >{{SERVER_NAME}}.localhost:{{PROXY_HTTPS_PORT}}</a
                    >
                  </div>
                  <div class="config-item">
                    <span>WebSocket</span>
                    <code>ws://127.0.0.1:{{PORT}}/ws/hot-reload</code>
                  </div>
                  <div class="config-item">
                    <span>Created</span>
                    <span id="creation-time">{{CREATION_TIME}}</span>
                  </div>
                </div>
              </div>

              <!-- TLS Certificate Info -->
              <div class="card compact">
                <h3>TLS Certificate</h3>
                <div class="config-items">
                  <div class="config-item">
                    <span>Certificate</span>
                    <code>{{SERVER_NAME}}-{{PORT}}.cert</code>
                  </div>
                  <div class="config-item">
                    <span>Private Key</span>
                    <code>{{SERVER_NAME}}-{{PORT}}.key</code>
                  </div>
                  <div class="config-item">
                    <span>Valid Days</span>
                    <span id="cert-valid-days">365</span>
                  </div>
                  <div class="config-item">
                    <span>Common Name</span>
                    <code>{{SERVER_NAME}}.localhost</code>
                  </div>
                  <div class="config-item">
                    <span>Alt Names</span>
                    <span>localhost, 127.0.0.1</span>
                  </div>
                </div>
              </div>

              <!-- Features -->
              <div class="card compact">
                <h3>Features</h3>
                <div class="feature-list">
                  <div class="feature-item">
                    <span class="feature-icon">üîÑ</span>
                    <span>Hot Reload</span>
                  </div>
                  <div class="feature-item">
                    <span class="feature-icon">üîí</span>
                    <span>HTTPS/TLS</span>
                  </div>
                  <div class="feature-item">
                    <span class="feature-icon">üåê</span>
                    <span>Reverse Proxy</span>
                  </div>
                  <div class="feature-item">
                    <span class="feature-icon">üìä</span>
                    <span>Live Metrics</span>
                  </div>
                  <div class="feature-item">
                    <span class="feature-icon">üõ°Ô∏è</span>
                    <span>Security Monitoring</span>
                  </div>
                  <div class="feature-item">
                    <span class="feature-icon">‚ö°</span>
                    <span>High Performance</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Endpoints Tab -->
          <div class="tab-panel" id="tab-endpoints">
            <div class="endpoint-groups">
              <div class="endpoint-group">
                <h4>Static Files</h4>
                <div class="endpoint-list compact">
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/</code>
                    <span class="desc">Main app</span>
                    <button class="test-btn" data-url="/">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/.rss/style.css</code>
                    <span class="desc">Stylesheet</span>
                    <button class="test-btn" data-url="/.rss/style.css">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/rss.js</code>
                    <span class="desc">JavaScript</span>
                    <button class="test-btn" data-url="/rss.js">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/robots.txt</code>
                    <span class="desc">SEO config</span>
                    <button class="test-btn" data-url="/robots.txt">Test</button>
                  </div>
                </div>
              </div>

              <div class="endpoint-group">
                <h4>Server API & WebSocket</h4>
                <div class="endpoint-list compact">
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/status</code>
                    <span class="desc">Server status</span>
                    <button class="test-btn" data-url="/api/status">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/health</code>
                    <span class="desc">Health check</span>
                    <button class="test-btn" data-url="/api/health">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/metrics</code>
                    <span class="desc">Performance</span>
                    <button class="test-btn" data-url="/api/metrics">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/logs</code>
                    <span class="desc">Log viewer</span>
                    <button class="test-btn" data-url="/api/logs">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method ws">WS</span>
                    <code>/ws/hot-reload</code>
                    <span class="desc">Hot Reload</span>
                    <button class="test-btn disabled">WebSocket</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Live Logs Tab -->
          <div class="tab-panel" id="tab-logs">
            <div class="terminal-container">
              <div class="terminal-header">
                <div class="terminal-controls">
                  <span class="control-dot red"></span>
                  <span class="control-dot yellow"></span>
                  <span class="control-dot green"></span>
                </div>
                <div class="terminal-title">{{SERVER_NAME}}-[{{PORT}}].log</div>
                <div class="terminal-actions">
                  <button class="terminal-btn">Clear</button>
                  <button class="terminal-btn">
                    <span id="autoscroll-text">Auto-scroll ON</span>
                  </button>
                  <button class="terminal-btn">Download Log</button>
                </div>
              </div>
              <div class="terminal-body" id="log-output">
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message">Server directory: www/{{SERVER_NAME}}-[{{PORT}}]/</span>
                </div>
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message">TLS certificate: {{SERVER_NAME}}-{{PORT}}.cert</span>
                </div>
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message">Hot Reload WebSocket enabled on /ws/hot-reload</span>
                </div>
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message">HTTP listening on 127.0.0.1:{{PORT}}</span>
                </div>
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message"
                    >Proxy HTTP on {{SERVER_NAME}}.localhost:{{PROXY_PORT}}</span
                  >
                </div>
                <div class="log-line system">
                  <span class="log-time">{{CREATION_TIME}}</span>
                  <span class="log-level INFO">INFO</span>
                  <span class="log-message"
                    >Proxy HTTPS on {{SERVER_NAME}}.localhost:{{PROXY_HTTPS_PORT}}</span
                  >
                </div>
              </div>
            </div>
          </div>

          <!-- Metrics Tab -->
          <div class="tab-panel" id="tab-metrics">
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-header">
                  <h4>Response Times</h4>
                  <span class="metric-trend up" id="response-trend">‚Üí</span>
                </div>
                <div class="metric-value" id="avg-response">0ms</div>
                <div class="metric-detail">avg</div>
              </div>

              <div class="metric-card">
                <div class="metric-header">
                  <h4>Traffic</h4>
                  <span class="metric-trend neutral" id="traffic-trend">‚Üí</span>
                </div>
                <div class="metric-value" id="total-requests">0</div>
                <div class="metric-detail">requests</div>
              </div>

              <div class="metric-card">
                <div class="metric-header">
                  <h4>Data Sent</h4>
                  <span class="metric-trend up" id="data-trend">‚Üí</span>
                </div>
                <div class="metric-value" id="bytes-sent">0 KB</div>
                <div class="metric-detail">total</div>
              </div>

              <div class="metric-card">
                <div class="metric-header">
                  <h4>Unique IPs</h4>
                  <span class="metric-trend neutral" id="ip-trend">‚Üí</span>
                </div>
                <div class="metric-value" id="unique-ips">0</div>
                <div class="metric-detail">visitors</div>
              </div>
            </div>

            <div class="metrics-details">
              <div class="card">
                <h4>Recent Activity</h4>
                <div id="recent-activity">
                  <div class="activity-item">
                    <span class="activity-time">Just now</span>
                    <span class="activity-desc">Server started with TLS support</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- TLS Certificate Tab -->
          <div class="tab-panel" id="tab-certificates">
            <div class="overview-grid">
              <!-- Certificate Details -->
              <div class="card">
                <h3>Server Certificate</h3>
                <div class="config-items">
                  <div class="config-item">
                    <span>Certificate File</span>
                    <code>.rss/certs/{{SERVER_NAME}}-{{PORT}}.cert</code>
                  </div>
                  <div class="config-item">
                    <span>Private Key</span>
                    <code>.rss/certs/{{SERVER_NAME}}-{{PORT}}.key</code>
                  </div>
                  <div class="config-item">
                    <span>Common Name</span>
                    <code>{{SERVER_NAME}}.localhost</code>
                  </div>
                  <div class="config-item">
                    <span>Subject Alt Names</span>
                    <span>localhost, 127.0.0.1, {{SERVER_NAME}}.localhost</span>
                  </div>
                  <div class="config-item">
                    <span>Valid for</span>
                    <span id="cert-validity">365 days</span>
                  </div>
                  <div class="config-item">
                    <span>Auto-generated</span>
                    <span class="status-value success">Yes</span>
                  </div>
                </div>
              </div>

              <!-- Proxy Certificate -->
              <div class="card">
                <h3>Proxy Certificate</h3>
                <div class="config-items">
                  <div class="config-item">
                    <span>Certificate File</span>
                    <code>.rss/certs/proxy-{{PROXY_HTTPS_PORT}}.cert</code>
                  </div>
                  <div class="config-item">
                    <span>Private Key</span>
                    <code>.rss/certs/proxy-{{PROXY_HTTPS_PORT}}.key</code>
                  </div>
                  <div class="config-item">
                    <span>Common Name</span>
                    <code>*.localhost</code>
                  </div>
                  <div class="config-item">
                    <span>Subject Alt Names</span>
                    <span>localhost, 127.0.0.1, *.localhost, proxy.localhost</span>
                  </div>
                  <div class="config-item">
                    <span>Wildcard Support</span>
                    <span class="status-value success">Yes</span>
                  </div>
                  <div class="config-item">
                    <span>Auto-generated</span>
                    <span class="status-value success">Yes</span>
                  </div>
                </div>
              </div>

              <!-- URL Testing - KORREKTE PORTS -->
              <div class="card full-width">
                <h3>URL Testing</h3>
                <div class="endpoint-list compact">
                  <div class="endpoint">
                    <span class="method get">HTTP</span>
                    <code>http://127.0.0.1:{{PORT}}</code>
                    <span class="desc">Direct HTTP access</span>
                    <button class="test-btn" data-url="http://127.0.0.1:{{PORT}}">Test</button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">PROXY-HTTP</span>
                    <code>http://{{SERVER_NAME}}.localhost:{{PROXY_PORT}}</code>
                    <span class="desc">Via HTTP proxy</span>
                    <button
                      class="test-btn"
                      data-url="http://{{SERVER_NAME}}.localhost:{{PROXY_PORT}}"
                    >
                      Test
                    </button>
                  </div>
                  <div class="endpoint">
                    <span class="method get">PROXY-HTTPS</span>
                    <code>https://{{SERVER_NAME}}.localhost:{{PROXY_HTTPS_PORT}}</code>
                    <span class="desc">Via HTTPS proxy</span>
                    <button
                      class="test-btn"
                      data-url="https://{{SERVER_NAME}}.localhost:{{PROXY_HTTPS_PORT}}"
                    >
                      Test
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Hot Reload Tab -->
          <div class="tab-panel" id="tab-hotreload">
            <div class="hotreload-grid">
              <!-- WebSocket Status -->
              <div class="card">
                <h3>WebSocket Connection</h3>
                <div class="websocket-status">
                  <div class="status-item">
                    <span class="status-label">Connection</span>
                    <span id="ws-connection-status" class="status-value checking"
                      >Connecting...</span
                    >
                  </div>
                  <div class="status-item">
                    <span class="status-label">Endpoint</span>
                    <code class="status-value">ws://127.0.0.1:{{PORT}}/ws/hot-reload</code>
                  </div>
                  <div class="status-item">
                    <span class="status-label">Reconnect Attempts</span>
                    <span id="reconnect-attempts" class="status-value">0</span>
                  </div>
                </div>
              </div>

              <!-- File Watching -->
              <div class="card">
                <h3>File Watcher</h3>
                <div class="watcher-info">
                  <div class="info-item">
                    <span class="info-label">Watching</span>
                    <code class="info-value">www/{{SERVER_NAME}}-[{{PORT}}]/</code>
                  </div>
                  <div class="info-item">
                    <span class="info-label">Supported Files</span>
                    <span class="info-value">html, css, js, json, svg, png, jpg, ico</span>
                  </div>
                  <div class="info-item">
                    <span class="info-label">Auto Reload</span>
                    <span class="info-value success">Enabled</span>
                  </div>
                </div>
              </div>

              <!-- Recent Changes -->
              <div class="card full-width">
                <h3>Recent File Changes</h3>
                <div id="file-changes-log" class="changes-log">
                  <div class="change-item">
                    <span class="change-time">Just now</span>
                    <span class="change-type created">CREATED</span>
                    <span class="change-file">index.html</span>
                    <span class="change-desc">Initial server setup</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Test Hot Reload -->
            <div class="card">
              <h3>Test Hot Reload</h3>
              <p class="test-instructions">
                To test Hot Reload, edit any file in the
                <code>www/{{SERVER_NAME}}-[{{PORT}}]/</code> directory. The page will automatically
                reload when you save changes.
              </p>
              <div class="test-actions">
                <button class="btn btn-secondary" data-action="simulate-file-change">
                  Simulate File Change
                </button>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </body>
</html>

// ## END ##

// ## FILE: src/server/handlers/templates/_receiver.html
// ## BEGIN ##
<!DOCTYPE html>
<html>
  <head>
    <title>Message Receiver (rss-002)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        background: #e8f5e8;
      }
      .container {
        max-width: 500px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
      }
      .message {
        background: #d1ecf1;
        padding: 15px;
        margin: 10px 0;
        border-radius: 4px;
        border-left: 4px solid #0c5460;
      }
      .message-meta {
        font-size: 12px;
        color: #666;
        margin-bottom: 5px;
      }
      .message-content {
        font-size: 16px;
        font-weight: bold;
      }
      button {
        background: #28a745;
        color: white;
        border: none;
        padding: 10px 15px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background: #218838;
      }
      .stats {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Message Receiver (rss-002)</h1>
      <p>Receiving messages from rss-001</p>

      <div class="stats"><strong>Messages received:</strong> <span id="messageCount">0</span></div>

      <button onclick="clearMessages()">Clear All</button>
      <button onclick="refreshMessages()">Refresh</button>

      <div id="messages">
        <h3>Messages:</h3>
      </div>
    </div>

    <script>
      let messageCount = 0;
      let messages = [];

      function addMessage(data) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';

        messageDiv.innerHTML = `
                <div class="message-meta">
                    From: ${data.from || 'Unknown'} |
                    Time: ${new Date(data.timestamp || Date.now()).toLocaleTimeString()}
                </div>
                <div class="message-content">${data.message || 'No message'}</div>
            `;

        messagesDiv.appendChild(messageDiv);
        messages.push(data);
        messageCount++;
        document.getElementById('messageCount').textContent = messageCount;

        messageDiv.scrollIntoView({ behavior: 'smooth' });
      }

      function clearMessages() {
        document.getElementById('messages').innerHTML = '<h3>Messages:</h3>';
        messages = [];
        messageCount = 0;
        document.getElementById('messageCount').textContent = messageCount;
      }

      async function refreshMessages() {
        try {
          const response = await fetch('/api/messages');
          if (response.ok) {
            const data = await response.json();

            // Nachrichten anzeigen
            if (data.messages && data.messages.length > 0) {
              // Neue Nachrichten hinzuf√ºgen
              data.messages.forEach((message) => {
                // Pr√ºfen ob bereits angezeigt
                if (!messages.find((m) => m.id === message.id)) {
                  addMessage(message);
                }
              });
            }

            console.log('Messages loaded:', data.messages?.length || 0);
          }
        } catch (error) {
          console.log('Refresh failed:', error);
        }
      }

      // Auto-refresh every 3 seconds to check for new messages
      setInterval(refreshMessages, 3000);

      window.onload = function () {
        addMessage({
          message: 'rss-002 ready to receive messages',
          from: 'system',
          timestamp: new Date().toISOString(),
        });
      };
    </script>
  </body>
</html>

// ## END ##

// ## FILE: src/server/handlers/templates/_sender.html
// ## BEGIN ##
<!DOCTYPE html>
<html>
  <head>
    <title>Message Sender (rss-001)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        background: #f0f0f0;
      }
      .container {
        max-width: 500px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
      }
      input,
      button {
        padding: 10px;
        margin: 5px;
      }
      button {
        background: #007cba;
        color: white;
        border: none;
        cursor: pointer;
      }
      button:hover {
        background: #005a84;
      }
      .status {
        margin-top: 15px;
        padding: 10px;
        border-radius: 4px;
      }
      .success {
        background: #d4edda;
        color: #155724;
      }
      .error {
        background: #f8d7da;
        color: #721c24;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Message Sender (rss-001)</h1>
      <p>Send messages to rss-002</p>

      <input
        type="text"
        id="messageInput"
        placeholder="Enter your message..."
        style="width: 300px"
      />
      <button onclick="sendMessage()">Send Message</button>

      <div id="status"></div>
    </div>

    <script>
      function showStatus(message, isSuccess) {
        const statusDiv = document.getElementById('status');
        statusDiv.className = `status ${isSuccess ? 'success' : 'error'}`;
        statusDiv.textContent = message;
      }

      async function sendMessage() {
        const message = document.getElementById('messageInput').value;
        if (!message.trim()) {
          showStatus('Please enter a message', false);
          return;
        }

        try {
          const response = await fetch('http://127.0.0.1:8081/api/message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message: message,
              from: 'rss-001',
              timestamp: new Date().toISOString(),
            }),
          });

          if (response.ok) {
            const result = await response.json();
            showStatus(`Message sent successfully!`, true);
            document.getElementById('messageInput').value = '';
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          showStatus(`Failed to send: ${error.message}`, false);
        }
      }

      // Send on Enter key
      document.getElementById('messageInput').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          sendMessage();
        }
      });
    </script>
  </body>
</html>

// ## END ##

// ## FILE: src/server/handlers/templates/rss/style.css
// ## BEGIN ##
/* Rush Sync Dashboard - Compact Developer Interface mit Hot Reload */
/* Ultra-compact design with terminal aesthetics and real-time updates */

/* ===== VARIABLES ===== */
:root {
  /* Colors - Developer theme */
  --bg-primary: #1a1d23;
  --bg-secondary: #252830;
  --bg-tertiary: #2d3139;
  --bg-card: #1e2127;

  --text-primary: #ffffff;
  --text-secondary: #a0a6b1;
  --text-muted: #7a8191;

  --accent-primary: #00d4ff;
  --accent-success: #00ff88;
  --accent-warning: #ffb000;
  --accent-error: #ff4757;
  --accent-info: #5865f2;

  --border: #3a3f47;
  --border-light: #4a4f57;

  /* Terminal colors */
  --terminal-bg: #0d1117;
  --terminal-text: #58a6ff;
  --terminal-green: #7ce38b;
  --terminal-yellow: #f0883e;
  --terminal-red: #ff6b6b;
  --terminal-cyan: #39c5cf;

  /* Typography */
  --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --font-mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Monaco', monospace;

  /* Spacing - Compact scale */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 0.75rem;
  --space-lg: 1rem;
  --space-xl: 1.5rem;

  /* Layout */
  --border-radius: 6px;
  --shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  --transition: all 0.2s ease;
}

/* ===== BASE ===== */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-system);
  font-size: 13px;
  line-height: 1.4;
  color: var(--text-primary);
  background: var(--bg-primary);
  overflow-x: hidden;
}

/* ===== HEADER ===== */
.dashboard-header {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  padding: var(--space-md) var(--space-lg);
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 100;
}

.server-info {
  display: flex;
  align-items: center;
  gap: var(--space-md);
}

.server-info h1 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  font-style: italic;
  position: relative;
  margin-bottom: 0;
}

.server-name {
  background: var(--accent-primary);
  color: var(--bg-primary);
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--border-radius);
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
}

.status-badge,
.hotreload-badge {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
  background: var(--bg-tertiary);
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--border-radius);
  border: 1px solid var(--border);
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  transition: var(--transition);
}

.status-dot[data-status='running'] {
  background: var(--accent-success);
  box-shadow: 0 0 4px var(--accent-success);
}

.status-dot[data-status='checking'] {
  background: var(--accent-warning);
  animation: pulse 1.5s infinite;
}

.status-dot[data-status='error'] {
  background: var(--accent-error);
  box-shadow: 0 0 4px var(--accent-error);
}

.status-text {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  text-transform: uppercase;
}

/* Kompakte Header Actions */
.header-actions {
  display: flex;
  gap: 8px;
  margin: 0 20px;
}
.header-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  transition: var(--transition);
}
.header-btn.primary {
  background: var(--accent-primary);
  color: var(--bg-primary);
}
.header-btn:hover {
  background: var(--border-light);
}
.header-btn.primary:hover {
  background: rgba(0, 212, 255, 0.8);
}

.header-btn.is-active {
  background: var(--accent-primary);
  color: var(--bg-primary);
  border-color: var(--accent-primary);
}
.header-btn.is-active:hover {
  background: rgba(0, 212, 255, 0.8);
}

/* NEW: Hot Reload Badge */
.hotreload-badge {
  background: var(--bg-tertiary);
  border-color: var(--accent-success);
}

.hotreload-icon {
  color: var(--accent-success);
  font-size: 10px;
  animation: rotate 2s linear infinite;
  margin: 0 7px;
}

.hotreload-status {
  position: relative;
  top: 1px;
  padding-right: 7px;
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
}

.hotreload-status.connected {
  color: var(--accent-success);
}

.hotreload-status.disconnected {
  color: var(--accent-warning);
}

.hotreload-status.error {
  color: var(--accent-error);
}

.hotreload-status.checking {
  color: var(--text-secondary);
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* ===== QUICK STATS ===== */
.quick-stats {
  display: flex;
  gap: var(--space-lg);
}

.stat {
  text-align: center;
}

.stat-label {
  display: block;
  font-size: 10px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.stat-value {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: var(--accent-primary);
  font-family: var(--font-mono);
}

/* ===== MAIN CONTENT ===== */
.dashboard {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.dashboard-content {
  flex: 1;
  padding: var(--space-lg);
  background: var(--bg-primary);
}

/* ===== TABS ===== */
.tab-nav {
  display: flex;
  background: var(--bg-secondary);
  border-radius: var(--border-radius);
  padding: var(--space-xs);
  margin-bottom: var(--space-lg);
  border: 1px solid var(--border);
}

.tab-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  padding: var(--space-sm) var(--space-md);
  border-radius: calc(var(--border-radius) - 2px);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-right: 10px;
}

.tab-btn:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.tab-btn.active {
  background: var(--accent-primary);
  color: var(--bg-primary);
}

/* ===== TAB CONTENT ===== */
.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
}

/* ===== OVERVIEW ===== */
.overview-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--space-lg);
}

.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--border-radius);
  padding: var(--space-lg);
}

.card.compact {
  padding: var(--space-md);
}

.card h3 {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Config Items */
.config-items {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.config-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-xs) 0;
  border-bottom: 1px solid var(--border);
  color: var(--accent-primary);
  font-size: 11px;
}

.config-item:last-child {
  border-bottom: none;
}

.config-item span:first-child {
  color: var(--text-muted);
  text-transform: uppercase;
}

.config-item code {
  position: relative;
  top: -3.3px;
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: var(--space-xs) var(--space-sm);
  border-radius: 3px;
  word-break: break-all;
}

.config-item a {
  color: var(--accent-primary);
  text-decoration: none;
}

/* Feature List */
.feature-list {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-sm);
}

.feature-item {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius);
}

.feature-icon {
  font-size: 14px;
}

.feature-item span:last-child {
  color: var(--text-secondary);
}

/* Action Buttons */
.action-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius);
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-transform: uppercase;
}

.btn-primary {
  background: var(--accent-primary);
  color: var(--bg-primary);
  border-color: var(--accent-primary);
}

.btn:hover {
  background: var(--border-light);
}

.btn-primary:hover {
  background: rgba(0, 212, 255, 0.8);
}

/* ===== ENDPOINTS ===== */
.endpoint-groups {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-lg);
}

.endpoint-group h4 {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.endpoint-list.compact {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--border-radius);
  overflow: hidden;
}

.endpoint {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm);
  border-bottom: 1px solid var(--border);
  transition: var(--transition);
}

.endpoint:last-child {
  border-bottom: none;
}

.endpoint:hover {
  background: var(--bg-tertiary);
}

.method {
  font-family: var(--font-mono);
  font-size: 9px;
  font-weight: 700;
  padding: 2px 4px;
  border-radius: 3px;
  text-transform: uppercase;
  min-width: 30px;
  text-align: center;
}

.method.get {
  background: var(--accent-success);
  color: var(--bg-primary);
}

.method.ws {
  background: var(--accent-info);
  color: var(--text-primary);
}

.endpoint code {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--terminal-cyan);
  min-width: 100px;
}

.endpoint .desc {
  font-size: 10px;
  color: var(--text-muted);
  flex: 1;
}

.test-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 9px;
  cursor: pointer;
  transition: var(--transition);
  text-transform: uppercase;
}

.test-btn:hover {
  background: var(--accent-primary);
  color: var(--bg-primary);
}

.test-btn.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ===== TERMINAL ===== */
.terminal-container {
  background: var(--terminal-bg);
  border: 1px solid var(--border);
  border-radius: var(--border-radius);
  overflow: hidden;
  height: 60vh;
  display: flex;
  flex-direction: column;
}

.terminal-header {
  background: var(--bg-secondary);
  padding: var(--space-sm) var(--space-md);
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}

.terminal-controls {
  display: flex;
  gap: var(--space-sm);
}

.control-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.control-dot.red {
  background: #ff5f57;
}
.control-dot.yellow {
  background: #ffbd2e;
}
.control-dot.green {
  background: #28ca42;
}

.terminal-title {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-secondary);
}

.terminal-actions {
  display: flex;
  gap: var(--space-sm);
}

.terminal-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 9px;
  cursor: pointer;
  font-family: var(--font-mono);
}

.terminal-body {
  flex: 1;
  padding: var(--space-md);
  overflow-y: auto;
  font-family: var(--font-mono);
  font-size: 11px;
  line-height: 1.3;
}

.log-line {
  display: flex;
  gap: var(--space-sm);
  margin-bottom: 2px;
  word-break: break-all;
}

.log-time {
  color: var(--text-muted);
  min-width: 80px;
}

.log-level {
  min-width: 40px;
  font-weight: 600;
}

.log-level.INFO {
  color: var(--terminal-cyan);
}
.log-level.WARN {
  color: var(--terminal-yellow);
}
.log-level.ERROR {
  color: var(--terminal-red);
}
.log-level.SUCCESS {
  color: var(--terminal-green);
}

.log-message {
  color: var(--terminal-text);
  flex: 1;
}

.log-line.system .log-message {
  color: var(--terminal-green);
}
.log-line.request .log-message {
  color: var(--terminal-cyan);
}
.log-line.error .log-message {
  color: var(--terminal-red);
}
.log-line.hotreload .log-message {
  color: var(--accent-warning);
}

/* ===== METRICS ===== */
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--space-lg);
  margin-bottom: var(--space-lg);
}

.metric-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--border-radius);
  padding: var(--space-md);
  text-align: center;
}

.metric-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-sm);
}

.metric-header h4 {
  font-size: 11px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.metric-trend {
  font-size: 12px;
  font-weight: 600;
}

.metric-trend.up {
  color: var(--accent-success);
}
.metric-trend.down {
  color: var(--accent-error);
}
.metric-trend.neutral {
  color: var(--text-muted);
}

.metric-value {
  font-size: 24px;
  font-weight: 600;
  color: var(--accent-primary);
  font-family: var(--font-mono);
}

.metric-detail {
  font-size: 10px;
  color: var(--text-muted);
  text-transform: uppercase;
}

.metrics-details {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--border-radius);
  padding: var(--space-lg);
}

.activity-item {
  display: flex;
  justify-content: space-between;
  padding: var(--space-xs) 0;
  border-bottom: 1px solid var(--border);
  font-size: 11px;
}

.activity-time {
  color: var(--text-muted);
  font-family: var(--font-mono);
}

.activity-desc {
  color: var(--text-secondary);
}

/* ===== NEW: HOT RELOAD TAB ===== */
.hotreload-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-lg);
  margin-bottom: var(--space-lg);
}

.card.full-width {
  grid-column: 1 / -1;
}

.websocket-status,
.watcher-info {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.status-item,
.info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-sm);
  background: var(--bg-tertiary);
  border-radius: var(--border-radius);
}

.status-label,
.info-label {
  font-size: 11px;
  color: var(--text-muted);
  text-transform: uppercase;
}

.status-value,
.info-value {
  font-size: 11px;
  color: var(--text-secondary);
}

.status-value.success,
.info-value.success {
  color: var(--accent-success);
}

.status-value.checking {
  color: var(--accent-warning);
}

.status-value code,
.info-value code {
  font-family: var(--font-mono);
  background: var(--bg-primary);
  padding: var(--space-xs);
  border-radius: 3px;
  font-size: 10px;
  color: var(--terminal-cyan);
}

.changes-log {
  max-height: 200px;
  overflow-y: auto;
}

.change-item {
  display: flex;
  gap: var(--space-sm);
  padding: var(--space-sm);
  border-bottom: 1px solid var(--border);
  font-size: 11px;
}

.change-time {
  color: var(--text-muted);
  font-family: var(--font-mono);
  min-width: 80px;
}

.change-type {
  font-family: var(--font-mono);
  font-weight: 600;
  min-width: 60px;
  text-transform: uppercase;
}

.change-type.created {
  color: var(--accent-success);
}
.change-type.modified {
  color: var(--accent-warning);
}
.change-type.deleted {
  color: var(--accent-error);
}

.change-file {
  color: var(--terminal-cyan);
  font-family: var(--font-mono);
  min-width: 100px;
}

.change-desc {
  color: var(--text-secondary);
  flex: 1;
}

.test-instructions {
  color: var(--text-secondary);
  font-size: 12px;
  margin-bottom: var(--space-md);
  line-height: 1.5;
}

.test-actions {
  display: flex;
  gap: var(--space-sm);
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .dashboard-header {
    flex-direction: column;
    gap: var(--space-md);
  }

  .quick-stats {
    gap: var(--space-md);
  }

  .overview-grid,
  .endpoint-groups,
  .metrics-grid,
  .hotreload-grid {
    grid-template-columns: 1fr;
  }

  .terminal-container {
    height: 50vh;
  }
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-light);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--accent-primary);
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/_reset.css
// ## BEGIN ##
/* Rush Sync Server - MINIMAL CSS Reset */
/* Nur die absolut n√∂tigsten Resets - NICHT aggressiv */

/* ===== FONT DEFINITIONS ===== */
@font-face {
  font-family: 'Kenyan Coffee';
  src: url('/.rss/fonts/Kenyan_Coffee_Rg.otf') format('opentype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Kenyan Coffee';
  src: url('/.rss/fonts/Kenyan_Coffee_Bd.otf') format('opentype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* ===== MINIMAL RESET - NUR NOTWENDIGES ===== */

/* Box-sizing f√ºr alle Elemente */
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Nur kritische margin/padding resets */
body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
figure,
blockquote {
  margin: 0;
}

/* HTML/Body Basis - SANFT */
html {
  font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif;
  font-size: 16px;
  line-height: 1.5;
}

body {
  font-family: inherit;
  color: #333;
  background: #fff;
}

/* ===== KEINE BUTTON RESETS ===== */
/* Buttons behalten ihre Browser-Defaults komplett */

/* Nur Font-Vererbung f√ºr Form-Elemente */
button,
input,
textarea,
select {
  font-family: inherit;
}

/* ===== BILDER ===== */
img {
  max-width: 100%;
  height: auto;
}

/* ===== FOCUS STYLES ===== */
*:focus-visible {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
}

/* ===== UTILITIES ===== */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/rss.js
// ## BEGIN ##
/**
 * Rush Sync Dashboard - Entry Point
 * L√§dt alle Module und startet das Dashboard
 */

import { RushSyncApp } from '/.rss/js/rush-app.js';

// Global config injection from Rust template
window.RUSH_CONFIG = {
  serverName: '{{SERVER_NAME}}',
  serverPort: '{{PORT}}',
  proxyHttpPort: '{{PROXY_PORT}}',
  proxyHttpsPort: '{{PROXY_HTTPS_PORT}}',
};

// Initialize Dashboard
function initDashboard() {
  try {
    new RushSyncApp();
    console.log('[Rush Sync] Dashboard loaded successfully');
  } catch (error) {
    console.error('[Rush Sync] Dashboard failed to load:', error);

    // Fallback error display
    document.body.innerHTML = `
      <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                  background: #ff4757; color: white; padding: 20px; border-radius: 8px;
                  font-family: monospace; text-align: center;">
        <h2>Dashboard Load Error</h2>
        <p>Check console for details</p>
        <p><strong>${error.message}</strong></p>
      </div>`;
  }
}

// Start when ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initDashboard);
} else {
  initDashboard();
}

// Export for debugging
if (typeof module !== 'undefined' && module.exports) {
  module.exports = RushSyncApp;
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/js/rush-ui.js
// ## BEGIN ##
/**
 * Rush Sync UI Manager
 * DOM Manipulation, Tab System, WebSocket Management, Hot Reload, Notifications
 */

export class UIManager {
  constructor(config, state) {
    this.config = config;
    this.state = state;

    // WebSocket state
    this.websocket = null;
    this.websocketConnected = false;
    this.reconnectAttempts = 0;

    // UI state
    this.autoScroll = true;

    // Callbacks to App Controller
    this.onTabSwitch = null;
    this.onFileChange = null;
    this.onAction = null;

    // API Manager reference (set later)
    this.apiManager = null;
  }

  setApiManager(apiManager) {
    this.apiManager = apiManager;
  }

  // ===== TAB SYSTEM =====

  initializeTabs() {
    this.switchTab('overview');
  }

  switchTab(tabName) {
    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.classList.toggle('active', btn.dataset.tab === tabName);
    });

    document.querySelectorAll('.tab-panel').forEach((panel) => {
      panel.classList.toggle('active', panel.id === `tab-${tabName}`);
    });

    this.state.currentTab = tabName;
    this.onTabSwitch?.(tabName);
  }

  // ===== DISPLAY UPDATES =====

  updateStatsDisplay(data) {
    const updates = {
      'request-count': data.total_requests || 0,
      'error-count': data.error_requests || 0,
    };

    Object.entries(updates).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) element.textContent = value;
    });
  }

  updateMetricsTab(data) {
    const updates = {
      'avg-response': `${Math.round(data.avg_response_time_ms || 0)}ms`,
      'total-requests': data.total_requests || 0,
      'bytes-sent': this.formatBytes(data.total_bytes_sent || 0),
      'unique-ips': data.unique_ips || 0,
    };

    Object.entries(updates).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) element.textContent = value;
    });

    this.updateRecentActivity(data);
  }

  updateRecentActivity(data) {
    const container = document.getElementById('recent-activity');
    if (!container) return;

    const activities = [
      { time: 'Just now', desc: `${data.total_requests || 0} total requests processed` },
      { time: '1m ago', desc: `Average response: ${Math.round(data.avg_response_time_ms || 0)}ms` },
      { time: '2m ago', desc: `${data.unique_ips || 0} unique visitors` },
    ];

    container.innerHTML = activities
      .map(
        (activity) => `
      <div class="activity-item">
        <span class="activity-time">${activity.time}</span>
        <span class="activity-desc">${activity.desc}</span>
      </div>
    `,
      )
      .join('');
  }

  // ===== LOG DISPLAY =====

  addLogEntry(level, message, type = 'system') {
    const container = document.getElementById('log-output');
    if (!container) return;

    const timestamp = new Date().toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });

    const logLine = document.createElement('div');
    logLine.className = `log-line ${type}`;
    logLine.innerHTML = `
      <span class="log-time">${timestamp}</span>
      <span class="log-level ${level}">${level}</span>
      <span class="log-message">${message}</span>
    `;

    container.appendChild(logLine);

    const lines = container.children;
    if (lines.length > this.config.maxLogLines) {
      container.removeChild(lines[0]);
    }

    if (this.autoScroll && this.state.currentTab === 'logs') {
      container.scrollTop = container.scrollHeight;
    }
  }

  displayLogs(entries) {
    const container = document.getElementById('log-output');
    if (!container) return;

    entries.forEach((entry) => {
      try {
        const logData = typeof entry === 'string' ? JSON.parse(entry) : entry;
        this.displayRealLogEntry(logData, container);
      } catch (e) {
        this.displayPlainLogEntry(entry, container);
      }
    });

    const lines = container.children;
    if (lines.length > this.config.maxLogLines) {
      const excess = lines.length - this.config.maxLogLines;
      for (let i = 0; i < excess; i++) {
        container.removeChild(lines[0]);
      }
    }

    if (this.autoScroll && this.state.currentTab === 'logs') {
      container.scrollTop = container.scrollHeight;
    }
  }

  displayRealLogEntry(logData, container) {
    const logLine = document.createElement('div');
    const eventType = this.apiManager.getLogEventType(logData);
    logLine.className = `log-line ${eventType}`;

    const timestamp = this.apiManager.formatLogTimestamp(logData.timestamp);
    const level = this.apiManager.getLogLevel(logData);
    const message = this.apiManager.formatLogMessage(logData);

    logLine.innerHTML = `
      <span class="log-time">${timestamp}</span>
      <span class="log-level ${level}">${level}</span>
      <span class="log-message">${message}</span>
    `;

    container.appendChild(logLine);
  }

  displayPlainLogEntry(entry, container) {
    const logLine = document.createElement('div');
    logLine.className = 'log-line system';

    const now = new Date().toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });

    logLine.innerHTML = `
      <span class="log-time">${now}</span>
      <span class="log-level INFO">INFO</span>
      <span class="log-message">${this.escapeHtml(entry)}</span>
    `;

    container.appendChild(logLine);
  }

  clearLogs() {
    const container = document.getElementById('log-output');
    if (container) {
      container.innerHTML = '';
      this.addLogEntry('INFO', 'Log buffer cleared');
    }
  }

  toggleAutoScroll() {
    this.autoScroll = !this.autoScroll;
    const button = document.getElementById('autoscroll-text');
    if (button) {
      button.textContent = this.autoScroll ? 'Auto-scroll ON' : 'Auto-scroll OFF';
    }
    this.addLogEntry('INFO', `Auto-scroll ${this.autoScroll ? 'enabled' : 'disabled'}`);
  }

  downloadLogs() {
    const logOutput = document.getElementById('log-output');
    if (!logOutput) return;

    const logLines = Array.from(logOutput.children)
      .map((line) => {
        const time = line.querySelector('.log-time')?.textContent || '';
        const level = line.querySelector('.log-level')?.textContent || '';
        const message = line.querySelector('.log-message')?.textContent || '';
        return `${time} ${level} ${message}`;
      })
      .join('\n');

    const blob = new Blob([logLines], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.config.serverName}-${this.config.serverPort}-logs.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    this.addLogEntry('INFO', 'Logs downloaded', 'system');
  }

  // ===== WEBSOCKET & HOT RELOAD =====

  initializeHotReload() {
    this.connectWebSocket();
  }

  connectWebSocket() {
    if (this.websocket?.readyState === WebSocket.OPEN) return;

    const wsUrl = `ws://127.0.0.1:${this.config.serverPort}/ws/hot-reload`;

    try {
      this.websocket = new WebSocket(wsUrl);

      this.websocket.onopen = () => {
        this.websocketConnected = true;
        this.reconnectAttempts = 0;
        this.updateHotReloadStatus('connected');
        console.log('[Hot Reload] Connected');
        this.addLogEntry('SUCCESS', 'Hot Reload connected', 'system');
      };

      this.websocket.onmessage = (event) => {
        try {
          const changeEvent = JSON.parse(event.data);
          this.onFileChange?.(changeEvent);
        } catch (e) {
          console.warn('[Hot Reload] Invalid message:', e);
        }
      };

      this.websocket.onclose = (event) => {
        this.websocketConnected = false;
        this.updateHotReloadStatus('disconnected');

        if (!event.wasClean && !this.state.shutdownNotified) {
          console.log('[Hot Reload] Reconnecting...');
          this.addLogEntry('WARN', 'Hot Reload reconnecting...', 'system');
          this.attemptReconnect();
        }
      };

      this.websocket.onerror = () => {
        this.updateHotReloadStatus('error');
        this.addLogEntry('ERROR', 'Hot Reload error', 'error');
      };
    } catch (error) {
      console.error('[Hot Reload] Connection failed:', error);
      this.updateHotReloadStatus('error');
      this.attemptReconnect();
    }
  }

  attemptReconnect() {
    if (this.state.shutdownNotified || this.reconnectAttempts >= this.config.maxReconnectAttempts)
      return;

    this.reconnectAttempts++;
    const delay = this.config.websocketReconnectDelay * this.reconnectAttempts;

    setTimeout(() => {
      if (!this.state.shutdownNotified) {
        console.log(
          `[Hot Reload] Attempt ${this.reconnectAttempts}/${this.config.maxReconnectAttempts}`,
        );
        this.connectWebSocket();
      }
    }, delay);
  }

  updateHotReloadStatus(status) {
    const statusElement = document.getElementById('hotreload-status');
    const wsStatusElement = document.getElementById('ws-connection-status');

    if (!statusElement) return;

    const statusText = {
      connected: 'Active',
      disconnected: 'Reconnecting',
      error: 'Error',
    };

    statusElement.textContent = statusText[status] || 'Unknown';
    statusElement.className = `hotreload-status ${status}`;

    if (wsStatusElement) {
      wsStatusElement.textContent =
        status === 'connected' ? 'Connected' : status === 'disconnected' ? 'Reconnecting' : 'Error';
      wsStatusElement.className = `status-value ${status}`;
    }

    const reconnectElement = document.getElementById('reconnect-attempts');
    if (reconnectElement) {
      reconnectElement.textContent = this.reconnectAttempts;
    }
  }

  addFileChangeToLog(changeEvent, fileName) {
    const container = document.getElementById('file-changes-log');
    if (!container) return;

    const changeItem = document.createElement('div');
    changeItem.className = 'change-item';

    const timestamp = new Date().toLocaleTimeString('de-DE', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });

    changeItem.innerHTML = `
      <span class="change-time">${timestamp}</span>
      <span class="change-type ${changeEvent.event_type.toLowerCase()}">${changeEvent.event_type.toUpperCase()}</span>
      <span class="change-file">${fileName}</span>
      <span class="change-desc">${changeEvent.file_extension} file changed</span>
    `;

    container.insertBefore(changeItem, container.firstChild);

    while (container.children.length > 20) {
      container.removeChild(container.lastChild);
    }
  }

  triggerPageReload(fileName) {
    this.showReloadNotification(fileName);
    setTimeout(() => {
      console.log('[Hot Reload] Reloading:', fileName);
      window.location.reload();
    }, 500);
  }

  showReloadNotification(fileName) {
    const existing = document.getElementById('hot-reload-notification');
    if (existing) existing.remove();

    const notification = document.createElement('div');
    notification.id = 'hot-reload-notification';
    notification.innerHTML = `
    <div style="position: fixed;top: 11px;right: 11px;background: rgba(0, 212, 255, 0.95);color: #1a1d23;border: 0.1rem solid rgba(255, 255, 255, 0.5);outline: 0.1rem solid rgba(0, 0, 0, 0.5);padding: 7px 13px;border-radius: 3px;font-size: 11px;z-index: 10000;animation: slideIn 0.3s ease-out;">Reloading: ${fileName}</div><style>@keyframes slideIn{from{transform: translateX(100%);opacity: 0;}to{transform: translateX(0);opacity: 1;}}</style>`;

    document.body.appendChild(notification);
    setTimeout(() => notification?.remove(), 3000);
  }

  closeWebSocket() {
    if (this.websocket) {
      this.websocket.close();
      this.websocket = null;
    }
  }

  // ===== EVENT HANDLERS =====

  handleClick(event) {
    event.preventDefault();

    if (event.target.classList.contains('tab-btn')) {
      this.switchTab(event.target.dataset.tab);
    } else if (event.target.classList.contains('test-btn')) {
      if (this.apiManager) {
        this.apiManager.testEndpoint(event.target.dataset.url, event.target);
      }
    } else if (event.target.hasAttribute('data-action')) {
      const action = event.target.dataset.action;
      const data = event.target.dataset;

      console.log('[UI] Action:', action);

      // Handle UI-specific actions
      if (action === 'simulate-file-change') {
        // This will be handled by app controller
        this.onAction?.(action, data);
      } else {
        // Pass other actions to app controller
        this.onAction?.(action, data);
      }
    } else if (event.target.classList.contains('terminal-btn')) {
      this.handleTerminalButton(event.target);
    }
  }

  handleTerminalButton(button) {
    const text = button.textContent.trim();
    if (text === 'Clear') {
      this.clearLogs();
    } else if (text.includes('Auto-scroll')) {
      this.toggleAutoScroll();
    } else if (text === 'Download Log') {
      this.downloadLogs();
    }
  }

  // ===== NOTIFICATIONS =====

  showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      padding: 12px 16px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 13px;
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    `;
    notification.textContent = message;

    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
  }

  showServerShutdownScreen() {
    document.body.innerHTML = `
      <div style="position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);text-align: center;padding: 30px;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;background: rgba(0, 212, 255, 0.25);color: #ffffff;display: flex;flex-direction: column;justify-content: center;align-items: center;border-radius: 11px;">
        <div style="border: 2px solid #00d4ff;padding: 30px;border-radius: 6px;max-width: 500px;background: #000000;">
          <h1 style="margin: 0 0 20px 0;color: #ff4757;font-size: 24px;font-weight: 600;text-transform: uppercase;">Server Stopped</h1>
          <p style="margin: 10px 0; font-size: 16px; color: #ffffff; line-height: 1.4">Server '<strong style="color: #00d4ff">${this.config.serverName}</strong>' on port <strong style="color: #00d4ff">${this.config.serverPort}</strong> stopped.</p>
          <p style="margin: 20px 0; font-size: 14px; color: #a0a6b1">Closing in <span id="countdown" style="color: #ff4757; font-weight: 600">3</span> seconds...</p>
          <button onclick="window.close()" style="margin-top: 20px;padding: 10px 20px;background: #00d4ff;color: #1a1d23;border: none;cursor: pointer;border-radius: 5px;font-size: 12px;font-weight: 600;text-transform: uppercase;">Close Tab Now</button>
        </div>
      </div>`;

    let countdown = 3;
    const countdownElement = document.getElementById('countdown');
    const timer = setInterval(() => {
      countdown--;
      if (countdownElement) countdownElement.textContent = countdown;
      if (countdown <= 0) {
        clearInterval(timer);
        this.attemptBrowserClose();
      }
    }, 1000);
  }

  attemptBrowserClose() {
    console.log('[UI] Closing tab');
    try {
      window.close();
      setTimeout(() => {
        if (!window.closed) {
          window.location.href = 'about:blank';
        }
      }, 500);
    } catch (e) {
      console.warn('[UI] Close failed, redirecting:', e);
      window.location.href = 'about:blank';
    }
  }

  // ===== UTILITIES =====

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  // ===== CLEANUP =====

  cleanup() {
    this.closeWebSocket();
    console.log('[UI] Cleanup completed');
  }
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/js/rush-api.js
// ## BEGIN ##
/**
 * Rush Sync API Manager
 * HTTP Requests, Server Monitoring, Log Loading, Health Checks, Statistics
 */

export class ApiManager {
  constructor(config, state) {
    this.config = config;
    this.state = state;
    this.intervals = {};

    // API state
    this.apiState = {
      lastLogCheck: 0,
      logFileSize: 0,
      realLogs: [],
    };

    // Callbacks to App Controller
    this.onServerShutdown = null;
    this.onStatsUpdate = null;
    this.onLogsUpdate = null;
    this.onServerStatusChange = null;
  }

  // ===== HEALTH & STATUS =====

  async checkServerStatus() {
    try {
      const response = await this.request('/api/health', {
        signal: AbortSignal.timeout(3000),
      });

      if (response.ok) {
        this.updateStatusUI('running', 'Online');
        if (!this.state.serverAlive) {
          this.state.serverAlive = true;
          this.onServerStatusChange?.(true);
        }
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      this.updateStatusUI('error', 'Offline');
      console.warn('[API] Status check failed:', error);

      if (this.state.serverAlive) {
        this.state.serverAlive = false;
        this.onServerStatusChange?.(false);
      }
    }
  }

  updateStatusUI(status, text) {
    const statusDot = document.querySelector('.status-dot');
    const statusText = document.querySelector('.status-text');

    if (statusDot) statusDot.setAttribute('data-status', status);
    if (statusText) statusText.textContent = text;
  }

  startServerHealthCheck() {
    this.intervals.healthCheck = setInterval(
      () => this.checkServerHealthInternal(),
      this.config.serverHealthCheckInterval,
    );
  }

  async checkServerHealthInternal() {
    if (this.state.shutdownNotified) return;

    try {
      const response = await this.request('/api/health', {
        signal: AbortSignal.timeout(1500),
      });

      if (!response.ok) throw new Error(`Server returned ${response.status}`);

      if (!this.state.serverAlive) {
        this.state.serverAlive = true;
        console.log('[API] Connection restored');
      }
    } catch (error) {
      if (this.state.serverAlive) {
        this.state.serverAlive = false;
        console.log('[API] Connection lost:', error.message);
        this.onServerShutdown?.();
      }
    }
  }

  // ===== METRICS & STATISTICS =====

  async loadInitialMetrics() {
    try {
      const response = await this.request('/api/stats');
      if (response.ok) {
        const data = await response.json();
        this.onStatsUpdate?.(data);
      }
    } catch (e) {
      console.warn('[API] Initial metrics failed:', e);
    }
  }

  async updateMetrics() {
    try {
      const response = await this.request('/api/stats');
      if (response.ok) {
        const data = await response.json();
        this.onStatsUpdate?.(data);
      }
    } catch (e) {
      console.warn('[API] Metrics update failed:', e);
    }
  }

  async loadMetrics() {
    this.updateMetrics();
  }

  // ===== REAL LOG SYSTEM =====

  startRealLogMonitoring() {
    this.intervals.realLogs = setInterval(() => {
      if (this.state.currentTab === 'logs') {
        this.loadRealLogs();
      }
    }, this.config.logRefreshInterval);
  }

  async loadRealLogs() {
    try {
      const response = await this.request('/api/logs/raw', {
        headers: {
          Accept: 'application/json',
          'X-Log-Size': this.apiState.logFileSize.toString(),
        },
      });

      if (response.ok) {
        const data = await response.json();

        if (data.new_entries && data.new_entries.length > 0) {
          this.processRealLogEntries(data.new_entries);
          this.apiState.logFileSize = data.file_size || this.apiState.logFileSize;
        }

        if (data.stats) {
          this.updateLogStats(data.stats);
        }
      }
    } catch (error) {
      console.warn('[API] Real log loading failed:', error);
    }
  }

  processRealLogEntries(entries) {
    this.onLogsUpdate?.(entries);
  }

  updateLogStats(stats) {
    if (stats.total_requests !== undefined) {
      const requestElement = document.getElementById('request-count');
      if (requestElement) requestElement.textContent = stats.total_requests;
    }

    if (stats.error_requests !== undefined) {
      const errorElement = document.getElementById('error-count');
      if (errorElement) errorElement.textContent = stats.error_requests;
    }
  }

  getLogEventType(logData) {
    switch (logData.event_type) {
      case 'Request':
        return 'request';
      case 'ServerError':
        return 'error';
      case 'SecurityAlert':
        return 'security';
      case 'PerformanceWarning':
        return 'performance';
      default:
        return 'system';
    }
  }

  getLogLevel(logData) {
    if (logData.event_type === 'ServerError') return 'ERROR';
    if (logData.event_type === 'SecurityAlert') return 'WARN';
    if (logData.event_type === 'PerformanceWarning') return 'WARN';
    if (logData.status_code >= 400) return 'WARN';
    if (logData.status_code >= 200 && logData.status_code < 300) return 'SUCCESS';
    return 'INFO';
  }

  formatLogMessage(logData) {
    if (logData.event_type === 'Request') {
      const responseTime = logData.response_time_ms ? ` - ${logData.response_time_ms}ms` : '';
      const bytes = logData.bytes_sent ? ` - ${this.formatBytes(logData.bytes_sent)}` : '';
      return `${logData.method} ${logData.path} - ${logData.status_code}${responseTime}${bytes} [${logData.ip_address}]`;
    }

    if (logData.event_type === 'SecurityAlert') {
      return `Security Alert: ${logData.headers?.alert_reason || 'Unknown'} - ${
        logData.headers?.alert_details || logData.path
      }`;
    }

    if (logData.event_type === 'PerformanceWarning') {
      return `Performance Warning: ${logData.headers?.metric || 'Response time'} = ${
        logData.response_time_ms
      }ms (threshold exceeded)`;
    }

    if (logData.event_type === 'ServerStart') {
      return `Server started on port ${this.config.serverPort}`;
    }

    if (logData.event_type === 'ServerStop') {
      return `Server stopped gracefully`;
    }

    if (logData.event_type === 'ServerError') {
      return `Server Error: ${logData.path} - ${
        logData.headers?.error_message || 'Internal error'
      }`;
    }

    return logData.path || 'System event';
  }

  formatLogTimestamp(timestamp) {
    if (!timestamp) return new Date().toLocaleTimeString('de-DE');

    try {
      const date = new Date(timestamp);
      return date.toLocaleTimeString('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3,
      });
    } catch (e) {
      return timestamp.substring(11, 23) || new Date().toLocaleTimeString('de-DE');
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  // ===== LOG LOADING =====

  async loadLogs() {
    try {
      const response = await this.request('/api/stats');
      if (response.ok) {
        const data = await response.json();

        // Simulate some log entries based on stats
        if (data.total_requests > this.state.requests) {
          const newRequests = data.total_requests - this.state.requests;
          for (let i = 0; i < Math.min(newRequests, 5); i++) {
            // This would be handled by UI manager
          }
        }

        this.state.requests = data.total_requests;
        this.onStatsUpdate?.(data);
      }
    } catch (e) {
      console.warn('[API] Stats fetch failed:', e);
    }
  }

  async pollLogs() {
    if (Math.random() < 0.3) {
      // Simulate activity - this would be handled by UI manager
    }
  }

  // ===== ENDPOINT TESTING =====

  async testEndpoint(url, button) {
    const originalText = button.textContent;
    button.textContent = '...';
    button.disabled = true;

    try {
      // FIX: Nur relative URLs oder lokale URLs testen
      let testUrl = url;

      // Externe URLs umleiten auf lokale Tests
      if (url.includes('localhost:') && !url.includes('127.0.0.1')) {
        // Externe Proxy URLs -> lokale API URLs f√ºr Test
        if (url.includes(this.config.proxyHttpsPort)) {
          testUrl = '/api/status'; // Test lokale API statt externe URL
        } else if (url.includes(this.config.proxyHttpPort)) {
          testUrl = '/api/health'; // Test lokale API statt externe URL
        }
      }

      console.log(`[API] Testing: ${url} -> ${testUrl}`);

      const response = await this.request(testUrl);

      if (response.ok) {
        button.textContent = 'OK';
        button.style.background = 'var(--accent-success)';
        console.log(`[API] ${url} - ${response.status} OK`);

        // Nur bei erfolgreichen lokalen URLs das Original √∂ffnen
        if (testUrl === url) {
          setTimeout(() => window.open(url, '_blank'), 500);
        } else {
          // Bei Proxy URLs das Original √∂ffnen (wird extern getestet)
          setTimeout(() => window.open(url, '_blank'), 500);
        }
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      button.textContent = 'ERR';
      button.style.background = 'var(--accent-error)';
      console.error(`[API] ${url} - ${error.message}`);
    }

    setTimeout(() => {
      button.textContent = originalText;
      button.style.background = '';
      button.disabled = false;
    }, 2000);
  }

  async testAllEndpoints() {
    console.log('[API] Testing all endpoints...');
    const endpoints = ['/api/status', '/api/health', '/api/info', '/api/metrics'];

    for (const endpoint of endpoints) {
      try {
        const response = await this.request(endpoint, {
          signal: AbortSignal.timeout(5000),
        });

        const status = response.ok ? 'PASS' : 'FAIL';
        const statusText = `${response.status} ${response.statusText}`;

        console.log(`[API] ${endpoint}: ${status} - ${statusText}`);
      } catch (e) {
        console.error(`[API] ${endpoint} failed:`, e);
      }

      await new Promise((resolve) => setTimeout(resolve, 300));
    }

    console.log('[API] All endpoints tested');
  }

  // ===== GENERIC HTTP =====

  async request(url, options = {}) {
    try {
      const response = await fetch(url, {
        cache: 'no-cache',
        ...options,
      });

      if (!response.ok && !options.allowErrors) {
        throw new Error(`HTTP ${response.status}`);
      }

      return response;
    } catch (error) {
      console.error('[API] Request failed:', url, error);
      throw error;
    }
  }

  // ===== MONITORING CONTROL =====

  stopMonitoring() {
    Object.values(this.intervals).forEach((interval) => interval && clearInterval(interval));
    this.intervals = {};
    console.log('[API] Monitoring stopped');
  }
}

// ## END ##

// ## FILE: src/server/handlers/templates/rss/js/rush-app.js
// ## BEGIN ##
/**
 * Rush Sync App Controller
 * Zentrale Koordination, Configuration, State Management
 */

import { ApiManager } from '/.rss/js/rush-api.js';
import { UIManager } from '/.rss/js/rush-ui.js';

export class RushSyncApp {
  constructor() {
    // Template-Replacement pr√ºfen und korrigieren
    this.config = this.parseAndValidateConfig();

    // Enhanced State
    this.state = {
      currentTab: 'overview',
      logs: [],
      metrics: {},
      requests: 0,
      errors: 0,
      uptime: 0,
      serverAlive: true,
      shutdownNotified: false,
      lastReloadTime: 0,
      lastLogCheck: 0,
      realLogs: [],
      logFileSize: 0,
    };

    this.intervals = {};
    this.startTime = Date.now();

    // Initialize Managers
    this.api = new ApiManager(this.config, this.state);
    this.ui = new UIManager(this.config, this.state);

    // Setup inter-module communication
    this.setupCallbacks();

    this.init();
  }

  parseAndValidateConfig() {
    const windowConfig = window.RUSH_CONFIG || {};

    // Template-Replacement Detection und Korrektur
    const serverName = this.validateTemplateValue(windowConfig.serverName, 'rss-001');
    const serverPort = this.validateTemplateValue(windowConfig.serverPort, '8000');
    const proxyHttpPort = this.validateTemplateValue(windowConfig.proxyHttpPort, '3000');
    const proxyHttpsPort = this.validateTemplateValue(windowConfig.proxyHttpsPort, '3443');

    const config = {
      statusInterval: 5000,
      logPollInterval: 3000,
      metricsInterval: 10000,
      maxLogLines: 1000,
      autoScroll: true,
      serverHealthCheckInterval: 2000,
      websocketReconnectDelay: 1000,
      maxReconnectAttempts: 10,
      hotReloadDebounce: 250,
      logRefreshInterval: 2000,

      // Validated template values
      serverName,
      serverPort,
      proxyHttpPort,
      proxyHttpsPort,
    };

    // Debug-Ausgabe
    console.log('[App] Template validation:', {
      raw: windowConfig,
      validated: {
        serverName: config.serverName,
        serverPort: config.serverPort,
        proxyHttpPort: config.proxyHttpPort,
        proxyHttpsPort: config.proxyHttpsPort,
      },
    });

    return config;
  }

  validateTemplateValue(value, fallback) {
    // Pr√ºfe auf nicht-ersetzte Template-Platzhalter
    if (!value || typeof value !== 'string' || value.includes('{{') || value.includes('}}')) {
      console.warn(
        '[App] Template replacement failed for value:',
        value,
        'using fallback:',
        fallback,
      );
      return fallback;
    }
    return value;
  }

  setupCallbacks() {
    // API ‚Üí App callbacks
    this.api.onServerShutdown = () => this.handleServerShutdown();
    this.api.onStatsUpdate = (data) => this.handleStatsUpdate(data);
    this.api.onLogsUpdate = (logs) => this.handleLogsUpdate(logs);
    this.api.onServerStatusChange = (alive) => this.handleServerStatusChange(alive);

    // UI ‚Üí App callbacks
    this.ui.onTabSwitch = (tab) => this.handleTabSwitch(tab);
    this.ui.onFileChange = (event) => this.handleFileChange(event);
    this.ui.onAction = (action, data) => this.handleUIAction(action, data);

    // App ‚Üí UI data flow
    this.ui.setApiManager(this.api);
  }

  init() {
    console.log('[Rush Sync] Initializing with validated config:', {
      server: this.config.serverName,
      port: this.config.serverPort,
      proxyHttp: this.config.proxyHttpPort,
      proxyHttps: this.config.proxyHttpsPort,
    });

    this.setupEventListeners();
    this.ui.initializeTabs();
    this.formatCreationTime();
    this.startAllMonitoring();
    this.ui.initializeHotReload();
    this.api.startRealLogMonitoring();

    // Global exposure for debugging
    window.RushApp = this;

    console.log('[Rush Sync] Dashboard initialized with Enhanced Logging');
    this.ui.addLogEntry(
      'INFO',
      `Enhanced Dashboard loaded - Proxy HTTP:${this.config.proxyHttpPort} HTTPS:${this.config.proxyHttpsPort}`,
    );
  }

  // ===== EVENT COORDINATION =====

  setupEventListeners() {
    document.addEventListener('DOMContentLoaded', () => this.onDOMReady());
    window.addEventListener('beforeunload', () => this.cleanup());

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pauseMonitoring();
      } else {
        this.resumeMonitoring();
      }
    });

    // Delegate all clicks to UI manager
    document.addEventListener('click', (e) => this.ui.handleClick(e));
  }

  onDOMReady() {
    this.api.checkServerStatus();
    this.api.loadInitialMetrics();
  }

  // ===== CALLBACK HANDLERS =====

  handleTabSwitch(tab) {
    this.state.currentTab = tab;

    if (tab === 'logs') {
      this.api.loadLogs();
      this.api.loadRealLogs();
    } else if (tab === 'metrics') {
      this.api.loadMetrics();
    }
  }

  handleFileChange(changeEvent) {
    const now = Date.now();
    if (now - this.state.lastReloadTime < this.config.hotReloadDebounce) return;

    console.log('[Hot Reload] File change:', changeEvent);

    const fileName = changeEvent.file_path.split('/').pop() || 'unknown';
    this.ui.addLogEntry('INFO', `File ${changeEvent.event_type}: ${fileName}`, 'hotreload');

    this.ui.addFileChangeToLog(changeEvent, fileName);

    if (this.shouldTriggerReload(changeEvent)) {
      this.state.lastReloadTime = now;
      this.ui.triggerPageReload(fileName);
    }
  }

  shouldTriggerReload(changeEvent) {
    const extension = changeEvent.file_extension?.toLowerCase();
    const webExtensions = [
      'html',
      'css',
      'js',
      'json',
      'txt',
      'md',
      'svg',
      'png',
      'jpg',
      'jpeg',
      'gif',
      'ico',
    ];
    return webExtensions.includes(extension) && changeEvent.event_type !== 'deleted';
  }

  handleStatsUpdate(data) {
    this.ui.updateStatsDisplay(data);
    if (this.state.currentTab === 'metrics') {
      this.ui.updateMetricsTab(data);
    }
  }

  handleLogsUpdate(logs) {
    this.state.realLogs = logs;
    if (this.state.currentTab === 'logs') {
      this.ui.displayLogs(logs);
    }
  }

  handleServerStatusChange(alive) {
    this.state.serverAlive = alive;
    if (!alive && !this.state.shutdownNotified) {
      this.handleServerShutdown();
    }
  }

  handleUIAction(action, data) {
    console.log('[App] Action:', action);

    switch (action) {
      case 'view-http':
        window.open(`http://127.0.0.1:${this.config.serverPort}`, '_blank');
        break;
      case 'view-proxy':
        // Validierte Config verwenden
        window.open(
          `https://${this.config.serverName}.localhost:${this.config.proxyHttpsPort}`,
          '_blank',
        );
        break;
      case 'view-proxy-http':
        window.open(
          `http://${this.config.serverName}.localhost:${this.config.proxyHttpPort}`,
          '_blank',
        );
        break;
      case 'test-apis':
        this.api.testAllEndpoints();
        break;
      case 'refresh-stats':
        this.refreshStats();
        break;
      case 'simulate-file-change':
        this.simulateFileChange();
        break;
      default:
        console.warn('[Rush Sync] Unknown action:', action);
    }
  }

  // ===== MONITORING =====

  startAllMonitoring() {
    this.intervals.status = setInterval(
      () => this.api.checkServerStatus(),
      this.config.statusInterval,
    );
    this.intervals.uptime = setInterval(() => this.updateUptime(), 1000);
    this.intervals.logs = setInterval(() => {
      if (this.state.currentTab === 'logs') this.api.pollLogs();
    }, this.config.logPollInterval);
    this.intervals.metrics = setInterval(
      () => this.api.updateMetrics(),
      this.config.metricsInterval,
    );
    this.api.startServerHealthCheck();
  }

  pauseMonitoring() {
    Object.values(this.intervals).forEach((interval) => interval && clearInterval(interval));
    this.intervals = {};
  }

  resumeMonitoring() {
    this.startAllMonitoring();
    this.api.startServerHealthCheck();
  }

  // ===== SERVER LIFECYCLE =====

  handleServerShutdown() {
    if (this.state.shutdownNotified) return;

    this.state.shutdownNotified = true;
    console.log('[Rush Sync] Server shutdown detected');

    this.ui.closeWebSocket();
    this.cleanup();
    this.ui.showServerShutdownScreen();
  }

  // ===== UTILITIES =====

  updateUptime() {
    const element = document.getElementById('uptime');
    if (element) {
      element.textContent = this.formatUptime(Date.now() - this.startTime);
    }
  }

  formatUptime(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}d ${hours % 24}h`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  formatCreationTime() {
    const element = document.getElementById('creation-time');
    if (!element || element.textContent === '{{CREATION_TIME}}') return;

    try {
      const date = new Date(element.textContent);
      if (!isNaN(date.getTime())) {
        element.textContent = date.toLocaleString('de-DE', {
          day: '2-digit',
          month: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
        });
      }
    } catch (e) {
      console.warn('[Rush Sync] Time format failed:', e);
    }
  }

  async refreshStats() {
    console.log('[Rush Sync] Refreshing stats...');
    this.ui.addLogEntry('INFO', 'Refreshing all stats...');

    try {
      await this.api.updateMetrics();
      await this.api.checkServerStatus();

      if (this.state.currentTab === 'logs') {
        this.api.loadLogs();
        this.api.loadRealLogs();
      }

      this.ui.addLogEntry('SUCCESS', 'Stats refreshed successfully');
      console.log('[Rush Sync] Stats refresh completed');
    } catch (error) {
      this.ui.addLogEntry('ERROR', `Stats refresh failed: ${error.message}`);
      console.error('[Rush Sync] Stats refresh failed:', error);
    }
  }

  simulateFileChange() {
    this.ui.addLogEntry('INFO', 'Simulating file change...', 'hotreload');

    const mockEvent = {
      event_type: 'modified',
      file_path: 'www/test-file.html',
      server_name: this.config.serverName,
      port: this.config.serverPort,
      timestamp: Math.floor(Date.now() / 1000),
      file_extension: 'html',
    };

    this.handleFileChange(mockEvent);
  }

  // ===== CLEANUP =====

  cleanup() {
    this.pauseMonitoring();
    this.api.stopMonitoring();
    this.ui.cleanup();
    console.log('[Rush Sync] Cleanup completed');
  }
}

// ## END ##

